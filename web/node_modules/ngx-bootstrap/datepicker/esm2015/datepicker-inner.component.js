/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable: max-file-line-count */
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { DateFormatter } from './date-formatter';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function DatePickerInnerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} }
const _c0 = ["*"];
export class DatePickerInnerComponent {
    constructor() {
        this.selectionDone = new EventEmitter(undefined);
        this.update = new EventEmitter(false);
        this.activeDateChange = new EventEmitter(undefined);
        /* tslint:disable-next-line: no-any*/
        this.stepDay = {};
        /* tslint:disable-next-line: no-any*/
        this.stepMonth = {};
        /* tslint:disable-next-line: no-any*/
        this.stepYear = {};
        this.modes = ['day', 'month', 'year'];
        this.dateFormatter = new DateFormatter();
    }
    /**
     * @return {?}
     */
    get activeDate() {
        return this._activeDate;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set activeDate(value) {
        this._activeDate = value;
    }
    // todo: add formatter value to Date object
    /**
     * @return {?}
     */
    ngOnInit() {
        // todo: use date for unique value
        this.uniqueId = `datepicker--${Math.floor(Math.random() * 10000)}`;
        if (this.initDate) {
            this.activeDate = this.initDate;
            this.selectedDate = new Date(this.activeDate.valueOf());
            this.update.emit(this.activeDate);
        }
        else if (this.activeDate === undefined) {
            this.activeDate = new Date();
        }
    }
    // this.refreshView should be called here to reflect the changes on the fly
    // tslint:disable-next-line:no-unused-variable
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.refreshView();
        this.checkIfActiveDateGotUpdated(changes.activeDate);
    }
    // Check if activeDate has been update and then emit the activeDateChange with the new date
    /* tslint:disable-next-line: no-any */
    /**
     * @param {?} activeDate
     * @return {?}
     */
    checkIfActiveDateGotUpdated(activeDate) {
        if (activeDate && !activeDate.firstChange) {
            /** @type {?} */
            const previousValue = activeDate.previousValue;
            if (previousValue &&
                previousValue instanceof Date &&
                previousValue.getTime() !== activeDate.currentValue.getTime()) {
                this.activeDateChange.emit(this.activeDate);
            }
        }
    }
    /**
     * @param {?} handler
     * @param {?} type
     * @return {?}
     */
    setCompareHandler(handler, type) {
        if (type === 'day') {
            this.compareHandlerDay = handler;
        }
        if (type === 'month') {
            this.compareHandlerMonth = handler;
        }
        if (type === 'year') {
            this.compareHandlerYear = handler;
        }
    }
    /**
     * @param {?} date1
     * @param {?} date2
     * @return {?}
     */
    compare(date1, date2) {
        if (date1 === undefined || date2 === undefined) {
            return undefined;
        }
        if (this.datepickerMode === 'day' && this.compareHandlerDay) {
            return this.compareHandlerDay(date1, date2);
        }
        if (this.datepickerMode === 'month' && this.compareHandlerMonth) {
            return this.compareHandlerMonth(date1, date2);
        }
        if (this.datepickerMode === 'year' && this.compareHandlerYear) {
            return this.compareHandlerYear(date1, date2);
        }
        return void 0;
    }
    /**
     * @param {?} handler
     * @param {?} type
     * @return {?}
     */
    setRefreshViewHandler(handler, type) {
        if (type === 'day') {
            this.refreshViewHandlerDay = handler;
        }
        if (type === 'month') {
            this.refreshViewHandlerMonth = handler;
        }
        if (type === 'year') {
            this.refreshViewHandlerYear = handler;
        }
    }
    /**
     * @return {?}
     */
    refreshView() {
        if (this.datepickerMode === 'day' && this.refreshViewHandlerDay) {
            this.refreshViewHandlerDay();
        }
        if (this.datepickerMode === 'month' && this.refreshViewHandlerMonth) {
            this.refreshViewHandlerMonth();
        }
        if (this.datepickerMode === 'year' && this.refreshViewHandlerYear) {
            this.refreshViewHandlerYear();
        }
    }
    /**
     * @param {?} date
     * @param {?} format
     * @return {?}
     */
    dateFilter(date, format) {
        return this.dateFormatter.format(date, format, this.locale);
    }
    /* tslint:disable-next-line: no-any*/
    /**
     * @param {?} dateObject
     * @return {?}
     */
    isActive(dateObject) {
        if (this.compare(dateObject.date, this.activeDate) === 0) {
            this.activeDateId = dateObject.uid;
            return true;
        }
        return false;
    }
    /* tslint:disable-next-line: no-any*/
    /**
     * @param {?} date
     * @param {?} format
     * @return {?}
     */
    createDateObject(date, format) {
        /* tslint:disable-next-line: no-any*/
        /** @type {?} */
        const dateObject = {};
        dateObject.date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        dateObject.date = this.fixTimeZone(dateObject.date);
        dateObject.label = this.dateFilter(date, format);
        dateObject.selected = this.compare(date, this.selectedDate) === 0;
        dateObject.disabled = this.isDisabled(date);
        dateObject.current = this.compare(date, new Date()) === 0;
        dateObject.customClass = this.getCustomClassForDate(dateObject.date);
        return dateObject;
    }
    /* tslint:disable-next-line: no-any*/
    /**
     * @param {?} arr
     * @param {?} size
     * @return {?}
     */
    split(arr, size) {
        /* tslint:disable-next-line: no-any*/
        /** @type {?} */
        const arrays = [];
        while (arr.length > 0) {
            arrays.push(arr.splice(0, size));
        }
        return arrays;
    }
    // Fix a hard-reproducible bug with timezones
    // The bug depends on OS, browser, current timezone and current date
    // i.e.
    // var date = new Date(2014, 0, 1);
    // console.log(date.getFullYear(), date.getMonth(), date.getDate(),
    // date.getHours()); can result in "2013 11 31 23" because of the bug.
    /**
     * @param {?} date
     * @return {?}
     */
    fixTimeZone(date) {
        /** @type {?} */
        const hours = date.getHours();
        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours === 23 ? hours + 2 : 0);
    }
    /**
     * @param {?} date
     * @param {?=} isManual
     * @return {?}
     */
    select(date, isManual = true) {
        if (this.datepickerMode === this.minMode) {
            if (!this.activeDate) {
                this.activeDate = new Date(0, 0, 0, 0, 0, 0, 0);
            }
            this.activeDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            this.activeDate = this.fixTimeZone(this.activeDate);
            if (isManual) {
                this.selectionDone.emit(this.activeDate);
            }
        }
        else {
            this.activeDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            this.activeDate = this.fixTimeZone(this.activeDate);
            if (isManual) {
                this.datepickerMode = this.modes[this.modes.indexOf(this.datepickerMode) - 1];
            }
        }
        this.selectedDate = new Date(this.activeDate.valueOf());
        this.update.emit(this.activeDate);
        this.refreshView();
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    move(direction) {
        /* tslint:disable-next-line: no-any*/
        /** @type {?} */
        let expectedStep;
        if (this.datepickerMode === 'day') {
            expectedStep = this.stepDay;
        }
        if (this.datepickerMode === 'month') {
            expectedStep = this.stepMonth;
        }
        if (this.datepickerMode === 'year') {
            expectedStep = this.stepYear;
        }
        if (expectedStep) {
            /** @type {?} */
            const year = this.activeDate.getFullYear() + direction * (expectedStep.years || 0);
            /** @type {?} */
            const month = this.activeDate.getMonth() + direction * (expectedStep.months || 0);
            this.activeDate = new Date(year, month, 1);
            this.refreshView();
            this.activeDateChange.emit(this.activeDate);
        }
    }
    /**
     * @param {?} _direction
     * @return {?}
     */
    toggleMode(_direction) {
        /** @type {?} */
        const direction = _direction || 1;
        if ((this.datepickerMode === this.maxMode && direction === 1) ||
            (this.datepickerMode === this.minMode && direction === -1)) {
            return;
        }
        this.datepickerMode = this.modes[this.modes.indexOf(this.datepickerMode) + direction];
        this.refreshView();
    }
    /**
     * @protected
     * @param {?} date
     * @return {?}
     */
    getCustomClassForDate(date) {
        if (!this.customClass) {
            return '';
        }
        // todo: build a hash of custom classes, it will work faster
        /** @type {?} */
        const customClassObject = this.customClass.find((/**
         * @param {?} customClass
         * @return {?}
         */
        (customClass) => {
            return (customClass.date.valueOf() === date.valueOf() &&
                customClass.mode === this.datepickerMode);
        }), this);
        return customClassObject === undefined ? '' : customClassObject.clazz;
    }
    /**
     * @protected
     * @param {?} date1Disabled
     * @param {?} date2
     * @return {?}
     */
    compareDateDisabled(date1Disabled, date2) {
        if (date1Disabled === undefined || date2 === undefined) {
            return undefined;
        }
        if (date1Disabled.mode === 'day' && this.compareHandlerDay) {
            return this.compareHandlerDay(date1Disabled.date, date2);
        }
        if (date1Disabled.mode === 'month' && this.compareHandlerMonth) {
            return this.compareHandlerMonth(date1Disabled.date, date2);
        }
        if (date1Disabled.mode === 'year' && this.compareHandlerYear) {
            return this.compareHandlerYear(date1Disabled.date, date2);
        }
        return undefined;
    }
    /**
     * @protected
     * @param {?} date
     * @return {?}
     */
    isDisabled(date) {
        /** @type {?} */
        let isDateDisabled = false;
        if (this.dateDisabled) {
            this.dateDisabled.forEach((/**
             * @param {?} disabledDate
             * @return {?}
             */
            (disabledDate) => {
                if (this.compareDateDisabled(disabledDate, date) === 0) {
                    isDateDisabled = true;
                }
            }));
        }
        if (this.dayDisabled) {
            isDateDisabled =
                isDateDisabled ||
                    this.dayDisabled.indexOf(date.getDay()) > -1;
        }
        return (isDateDisabled ||
            (this.minDate && this.compare(date, this.minDate) < 0) ||
            (this.maxDate && this.compare(date, this.maxDate) > 0));
    }
}
DatePickerInnerComponent.ɵfac = function DatePickerInnerComponent_Factory(t) { return new (t || DatePickerInnerComponent)(); };
DatePickerInnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DatePickerInnerComponent, selectors: [["datepicker-inner"]], inputs: { activeDate: "activeDate", datepickerMode: "datepickerMode", locale: "locale", startingDay: "startingDay", yearRange: "yearRange", minDate: "minDate", maxDate: "maxDate", minMode: "minMode", maxMode: "maxMode", showWeeks: "showWeeks", formatDay: "formatDay", formatMonth: "formatMonth", formatYear: "formatYear", formatDayHeader: "formatDayHeader", formatDayTitle: "formatDayTitle", formatMonthTitle: "formatMonthTitle", onlyCurrentMonth: "onlyCurrentMonth", shortcutPropagation: "shortcutPropagation", customClass: "customClass", monthColLimit: "monthColLimit", yearColLimit: "yearColLimit", dateDisabled: "dateDisabled", dayDisabled: "dayDisabled", initDate: "initDate" }, outputs: { selectionDone: "selectionDone", update: "update", activeDateChange: "activeDateChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c0, decls: 1, vars: 1, consts: [["class", "well well-sm bg-faded p-a card", "role", "application", 4, "ngIf"], ["role", "application", 1, "well", "well-sm", "bg-faded", "p-a", "card"]], template: function DatePickerInnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, DatePickerInnerComponent_div_0_Template, 2, 0, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.datepickerMode);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
DatePickerInnerComponent.propDecorators = {
    locale: [{ type: Input }],
    datepickerMode: [{ type: Input }],
    startingDay: [{ type: Input }],
    yearRange: [{ type: Input }],
    minDate: [{ type: Input }],
    maxDate: [{ type: Input }],
    minMode: [{ type: Input }],
    maxMode: [{ type: Input }],
    showWeeks: [{ type: Input }],
    formatDay: [{ type: Input }],
    formatMonth: [{ type: Input }],
    formatYear: [{ type: Input }],
    formatDayHeader: [{ type: Input }],
    formatDayTitle: [{ type: Input }],
    formatMonthTitle: [{ type: Input }],
    onlyCurrentMonth: [{ type: Input }],
    shortcutPropagation: [{ type: Input }],
    customClass: [{ type: Input }],
    monthColLimit: [{ type: Input }],
    yearColLimit: [{ type: Input }],
    dateDisabled: [{ type: Input }],
    dayDisabled: [{ type: Input }],
    initDate: [{ type: Input }],
    selectionDone: [{ type: Output }],
    update: [{ type: Output }],
    activeDateChange: [{ type: Output }],
    activeDate: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePickerInnerComponent, [{
        type: Component,
        args: [{
                selector: 'datepicker-inner',
                template: `
    <!--&lt;!&ndash;ng-keydown="keydown($event)"&ndash;&gt;-->
    <div *ngIf="datepickerMode" class="well well-sm bg-faded p-a card" role="application" >
      <ng-content></ng-content>
    </div>
  `
            }]
    }], function () { return []; }, { selectionDone: [{
            type: Output
        }], update: [{
            type: Output
        }], activeDateChange: [{
            type: Output
        }], activeDate: [{
            type: Input
        }], datepickerMode: [{
            type: Input
        }], locale: [{
            type: Input
        }], startingDay: [{
            type: Input
        }], yearRange: [{
            type: Input
        }], minDate: [{
            type: Input
        }], maxDate: [{
            type: Input
        }], minMode: [{
            type: Input
        }], maxMode: [{
            type: Input
        }], showWeeks: [{
            type: Input
        }], formatDay: [{
            type: Input
        }], formatMonth: [{
            type: Input
        }], formatYear: [{
            type: Input
        }], formatDayHeader: [{
            type: Input
        }], formatDayTitle: [{
            type: Input
        }], formatMonthTitle: [{
            type: Input
        }], onlyCurrentMonth: [{
            type: Input
        }], shortcutPropagation: [{
            type: Input
        }], customClass: [{
            type: Input
        }], monthColLimit: [{
            type: Input
        }], yearColLimit: [{
            type: Input
        }], dateDisabled: [{
            type: Input
        }], dayDisabled: [{
            type: Input
        }], initDate: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    DatePickerInnerComponent.prototype.locale;
    /** @type {?} */
    DatePickerInnerComponent.prototype.datepickerMode;
    /** @type {?} */
    DatePickerInnerComponent.prototype.startingDay;
    /** @type {?} */
    DatePickerInnerComponent.prototype.yearRange;
    /** @type {?} */
    DatePickerInnerComponent.prototype.minDate;
    /** @type {?} */
    DatePickerInnerComponent.prototype.maxDate;
    /** @type {?} */
    DatePickerInnerComponent.prototype.minMode;
    /** @type {?} */
    DatePickerInnerComponent.prototype.maxMode;
    /** @type {?} */
    DatePickerInnerComponent.prototype.showWeeks;
    /** @type {?} */
    DatePickerInnerComponent.prototype.formatDay;
    /** @type {?} */
    DatePickerInnerComponent.prototype.formatMonth;
    /** @type {?} */
    DatePickerInnerComponent.prototype.formatYear;
    /** @type {?} */
    DatePickerInnerComponent.prototype.formatDayHeader;
    /** @type {?} */
    DatePickerInnerComponent.prototype.formatDayTitle;
    /** @type {?} */
    DatePickerInnerComponent.prototype.formatMonthTitle;
    /** @type {?} */
    DatePickerInnerComponent.prototype.onlyCurrentMonth;
    /** @type {?} */
    DatePickerInnerComponent.prototype.shortcutPropagation;
    /** @type {?} */
    DatePickerInnerComponent.prototype.customClass;
    /** @type {?} */
    DatePickerInnerComponent.prototype.monthColLimit;
    /** @type {?} */
    DatePickerInnerComponent.prototype.yearColLimit;
    /** @type {?} */
    DatePickerInnerComponent.prototype.dateDisabled;
    /** @type {?} */
    DatePickerInnerComponent.prototype.dayDisabled;
    /** @type {?} */
    DatePickerInnerComponent.prototype.initDate;
    /** @type {?} */
    DatePickerInnerComponent.prototype.selectionDone;
    /** @type {?} */
    DatePickerInnerComponent.prototype.update;
    /** @type {?} */
    DatePickerInnerComponent.prototype.activeDateChange;
    /** @type {?} */
    DatePickerInnerComponent.prototype.stepDay;
    /** @type {?} */
    DatePickerInnerComponent.prototype.stepMonth;
    /** @type {?} */
    DatePickerInnerComponent.prototype.stepYear;
    /** @type {?} */
    DatePickerInnerComponent.prototype.uniqueId;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype.modes;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype.dateFormatter;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype._activeDate;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype.selectedDate;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype.activeDateId;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype.refreshViewHandlerDay;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype.compareHandlerDay;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype.refreshViewHandlerMonth;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype.compareHandlerMonth;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype.refreshViewHandlerYear;
    /**
     * @type {?}
     * @protected
     */
    DatePickerInnerComponent.prototype.compareHandlerYear;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9uZ3gtYm9vdHN0cmFwL2RhdGVwaWNrZXIvZXNtMjAxNS9kYXRlcGlja2VyLWlubmVyLmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQU9BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVWQyx1REFXQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBNkJBIiwiZmlsZSI6ImRhdGVwaWNrZXItaW5uZXIuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qIHRzbGludDpkaXNhYmxlOiBtYXgtZmlsZS1saW5lLWNvdW50ICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciB9IGZyb20gJy4vZGF0ZS1mb3JtYXR0ZXInO1xuZXhwb3J0IGNsYXNzIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRG9uZSA9IG5ldyBFdmVudEVtaXR0ZXIodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcih1bmRlZmluZWQpO1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueSovXG4gICAgICAgIHRoaXMuc3RlcERheSA9IHt9O1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueSovXG4gICAgICAgIHRoaXMuc3RlcE1vbnRoID0ge307XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55Ki9cbiAgICAgICAgdGhpcy5zdGVwWWVhciA9IHt9O1xuICAgICAgICB0aGlzLm1vZGVzID0gWydkYXknLCAnbW9udGgnLCAneWVhciddO1xuICAgICAgICB0aGlzLmRhdGVGb3JtYXR0ZXIgPSBuZXcgRGF0ZUZvcm1hdHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBhY3RpdmVEYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlRGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc2V0IGFjdGl2ZURhdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvLyB0b2RvOiBhZGQgZm9ybWF0dGVyIHZhbHVlIHRvIERhdGUgb2JqZWN0XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgLy8gdG9kbzogdXNlIGRhdGUgZm9yIHVuaXF1ZSB2YWx1ZVxuICAgICAgICB0aGlzLnVuaXF1ZUlkID0gYGRhdGVwaWNrZXItLSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApfWA7XG4gICAgICAgIGlmICh0aGlzLmluaXREYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLmluaXREYXRlO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGUgPSBuZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUudmFsdWVPZigpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZURhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGlzLnJlZnJlc2hWaWV3IHNob3VsZCBiZSBjYWxsZWQgaGVyZSB0byByZWZsZWN0IHRoZSBjaGFuZ2VzIG9uIHRoZSBmbHlcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLXZhcmlhYmxlXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaFZpZXcoKTtcbiAgICAgICAgdGhpcy5jaGVja0lmQWN0aXZlRGF0ZUdvdFVwZGF0ZWQoY2hhbmdlcy5hY3RpdmVEYXRlKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYWN0aXZlRGF0ZSBoYXMgYmVlbiB1cGRhdGUgYW5kIHRoZW4gZW1pdCB0aGUgYWN0aXZlRGF0ZUNoYW5nZSB3aXRoIHRoZSBuZXcgZGF0ZVxuICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55ICovXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhY3RpdmVEYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBjaGVja0lmQWN0aXZlRGF0ZUdvdFVwZGF0ZWQoYWN0aXZlRGF0ZSkge1xuICAgICAgICBpZiAoYWN0aXZlRGF0ZSAmJiAhYWN0aXZlRGF0ZS5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IGFjdGl2ZURhdGUucHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICYmXG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSBpbnN0YW5jZW9mIERhdGUgJiZcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlLmdldFRpbWUoKSAhPT0gYWN0aXZlRGF0ZS5jdXJyZW50VmFsdWUuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVEYXRlQ2hhbmdlLmVtaXQodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldENvbXBhcmVIYW5kbGVyKGhhbmRsZXIsIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkYXknKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVIYW5kbGVyRGF5ID0gaGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJlSGFuZGxlck1vbnRoID0gaGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVIYW5kbGVyWWVhciA9IGhhbmRsZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlMVxuICAgICAqIEBwYXJhbSB7P30gZGF0ZTJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGNvbXBhcmUoZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIGlmIChkYXRlMSA9PT0gdW5kZWZpbmVkIHx8IGRhdGUyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0ZXBpY2tlck1vZGUgPT09ICdkYXknICYmIHRoaXMuY29tcGFyZUhhbmRsZXJEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVIYW5kbGVyRGF5KGRhdGUxLCBkYXRlMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0ZXBpY2tlck1vZGUgPT09ICdtb250aCcgJiYgdGhpcy5jb21wYXJlSGFuZGxlck1vbnRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlSGFuZGxlck1vbnRoKGRhdGUxLCBkYXRlMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0ZXBpY2tlck1vZGUgPT09ICd5ZWFyJyAmJiB0aGlzLmNvbXBhcmVIYW5kbGVyWWVhcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZUhhbmRsZXJZZWFyKGRhdGUxLCBkYXRlMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXRSZWZyZXNoVmlld0hhbmRsZXIoaGFuZGxlciwgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2RheScpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFZpZXdIYW5kbGVyRGF5ID0gaGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVmlld0hhbmRsZXJNb250aCA9IGhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVmlld0hhbmRsZXJZZWFyID0gaGFuZGxlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHJlZnJlc2hWaWV3KCkge1xuICAgICAgICBpZiAodGhpcy5kYXRlcGlja2VyTW9kZSA9PT0gJ2RheScgJiYgdGhpcy5yZWZyZXNoVmlld0hhbmRsZXJEYXkpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFZpZXdIYW5kbGVyRGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0ZXBpY2tlck1vZGUgPT09ICdtb250aCcgJiYgdGhpcy5yZWZyZXNoVmlld0hhbmRsZXJNb250aCkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVmlld0hhbmRsZXJNb250aCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGVwaWNrZXJNb2RlID09PSAneWVhcicgJiYgdGhpcy5yZWZyZXNoVmlld0hhbmRsZXJZZWFyKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hWaWV3SGFuZGxlclllYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcGFyYW0gez99IGZvcm1hdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZGF0ZUZpbHRlcihkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUZvcm1hdHRlci5mb3JtYXQoZGF0ZSwgZm9ybWF0LCB0aGlzLmxvY2FsZSk7XG4gICAgfVxuICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55Ki9cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRhdGVPYmplY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGlzQWN0aXZlKGRhdGVPYmplY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZShkYXRlT2JqZWN0LmRhdGUsIHRoaXMuYWN0aXZlRGF0ZSkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRGF0ZUlkID0gZGF0ZU9iamVjdC51aWQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55Ki9cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcGFyYW0gez99IGZvcm1hdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgY3JlYXRlRGF0ZU9iamVjdChkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnkqL1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGRhdGVPYmplY3QgPSB7fTtcbiAgICAgICAgZGF0ZU9iamVjdC5kYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgZGF0ZU9iamVjdC5kYXRlID0gdGhpcy5maXhUaW1lWm9uZShkYXRlT2JqZWN0LmRhdGUpO1xuICAgICAgICBkYXRlT2JqZWN0LmxhYmVsID0gdGhpcy5kYXRlRmlsdGVyKGRhdGUsIGZvcm1hdCk7XG4gICAgICAgIGRhdGVPYmplY3Quc2VsZWN0ZWQgPSB0aGlzLmNvbXBhcmUoZGF0ZSwgdGhpcy5zZWxlY3RlZERhdGUpID09PSAwO1xuICAgICAgICBkYXRlT2JqZWN0LmRpc2FibGVkID0gdGhpcy5pc0Rpc2FibGVkKGRhdGUpO1xuICAgICAgICBkYXRlT2JqZWN0LmN1cnJlbnQgPSB0aGlzLmNvbXBhcmUoZGF0ZSwgbmV3IERhdGUoKSkgPT09IDA7XG4gICAgICAgIGRhdGVPYmplY3QuY3VzdG9tQ2xhc3MgPSB0aGlzLmdldEN1c3RvbUNsYXNzRm9yRGF0ZShkYXRlT2JqZWN0LmRhdGUpO1xuICAgICAgICByZXR1cm4gZGF0ZU9iamVjdDtcbiAgICB9XG4gICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnkqL1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXJyXG4gICAgICogQHBhcmFtIHs/fSBzaXplXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzcGxpdChhcnIsIHNpemUpIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnkqL1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGFycmF5cyA9IFtdO1xuICAgICAgICB3aGlsZSAoYXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFycmF5cy5wdXNoKGFyci5zcGxpY2UoMCwgc2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheXM7XG4gICAgfVxuICAgIC8vIEZpeCBhIGhhcmQtcmVwcm9kdWNpYmxlIGJ1ZyB3aXRoIHRpbWV6b25lc1xuICAgIC8vIFRoZSBidWcgZGVwZW5kcyBvbiBPUywgYnJvd3NlciwgY3VycmVudCB0aW1lem9uZSBhbmQgY3VycmVudCBkYXRlXG4gICAgLy8gaS5lLlxuICAgIC8vIHZhciBkYXRlID0gbmV3IERhdGUoMjAxNCwgMCwgMSk7XG4gICAgLy8gY29uc29sZS5sb2coZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpLFxuICAgIC8vIGRhdGUuZ2V0SG91cnMoKSk7IGNhbiByZXN1bHQgaW4gXCIyMDEzIDExIDMxIDIzXCIgYmVjYXVzZSBvZiB0aGUgYnVnLlxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZml4VGltZVpvbmUoZGF0ZSkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpLCBob3VycyA9PT0gMjMgPyBob3VycyArIDIgOiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHBhcmFtIHs/PX0gaXNNYW51YWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNlbGVjdChkYXRlLCBpc01hbnVhbCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZXBpY2tlck1vZGUgPT09IHRoaXMubWluTW9kZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZURhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBuZXcgRGF0ZSgwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLmZpeFRpbWVab25lKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICAgICAgICBpZiAoaXNNYW51YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkRvbmUuZW1pdCh0aGlzLmFjdGl2ZURhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IHRoaXMuZml4VGltZVpvbmUodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgICAgICAgIGlmIChpc01hbnVhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZXBpY2tlck1vZGUgPSB0aGlzLm1vZGVzW3RoaXMubW9kZXMuaW5kZXhPZih0aGlzLmRhdGVwaWNrZXJNb2RlKSAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gbmV3IERhdGUodGhpcy5hY3RpdmVEYXRlLnZhbHVlT2YoKSk7XG4gICAgICAgIHRoaXMudXBkYXRlLmVtaXQodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoVmlldygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbW92ZShkaXJlY3Rpb24pIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnkqL1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGxldCBleHBlY3RlZFN0ZXA7XG4gICAgICAgIGlmICh0aGlzLmRhdGVwaWNrZXJNb2RlID09PSAnZGF5Jykge1xuICAgICAgICAgICAgZXhwZWN0ZWRTdGVwID0gdGhpcy5zdGVwRGF5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGVwaWNrZXJNb2RlID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICBleHBlY3RlZFN0ZXAgPSB0aGlzLnN0ZXBNb250aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRlcGlja2VyTW9kZSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBleHBlY3RlZFN0ZXAgPSB0aGlzLnN0ZXBZZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZFN0ZXApIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IHllYXIgPSB0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSArIGRpcmVjdGlvbiAqIChleHBlY3RlZFN0ZXAueWVhcnMgfHwgMCk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBjb25zdCBtb250aCA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpICsgZGlyZWN0aW9uICogKGV4cGVjdGVkU3RlcC5tb250aHMgfHwgMCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hWaWV3KCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZURhdGVDaGFuZ2UuZW1pdCh0aGlzLmFjdGl2ZURhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2RpcmVjdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgdG9nZ2xlTW9kZShfZGlyZWN0aW9uKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gX2RpcmVjdGlvbiB8fCAxO1xuICAgICAgICBpZiAoKHRoaXMuZGF0ZXBpY2tlck1vZGUgPT09IHRoaXMubWF4TW9kZSAmJiBkaXJlY3Rpb24gPT09IDEpIHx8XG4gICAgICAgICAgICAodGhpcy5kYXRlcGlja2VyTW9kZSA9PT0gdGhpcy5taW5Nb2RlICYmIGRpcmVjdGlvbiA9PT0gLTEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRlcGlja2VyTW9kZSA9IHRoaXMubW9kZXNbdGhpcy5tb2Rlcy5pbmRleE9mKHRoaXMuZGF0ZXBpY2tlck1vZGUpICsgZGlyZWN0aW9uXTtcbiAgICAgICAgdGhpcy5yZWZyZXNoVmlldygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXRDdXN0b21DbGFzc0ZvckRhdGUoZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY3VzdG9tQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyB0b2RvOiBidWlsZCBhIGhhc2ggb2YgY3VzdG9tIGNsYXNzZXMsIGl0IHdpbGwgd29yayBmYXN0ZXJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBjdXN0b21DbGFzc09iamVjdCA9IHRoaXMuY3VzdG9tQ2xhc3MuZmluZCgoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY3VzdG9tQ2xhc3NcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIChjdXN0b21DbGFzcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChjdXN0b21DbGFzcy5kYXRlLnZhbHVlT2YoKSA9PT0gZGF0ZS52YWx1ZU9mKCkgJiZcbiAgICAgICAgICAgICAgICBjdXN0b21DbGFzcy5tb2RlID09PSB0aGlzLmRhdGVwaWNrZXJNb2RlKTtcbiAgICAgICAgfSksIHRoaXMpO1xuICAgICAgICByZXR1cm4gY3VzdG9tQ2xhc3NPYmplY3QgPT09IHVuZGVmaW5lZCA/ICcnIDogY3VzdG9tQ2xhc3NPYmplY3QuY2xheno7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0gez99IGRhdGUxRGlzYWJsZWRcbiAgICAgKiBAcGFyYW0gez99IGRhdGUyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBjb21wYXJlRGF0ZURpc2FibGVkKGRhdGUxRGlzYWJsZWQsIGRhdGUyKSB7XG4gICAgICAgIGlmIChkYXRlMURpc2FibGVkID09PSB1bmRlZmluZWQgfHwgZGF0ZTIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZTFEaXNhYmxlZC5tb2RlID09PSAnZGF5JyAmJiB0aGlzLmNvbXBhcmVIYW5kbGVyRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlSGFuZGxlckRheShkYXRlMURpc2FibGVkLmRhdGUsIGRhdGUyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZTFEaXNhYmxlZC5tb2RlID09PSAnbW9udGgnICYmIHRoaXMuY29tcGFyZUhhbmRsZXJNb250aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZUhhbmRsZXJNb250aChkYXRlMURpc2FibGVkLmRhdGUsIGRhdGUyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZTFEaXNhYmxlZC5tb2RlID09PSAneWVhcicgJiYgdGhpcy5jb21wYXJlSGFuZGxlclllYXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVIYW5kbGVyWWVhcihkYXRlMURpc2FibGVkLmRhdGUsIGRhdGUyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBpc0Rpc2FibGVkKGRhdGUpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBsZXQgaXNEYXRlRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZURpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGVEaXNhYmxlZC5mb3JFYWNoKCgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZGlzYWJsZWREYXRlXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoZGlzYWJsZWREYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZURhdGVEaXNhYmxlZChkaXNhYmxlZERhdGUsIGRhdGUpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRGF0ZURpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF5RGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlzRGF0ZURpc2FibGVkID1cbiAgICAgICAgICAgICAgICBpc0RhdGVEaXNhYmxlZCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRheURpc2FibGVkLmluZGV4T2YoZGF0ZS5nZXREYXkoKSkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGlzRGF0ZURpc2FibGVkIHx8XG4gICAgICAgICAgICAodGhpcy5taW5EYXRlICYmIHRoaXMuY29tcGFyZShkYXRlLCB0aGlzLm1pbkRhdGUpIDwgMCkgfHxcbiAgICAgICAgICAgICh0aGlzLm1heERhdGUgJiYgdGhpcy5jb21wYXJlKGRhdGUsIHRoaXMubWF4RGF0ZSkgPiAwKSk7XG4gICAgfVxufVxuRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdkYXRlcGlja2VyLWlubmVyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDwhLS0mbHQ7ISZuZGFzaDtuZy1rZXlkb3duPVwia2V5ZG93bigkZXZlbnQpXCImbmRhc2g7Jmd0Oy0tPlxuICAgIDxkaXYgKm5nSWY9XCJkYXRlcGlja2VyTW9kZVwiIGNsYXNzPVwid2VsbCB3ZWxsLXNtIGJnLWZhZGVkIHAtYSBjYXJkXCIgcm9sZT1cImFwcGxpY2F0aW9uXCIgPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuICBgXG4gICAgICAgICAgICB9XSB9XG5dO1xuRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGxvY2FsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0ZXBpY2tlck1vZGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0YXJ0aW5nRGF5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB5ZWFyUmFuZ2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1pbkRhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heERhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1pbk1vZGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heE1vZGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNob3dXZWVrczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZm9ybWF0RGF5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb3JtYXRNb250aDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZm9ybWF0WWVhcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZm9ybWF0RGF5SGVhZGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb3JtYXREYXlUaXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZm9ybWF0TW9udGhUaXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgb25seUN1cnJlbnRNb250aDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvcnRjdXRQcm9wYWdhdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3VzdG9tQ2xhc3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1vbnRoQ29sTGltaXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHllYXJDb2xMaW1pdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0ZURpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXlEaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaW5pdERhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGlvbkRvbmU6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICB1cGRhdGU6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBhY3RpdmVEYXRlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgYWN0aXZlRGF0ZTogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5sb2NhbGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUuZGF0ZXBpY2tlck1vZGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUuc3RhcnRpbmdEYXk7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUueWVhclJhbmdlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLm1pbkRhdGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUubWF4RGF0ZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5taW5Nb2RlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLm1heE1vZGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUuc2hvd1dlZWtzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLmZvcm1hdERheTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5mb3JtYXRNb250aDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5mb3JtYXRZZWFyO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLmZvcm1hdERheUhlYWRlcjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5mb3JtYXREYXlUaXRsZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5mb3JtYXRNb250aFRpdGxlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLm9ubHlDdXJyZW50TW9udGg7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUuc2hvcnRjdXRQcm9wYWdhdGlvbjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5jdXN0b21DbGFzcztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5tb250aENvbExpbWl0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLnllYXJDb2xMaW1pdDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5kYXRlRGlzYWJsZWQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUuZGF5RGlzYWJsZWQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUuaW5pdERhdGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUuc2VsZWN0aW9uRG9uZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUuYWN0aXZlRGF0ZUNoYW5nZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5zdGVwRGF5O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLnN0ZXBNb250aDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5zdGVwWWVhcjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS51bmlxdWVJZDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5tb2RlcztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5kYXRlRm9ybWF0dGVyO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLl9hY3RpdmVEYXRlO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLnNlbGVjdGVkRGF0ZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5hY3RpdmVEYXRlSWQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUucmVmcmVzaFZpZXdIYW5kbGVyRGF5O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLmNvbXBhcmVIYW5kbGVyRGF5O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLnJlZnJlc2hWaWV3SGFuZGxlck1vbnRoO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBEYXRlUGlja2VySW5uZXJDb21wb25lbnQucHJvdG90eXBlLmNvbXBhcmVIYW5kbGVyTW9udGg7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIERhdGVQaWNrZXJJbm5lckNvbXBvbmVudC5wcm90b3R5cGUucmVmcmVzaFZpZXdIYW5kbGVyWWVhcjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgRGF0ZVBpY2tlcklubmVyQ29tcG9uZW50LnByb3RvdHlwZS5jb21wYXJlSGFuZGxlclllYXI7XG59XG4iXX0=