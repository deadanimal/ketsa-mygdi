/*!
 * devextreme-angular
 * Version: 19.2.6
 * Build date: Thu Jan 30 2020
 *
 * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-angular
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import * as commonUtils from 'devextreme/core/utils/common';
import * as ɵngcc0 from '@angular/core';
var WatcherHelper = /** @class */ (function () {
    function WatcherHelper() {
        this._watchers = [];
    }
    WatcherHelper.prototype.getWatchMethod = function () {
        var _this = this;
        var watchMethod = function (valueGetter, valueChangeCallback, options) {
            var oldValue = valueGetter();
            options = options || {};
            if (!options.skipImmediate) {
                valueChangeCallback(oldValue);
            }
            var watcher = function () {
                var newValue = valueGetter();
                if (_this._isDifferentValues(oldValue, newValue, options.deep)) {
                    valueChangeCallback(newValue);
                    oldValue = newValue;
                }
            };
            _this._watchers.push(watcher);
            return function () {
                var index = _this._watchers.indexOf(watcher);
                if (index !== -1) {
                    _this._watchers.splice(index, 1);
                }
            };
        };
        return watchMethod;
    };
    WatcherHelper.prototype._isDifferentValues = function (oldValue, newValue, deepCheck) {
        var comparableNewValue = this._toComparable(newValue);
        var comparableOldValue = this._toComparable(oldValue);
        var isObjectValues = comparableNewValue instanceof Object && comparableOldValue instanceof Object;
        if (deepCheck && isObjectValues) {
            return this._checkObjectsFields(newValue, oldValue);
        }
        return comparableNewValue !== comparableOldValue;
    };
    WatcherHelper.prototype._toComparable = function (value) {
        if (value instanceof Date) {
            return value.getTime();
        }
        return value;
    };
    WatcherHelper.prototype._checkObjectsFields = function (checkingFromObject, checkingToObject) {
        for (var field in checkingFromObject) {
            var oldValue = this._toComparable(checkingFromObject[field]);
            var newValue = this._toComparable(checkingToObject[field]);
            var isEqualObjects = false;
            if (typeof oldValue === 'object' && typeof newValue === 'object') {
                isEqualObjects = commonUtils.equalByValue(oldValue, newValue);
            }
            if (oldValue !== newValue && !isEqualObjects) {
                return true;
            }
        }
    };
    WatcherHelper.prototype.checkWatchers = function () {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(this._watchers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var watcher = _c.value;
                watcher();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
WatcherHelper.ɵfac = function WatcherHelper_Factory(t) { return new (t || WatcherHelper)(); };
WatcherHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: WatcherHelper, factory: function (t) { return WatcherHelper.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(WatcherHelper, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return WatcherHelper;
}());
export { WatcherHelper };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lLWFuZ3VsYXIvZXNtNS9jb3JlL3dhdGNoZXItaGVscGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQXdFTTs7Ozs7Z0RBR2dCIiwiZmlsZSI6IndhdGNoZXItaGVscGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAqIGRldmV4dHJlbWUtYW5ndWxhclxyXG4gKiBWZXJzaW9uOiAxOS4yLjZcclxuICogQnVpbGQgZGF0ZTogVGh1IEphbiAzMCAyMDIwXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjAgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqXHJcbiAqIFRoaXMgc29mdHdhcmUgbWF5IGJlIG1vZGlmaWVkIGFuZCBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXNcclxuICogb2YgdGhlIE1JVCBsaWNlbnNlLiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgcHJvamVjdCBmb3IgZGV0YWlscy5cclxuICpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvZGV2ZXh0cmVtZS1hbmd1bGFyXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIGNvbW1vblV0aWxzIGZyb20gJ2RldmV4dHJlbWUvY29yZS91dGlscy9jb21tb24nO1xyXG52YXIgV2F0Y2hlckhlbHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFdhdGNoZXJIZWxwZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fd2F0Y2hlcnMgPSBbXTtcclxuICAgIH1cclxuICAgIFdhdGNoZXJIZWxwZXIucHJvdG90eXBlLmdldFdhdGNoTWV0aG9kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHdhdGNoTWV0aG9kID0gZnVuY3Rpb24gKHZhbHVlR2V0dGVyLCB2YWx1ZUNoYW5nZUNhbGxiYWNrLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHZhbHVlR2V0dGVyKCk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2tpcEltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVDaGFuZ2VDYWxsYmFjayhvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHdhdGNoZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZUdldHRlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc0RpZmZlcmVudFZhbHVlcyhvbGRWYWx1ZSwgbmV3VmFsdWUsIG9wdGlvbnMuZGVlcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUNoYW5nZUNhbGxiYWNrKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5fd2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl93YXRjaGVycy5pbmRleE9mKHdhdGNoZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl93YXRjaGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHdhdGNoTWV0aG9kO1xyXG4gICAgfTtcclxuICAgIFdhdGNoZXJIZWxwZXIucHJvdG90eXBlLl9pc0RpZmZlcmVudFZhbHVlcyA9IGZ1bmN0aW9uIChvbGRWYWx1ZSwgbmV3VmFsdWUsIGRlZXBDaGVjaykge1xyXG4gICAgICAgIHZhciBjb21wYXJhYmxlTmV3VmFsdWUgPSB0aGlzLl90b0NvbXBhcmFibGUobmV3VmFsdWUpO1xyXG4gICAgICAgIHZhciBjb21wYXJhYmxlT2xkVmFsdWUgPSB0aGlzLl90b0NvbXBhcmFibGUob2xkVmFsdWUpO1xyXG4gICAgICAgIHZhciBpc09iamVjdFZhbHVlcyA9IGNvbXBhcmFibGVOZXdWYWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiBjb21wYXJhYmxlT2xkVmFsdWUgaW5zdGFuY2VvZiBPYmplY3Q7XHJcbiAgICAgICAgaWYgKGRlZXBDaGVjayAmJiBpc09iamVjdFZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tPYmplY3RzRmllbGRzKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21wYXJhYmxlTmV3VmFsdWUgIT09IGNvbXBhcmFibGVPbGRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBXYXRjaGVySGVscGVyLnByb3RvdHlwZS5fdG9Db21wYXJhYmxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgV2F0Y2hlckhlbHBlci5wcm90b3R5cGUuX2NoZWNrT2JqZWN0c0ZpZWxkcyA9IGZ1bmN0aW9uIChjaGVja2luZ0Zyb21PYmplY3QsIGNoZWNraW5nVG9PYmplY3QpIHtcclxuICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiBjaGVja2luZ0Zyb21PYmplY3QpIHtcclxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5fdG9Db21wYXJhYmxlKGNoZWNraW5nRnJvbU9iamVjdFtmaWVsZF0pO1xyXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLl90b0NvbXBhcmFibGUoY2hlY2tpbmdUb09iamVjdFtmaWVsZF0pO1xyXG4gICAgICAgICAgICB2YXIgaXNFcXVhbE9iamVjdHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgaXNFcXVhbE9iamVjdHMgPSBjb21tb25VdGlscy5lcXVhbEJ5VmFsdWUob2xkVmFsdWUsIG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlICYmICFpc0VxdWFsT2JqZWN0cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgV2F0Y2hlckhlbHBlci5wcm90b3R5cGUuY2hlY2tXYXRjaGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZV8xLCBfYTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IHRzbGliXzEuX192YWx1ZXModGhpcy5fd2F0Y2hlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2F0Y2hlciA9IF9jLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgd2F0Y2hlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBXYXRjaGVySGVscGVyID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKClcclxuICAgIF0sIFdhdGNoZXJIZWxwZXIpO1xyXG4gICAgcmV0dXJuIFdhdGNoZXJIZWxwZXI7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IFdhdGNoZXJIZWxwZXIgfTtcciJdfQ==