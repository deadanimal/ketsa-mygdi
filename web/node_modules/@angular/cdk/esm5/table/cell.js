/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __extends } from "tslib";
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ContentChild, Directive, ElementRef, Input, TemplateRef, Inject, Optional, } from '@angular/core';
import { mixinHasStickyInput } from './can-stick';
import { CDK_TABLE } from './tokens';
/**
 * Cell definition for a CDK table.
 * Captures the template of a column's data row cell as well as cell-specific properties.
 */
import * as ɵngcc0 from '@angular/core';
var CdkCellDef = /** @class */ (function () {
    function CdkCellDef(/** @docs-private */ template) {
        this.template = template;
    }
    /** @nocollapse */
    CdkCellDef.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
CdkCellDef.ɵfac = function CdkCellDef_Factory(t) { return new (t || CdkCellDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
CdkCellDef.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkCellDef, selectors: [["", "cdkCellDef", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkCellDef, [{
        type: Directive,
        args: [{ selector: '[cdkCellDef]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
    return CdkCellDef;
}());
export { CdkCellDef };
/**
 * Header cell definition for a CDK table.
 * Captures the template of a column's header cell and as well as cell-specific properties.
 */
var CdkHeaderCellDef = /** @class */ (function () {
    function CdkHeaderCellDef(/** @docs-private */ template) {
        this.template = template;
    }
    /** @nocollapse */
    CdkHeaderCellDef.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
CdkHeaderCellDef.ɵfac = function CdkHeaderCellDef_Factory(t) { return new (t || CdkHeaderCellDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
CdkHeaderCellDef.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkHeaderCellDef, selectors: [["", "cdkHeaderCellDef", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkHeaderCellDef, [{
        type: Directive,
        args: [{ selector: '[cdkHeaderCellDef]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
    return CdkHeaderCellDef;
}());
export { CdkHeaderCellDef };
/**
 * Footer cell definition for a CDK table.
 * Captures the template of a column's footer cell and as well as cell-specific properties.
 */
var CdkFooterCellDef = /** @class */ (function () {
    function CdkFooterCellDef(/** @docs-private */ template) {
        this.template = template;
    }
    /** @nocollapse */
    CdkFooterCellDef.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
CdkFooterCellDef.ɵfac = function CdkFooterCellDef_Factory(t) { return new (t || CdkFooterCellDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
CdkFooterCellDef.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkFooterCellDef, selectors: [["", "cdkFooterCellDef", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkFooterCellDef, [{
        type: Directive,
        args: [{ selector: '[cdkFooterCellDef]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
    return CdkFooterCellDef;
}());
export { CdkFooterCellDef };
// Boilerplate for applying mixins to CdkColumnDef.
/** @docs-private */
var CdkColumnDefBase = /** @class */ (function () {
    function CdkColumnDefBase() {
    }
    return CdkColumnDefBase;
}());
var _CdkColumnDefBase = mixinHasStickyInput(CdkColumnDefBase);
/**
 * Column definition for the CDK table.
 * Defines a set of cells available for a table column.
 */
var CdkColumnDef = /** @class */ (function (_super) {
    __extends(CdkColumnDef, _super);
    function CdkColumnDef(_table) {
        var _this = _super.call(this) || this;
        _this._table = _table;
        _this._stickyEnd = false;
        return _this;
    }
    Object.defineProperty(CdkColumnDef.prototype, "name", {
        /** Unique name for this column. */
        get: function () {
            return this._name;
        },
        set: function (name) {
            // If the directive is set without a name (updated programatically), then this setter will
            // trigger with an empty string and should not overwrite the programatically set value.
            if (name) {
                this._name = name;
                this.cssClassFriendlyName = name.replace(/[^a-z0-9_-]/ig, '-');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkColumnDef.prototype, "stickyEnd", {
        /**
         * Whether this column should be sticky positioned on the end of the row. Should make sure
         * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
         * has been changed.
         */
        get: function () {
            return this._stickyEnd;
        },
        set: function (v) {
            var prevValue = this._stickyEnd;
            this._stickyEnd = coerceBooleanProperty(v);
            this._hasStickyChanged = prevValue !== this._stickyEnd;
        },
        enumerable: true,
        configurable: true
    });
    /** @nocollapse */
    CdkColumnDef.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [CDK_TABLE,] }, { type: Optional }] }
    ]; };
    CdkColumnDef.propDecorators = {
        name: [{ type: Input, args: ['cdkColumnDef',] }],
        stickyEnd: [{ type: Input, args: ['stickyEnd',] }],
        cell: [{ type: ContentChild, args: [CdkCellDef,] }],
        headerCell: [{ type: ContentChild, args: [CdkHeaderCellDef,] }],
        footerCell: [{ type: ContentChild, args: [CdkFooterCellDef,] }]
    };
CdkColumnDef.ɵfac = function CdkColumnDef_Factory(t) { return new (t || CdkColumnDef)(ɵngcc0.ɵɵdirectiveInject(CDK_TABLE, 8)); };
CdkColumnDef.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkColumnDef, selectors: [["", "cdkColumnDef", ""]], contentQueries: function CdkColumnDef_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkCellDef, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkHeaderCellDef, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkFooterCellDef, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cell = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerCell = _t.first);
    } }, inputs: { sticky: "sticky", name: ["cdkColumnDef", "name"], stickyEnd: "stickyEnd" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkColumnDef, [{
        type: Directive,
        args: [{
                selector: '[cdkColumnDef]',
                inputs: ['sticky'],
                providers: [{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [CDK_TABLE]
            }, {
                type: Optional
            }] }]; }, { name: [{
            type: Input,
            args: ['cdkColumnDef']
        }], stickyEnd: [{
            type: Input,
            args: ['stickyEnd']
        }], cell: [{
            type: ContentChild,
            args: [CdkCellDef]
        }], headerCell: [{
            type: ContentChild,
            args: [CdkHeaderCellDef]
        }], footerCell: [{
            type: ContentChild,
            args: [CdkFooterCellDef]
        }] }); })();
    return CdkColumnDef;
}(_CdkColumnDefBase));
export { CdkColumnDef };
/** Base class for the cells. Adds a CSS classname that identifies the column it renders in. */
var BaseCdkCell = /** @class */ (function () {
    function BaseCdkCell(columnDef, elementRef) {
        var columnClassName = "cdk-column-" + columnDef.cssClassFriendlyName;
        elementRef.nativeElement.classList.add(columnClassName);
    }
    return BaseCdkCell;
}());
export { BaseCdkCell };
/** Header cell template container that adds the right classes and role. */
var CdkHeaderCell = /** @class */ (function (_super) {
    __extends(CdkHeaderCell, _super);
    function CdkHeaderCell(columnDef, elementRef) {
        return _super.call(this, columnDef, elementRef) || this;
    }
    /** @nocollapse */
    CdkHeaderCell.ctorParameters = function () { return [
        { type: CdkColumnDef },
        { type: ElementRef }
    ]; };
CdkHeaderCell.ɵfac = function CdkHeaderCell_Factory(t) { return new (t || CdkHeaderCell)(ɵngcc0.ɵɵdirectiveInject(CdkColumnDef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
CdkHeaderCell.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkHeaderCell, selectors: [["cdk-header-cell"], ["th", "cdk-header-cell", ""]], hostAttrs: ["role", "columnheader", 1, "cdk-header-cell"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkHeaderCell, [{
        type: Directive,
        args: [{
                selector: 'cdk-header-cell, th[cdk-header-cell]',
                host: {
                    'class': 'cdk-header-cell',
                    'role': 'columnheader'
                }
            }]
    }], function () { return [{ type: CdkColumnDef }, { type: ɵngcc0.ElementRef }]; }, null); })();
    return CdkHeaderCell;
}(BaseCdkCell));
export { CdkHeaderCell };
/** Footer cell template container that adds the right classes and role. */
var CdkFooterCell = /** @class */ (function (_super) {
    __extends(CdkFooterCell, _super);
    function CdkFooterCell(columnDef, elementRef) {
        return _super.call(this, columnDef, elementRef) || this;
    }
    /** @nocollapse */
    CdkFooterCell.ctorParameters = function () { return [
        { type: CdkColumnDef },
        { type: ElementRef }
    ]; };
CdkFooterCell.ɵfac = function CdkFooterCell_Factory(t) { return new (t || CdkFooterCell)(ɵngcc0.ɵɵdirectiveInject(CdkColumnDef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
CdkFooterCell.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkFooterCell, selectors: [["cdk-footer-cell"], ["td", "cdk-footer-cell", ""]], hostAttrs: ["role", "gridcell", 1, "cdk-footer-cell"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkFooterCell, [{
        type: Directive,
        args: [{
                selector: 'cdk-footer-cell, td[cdk-footer-cell]',
                host: {
                    'class': 'cdk-footer-cell',
                    'role': 'gridcell'
                }
            }]
    }], function () { return [{ type: CdkColumnDef }, { type: ɵngcc0.ElementRef }]; }, null); })();
    return CdkFooterCell;
}(BaseCdkCell));
export { CdkFooterCell };
/** Cell template container that adds the right classes and role. */
var CdkCell = /** @class */ (function (_super) {
    __extends(CdkCell, _super);
    function CdkCell(columnDef, elementRef) {
        return _super.call(this, columnDef, elementRef) || this;
    }
    /** @nocollapse */
    CdkCell.ctorParameters = function () { return [
        { type: CdkColumnDef },
        { type: ElementRef }
    ]; };
CdkCell.ɵfac = function CdkCell_Factory(t) { return new (t || CdkCell)(ɵngcc0.ɵɵdirectiveInject(CdkColumnDef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
CdkCell.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkCell, selectors: [["cdk-cell"], ["td", "cdk-cell", ""]], hostAttrs: ["role", "gridcell", 1, "cdk-cell"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkCell, [{
        type: Directive,
        args: [{
                selector: 'cdk-cell, td[cdk-cell]',
                host: {
                    'class': 'cdk-cell',
                    'role': 'gridcell'
                }
            }]
    }], function () { return [{ type: CdkColumnDef }, { type: ɵngcc0.ElementRef }]; }, null); })();
    return CdkCell;
}(BaseCdkCell));
export { CdkCell };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jZGsvZXNtNS90YWJsZS9jZWxsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTs7O0tBR0ssQUFHQzs7Ozs7Ozs7Ozs0RUFJRzs7Ozs7Ozs7Ozs7S0FXSixBQUdDOzs7Ozs7Ozs7OzRFQUlHOzs7Ozs7Ozs7OztLQVdKLEFBR0M7Ozs7Ozs7Ozs7NEVBSUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0RGLEFBT0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FrQkQsQUFTQzs7Ozs7Ozs7Ozs7Ozs7Ozs7bUdBS0c7Ozs7Ozs7OztLQVNKLEFBU0M7Ozs7Ozs7Ozs7Ozs7Ozs7O21HQUtHOzs7Ozs7Ozs7S0FTSixBQVNDOzs7Ozs7Ozs7Ozs7Ozs7OzttR0FLRyIsImZpbGUiOiJjZWxsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBDb250ZW50Q2hpbGQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIFRlbXBsYXRlUmVmLCBJbmplY3QsIE9wdGlvbmFsLCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbWl4aW5IYXNTdGlja3lJbnB1dCB9IGZyb20gJy4vY2FuLXN0aWNrJztcbmltcG9ydCB7IENES19UQUJMRSB9IGZyb20gJy4vdG9rZW5zJztcbi8qKlxuICogQ2VsbCBkZWZpbml0aW9uIGZvciBhIENESyB0YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGRhdGEgcm93IGNlbGwgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDZGtDZWxsRGVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENka0NlbGxEZWYoLyoqIEBkb2NzLXByaXZhdGUgKi8gdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICBDZGtDZWxsRGVmLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tjZGtDZWxsRGVmXScgfSxdIH1cbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIENka0NlbGxEZWYuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogVGVtcGxhdGVSZWYgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIENka0NlbGxEZWY7XG59KCkpO1xuZXhwb3J0IHsgQ2RrQ2VsbERlZiB9O1xuLyoqXG4gKiBIZWFkZXIgY2VsbCBkZWZpbml0aW9uIGZvciBhIENESyB0YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGhlYWRlciBjZWxsIGFuZCBhcyB3ZWxsIGFzIGNlbGwtc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqL1xudmFyIENka0hlYWRlckNlbGxEZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2RrSGVhZGVyQ2VsbERlZigvKiogQGRvY3MtcHJpdmF0ZSAqLyB0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIENka0hlYWRlckNlbGxEZWYuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Nka0hlYWRlckNlbGxEZWZdJyB9LF0gfVxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgQ2RrSGVhZGVyQ2VsbERlZi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gQ2RrSGVhZGVyQ2VsbERlZjtcbn0oKSk7XG5leHBvcnQgeyBDZGtIZWFkZXJDZWxsRGVmIH07XG4vKipcbiAqIEZvb3RlciBjZWxsIGRlZmluaXRpb24gZm9yIGEgQ0RLIHRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIHRlbXBsYXRlIG9mIGEgY29sdW1uJ3MgZm9vdGVyIGNlbGwgYW5kIGFzIHdlbGwgYXMgY2VsbC1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ2RrRm9vdGVyQ2VsbERlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZGtGb290ZXJDZWxsRGVmKC8qKiBAZG9jcy1wcml2YXRlICovIHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgQ2RrRm9vdGVyQ2VsbERlZi5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbY2RrRm9vdGVyQ2VsbERlZl0nIH0sXSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBDZGtGb290ZXJDZWxsRGVmLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBDZGtGb290ZXJDZWxsRGVmO1xufSgpKTtcbmV4cG9ydCB7IENka0Zvb3RlckNlbGxEZWYgfTtcbi8vIEJvaWxlcnBsYXRlIGZvciBhcHBseWluZyBtaXhpbnMgdG8gQ2RrQ29sdW1uRGVmLlxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbnZhciBDZGtDb2x1bW5EZWZCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENka0NvbHVtbkRlZkJhc2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBDZGtDb2x1bW5EZWZCYXNlO1xufSgpKTtcbnZhciBfQ2RrQ29sdW1uRGVmQmFzZSA9IG1peGluSGFzU3RpY2t5SW5wdXQoQ2RrQ29sdW1uRGVmQmFzZSk7XG4vKipcbiAqIENvbHVtbiBkZWZpbml0aW9uIGZvciB0aGUgQ0RLIHRhYmxlLlxuICogRGVmaW5lcyBhIHNldCBvZiBjZWxscyBhdmFpbGFibGUgZm9yIGEgdGFibGUgY29sdW1uLlxuICovXG52YXIgQ2RrQ29sdW1uRGVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDZGtDb2x1bW5EZWYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2RrQ29sdW1uRGVmKF90YWJsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFibGUgPSBfdGFibGU7XG4gICAgICAgIF90aGlzLl9zdGlja3lFbmQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2RrQ29sdW1uRGVmLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgLyoqIFVuaXF1ZSBuYW1lIGZvciB0aGlzIGNvbHVtbi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpcmVjdGl2ZSBpcyBzZXQgd2l0aG91dCBhIG5hbWUgKHVwZGF0ZWQgcHJvZ3JhbWF0aWNhbGx5KSwgdGhlbiB0aGlzIHNldHRlciB3aWxsXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHdpdGggYW4gZW1wdHkgc3RyaW5nIGFuZCBzaG91bGQgbm90IG92ZXJ3cml0ZSB0aGUgcHJvZ3JhbWF0aWNhbGx5IHNldCB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jc3NDbGFzc0ZyaWVuZGx5TmFtZSA9IG5hbWUucmVwbGFjZSgvW15hLXowLTlfLV0vaWcsICctJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDZGtDb2x1bW5EZWYucHJvdG90eXBlLCBcInN0aWNreUVuZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgY29sdW1uIHNob3VsZCBiZSBzdGlja3kgcG9zaXRpb25lZCBvbiB0aGUgZW5kIG9mIHRoZSByb3cuIFNob3VsZCBtYWtlIHN1cmVcbiAgICAgICAgICogdGhhdCBpdCBtaW1pY3MgdGhlIGBDYW5TdGlja2AgbWl4aW4gc3VjaCB0aGF0IGBfaGFzU3RpY2t5Q2hhbmdlZGAgaXMgc2V0IHRvIHRydWUgaWYgdGhlIHZhbHVlXG4gICAgICAgICAqIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGlja3lFbmQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSB0aGlzLl9zdGlja3lFbmQ7XG4gICAgICAgICAgICB0aGlzLl9zdGlja3lFbmQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodik7XG4gICAgICAgICAgICB0aGlzLl9oYXNTdGlja3lDaGFuZ2VkID0gcHJldlZhbHVlICE9PSB0aGlzLl9zdGlja3lFbmQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENka0NvbHVtbkRlZi5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrQ29sdW1uRGVmXScsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydzdGlja3knXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiAnTUFUX1NPUlRfSEVBREVSX0NPTFVNTl9ERUYnLCB1c2VFeGlzdGluZzogQ2RrQ29sdW1uRGVmIH1dLFxuICAgICAgICAgICAgICAgIH0sXSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBDZGtDb2x1bW5EZWYuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtDREtfVEFCTEUsXSB9LCB7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbiAgICBdOyB9O1xuICAgIENka0NvbHVtbkRlZi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgbmFtZTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnY2RrQ29sdW1uRGVmJyxdIH1dLFxuICAgICAgICBzdGlja3lFbmQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ3N0aWNreUVuZCcsXSB9XSxcbiAgICAgICAgY2VsbDogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbQ2RrQ2VsbERlZixdIH1dLFxuICAgICAgICBoZWFkZXJDZWxsOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtDZGtIZWFkZXJDZWxsRGVmLF0gfV0sXG4gICAgICAgIGZvb3RlckNlbGw6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0Nka0Zvb3RlckNlbGxEZWYsXSB9XVxuICAgIH07XG4gICAgcmV0dXJuIENka0NvbHVtbkRlZjtcbn0oX0Nka0NvbHVtbkRlZkJhc2UpKTtcbmV4cG9ydCB7IENka0NvbHVtbkRlZiB9O1xuLyoqIEJhc2UgY2xhc3MgZm9yIHRoZSBjZWxscy4gQWRkcyBhIENTUyBjbGFzc25hbWUgdGhhdCBpZGVudGlmaWVzIHRoZSBjb2x1bW4gaXQgcmVuZGVycyBpbi4gKi9cbnZhciBCYXNlQ2RrQ2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlQ2RrQ2VsbChjb2x1bW5EZWYsIGVsZW1lbnRSZWYpIHtcbiAgICAgICAgdmFyIGNvbHVtbkNsYXNzTmFtZSA9IFwiY2RrLWNvbHVtbi1cIiArIGNvbHVtbkRlZi5jc3NDbGFzc0ZyaWVuZGx5TmFtZTtcbiAgICAgICAgZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoY29sdW1uQ2xhc3NOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIEJhc2VDZGtDZWxsO1xufSgpKTtcbmV4cG9ydCB7IEJhc2VDZGtDZWxsIH07XG4vKiogSGVhZGVyIGNlbGwgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgYWRkcyB0aGUgcmlnaHQgY2xhc3NlcyBhbmQgcm9sZS4gKi9cbnZhciBDZGtIZWFkZXJDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDZGtIZWFkZXJDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENka0hlYWRlckNlbGwoY29sdW1uRGVmLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb2x1bW5EZWYsIGVsZW1lbnRSZWYpIHx8IHRoaXM7XG4gICAgfVxuICAgIENka0hlYWRlckNlbGwuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnY2RrLWhlYWRlci1jZWxsLCB0aFtjZGstaGVhZGVyLWNlbGxdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2Nkay1oZWFkZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdjb2x1bW5oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBDZGtIZWFkZXJDZWxsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENka0NvbHVtbkRlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIENka0hlYWRlckNlbGw7XG59KEJhc2VDZGtDZWxsKSk7XG5leHBvcnQgeyBDZGtIZWFkZXJDZWxsIH07XG4vKiogRm9vdGVyIGNlbGwgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgYWRkcyB0aGUgcmlnaHQgY2xhc3NlcyBhbmQgcm9sZS4gKi9cbnZhciBDZGtGb290ZXJDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDZGtGb290ZXJDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENka0Zvb3RlckNlbGwoY29sdW1uRGVmLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb2x1bW5EZWYsIGVsZW1lbnRSZWYpIHx8IHRoaXM7XG4gICAgfVxuICAgIENka0Zvb3RlckNlbGwuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnY2RrLWZvb3Rlci1jZWxsLCB0ZFtjZGstZm9vdGVyLWNlbGxdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2Nkay1mb290ZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdncmlkY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxdIH1cbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIENka0Zvb3RlckNlbGwuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2RrQ29sdW1uRGVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gQ2RrRm9vdGVyQ2VsbDtcbn0oQmFzZUNka0NlbGwpKTtcbmV4cG9ydCB7IENka0Zvb3RlckNlbGwgfTtcbi8qKiBDZWxsIHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGFkZHMgdGhlIHJpZ2h0IGNsYXNzZXMgYW5kIHJvbGUuICovXG52YXIgQ2RrQ2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2RrQ2VsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDZGtDZWxsKGNvbHVtbkRlZiwgZWxlbWVudFJlZikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29sdW1uRGVmLCBlbGVtZW50UmVmKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDZGtDZWxsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2Nkay1jZWxsLCB0ZFtjZGstY2VsbF0nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnY2RrLWNlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBDZGtDZWxsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENka0NvbHVtbkRlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIENka0NlbGw7XG59KEJhc2VDZGtDZWxsKSk7XG5leHBvcnQgeyBDZGtDZWxsIH07XG4iXX0=