/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Platform, normalizePassiveListenerOptions } from '@angular/cdk/platform';
import { Directive, ElementRef, EventEmitter, Injectable, NgZone, Output, } from '@angular/core';
import { coerceElement } from '@angular/cdk/coercion';
import { EMPTY, Subject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/platform";
/** Options to pass to the animationstart listener. */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/platform';
var listenerOptions = normalizePassiveListenerOptions({ passive: true });
/**
 * An injectable service that can be used to monitor the autofill state of an input.
 * Based on the following blog post:
 * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7
 */
var AutofillMonitor = /** @class */ (function () {
    function AutofillMonitor(_platform, _ngZone) {
        this._platform = _platform;
        this._ngZone = _ngZone;
        this._monitoredElements = new Map();
    }
    AutofillMonitor.prototype.monitor = function (elementOrRef) {
        var _this = this;
        if (!this._platform.isBrowser) {
            return EMPTY;
        }
        var element = coerceElement(elementOrRef);
        var info = this._monitoredElements.get(element);
        if (info) {
            return info.subject.asObservable();
        }
        var result = new Subject();
        var cssClass = 'cdk-text-field-autofilled';
        var listener = (function (event) {
            // Animation events fire on initial element render, we check for the presence of the autofill
            // CSS class to make sure this is a real change in state, not just the initial render before
            // we fire off events.
            if (event.animationName === 'cdk-text-field-autofill-start' &&
                !element.classList.contains(cssClass)) {
                element.classList.add(cssClass);
                _this._ngZone.run(function () { return result.next({ target: event.target, isAutofilled: true }); });
            }
            else if (event.animationName === 'cdk-text-field-autofill-end' &&
                element.classList.contains(cssClass)) {
                element.classList.remove(cssClass);
                _this._ngZone.run(function () { return result.next({ target: event.target, isAutofilled: false }); });
            }
        });
        this._ngZone.runOutsideAngular(function () {
            element.addEventListener('animationstart', listener, listenerOptions);
            element.classList.add('cdk-text-field-autofill-monitored');
        });
        this._monitoredElements.set(element, {
            subject: result,
            unlisten: function () {
                element.removeEventListener('animationstart', listener, listenerOptions);
            }
        });
        return result.asObservable();
    };
    AutofillMonitor.prototype.stopMonitoring = function (elementOrRef) {
        var element = coerceElement(elementOrRef);
        var info = this._monitoredElements.get(element);
        if (info) {
            info.unlisten();
            info.subject.complete();
            element.classList.remove('cdk-text-field-autofill-monitored');
            element.classList.remove('cdk-text-field-autofilled');
            this._monitoredElements.delete(element);
        }
    };
    AutofillMonitor.prototype.ngOnDestroy = function () {
        var _this = this;
        this._monitoredElements.forEach(function (_info, element) { return _this.stopMonitoring(element); });
    };
    /** @nocollapse */
    AutofillMonitor.ctorParameters = function () { return [
        { type: Platform },
        { type: NgZone }
    ]; };
    AutofillMonitor.ɵprov = i0.ɵɵdefineInjectable({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(i0.ɵɵinject(i1.Platform), i0.ɵɵinject(i0.NgZone)); }, token: AutofillMonitor, providedIn: "root" });
AutofillMonitor.ɵfac = function AutofillMonitor_Factory(t) { return new (t || AutofillMonitor)(ɵngcc0.ɵɵinject(ɵngcc1.Platform), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AutofillMonitor, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc1.Platform }, { type: ɵngcc0.NgZone }]; }, null); })();
    return AutofillMonitor;
}());
export { AutofillMonitor };
/** A directive that can be used to monitor the autofill state of an input. */
var CdkAutofill = /** @class */ (function () {
    function CdkAutofill(_elementRef, _autofillMonitor) {
        this._elementRef = _elementRef;
        this._autofillMonitor = _autofillMonitor;
        /** Emits when the autofill state of the element changes. */
        this.cdkAutofill = new EventEmitter();
    }
    CdkAutofill.prototype.ngOnInit = function () {
        var _this = this;
        this._autofillMonitor
            .monitor(this._elementRef)
            .subscribe(function (event) { return _this.cdkAutofill.emit(event); });
    };
    CdkAutofill.prototype.ngOnDestroy = function () {
        this._autofillMonitor.stopMonitoring(this._elementRef);
    };
    /** @nocollapse */
    CdkAutofill.ctorParameters = function () { return [
        { type: ElementRef },
        { type: AutofillMonitor }
    ]; };
    CdkAutofill.propDecorators = {
        cdkAutofill: [{ type: Output }]
    };
CdkAutofill.ɵfac = function CdkAutofill_Factory(t) { return new (t || CdkAutofill)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(AutofillMonitor)); };
CdkAutofill.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkAutofill, selectors: [["", "cdkAutofill", ""]], outputs: { cdkAutofill: "cdkAutofill" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkAutofill, [{
        type: Directive,
        args: [{
                selector: '[cdkAutofill]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: AutofillMonitor }]; }, { cdkAutofill: [{
            type: Output
        }] }); })();
    return CdkAutofill;
}());
export { CdkAutofill };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jZGsvZXNtNS90ZXh0LWZpZWxkL2F1dG9maWxsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BaUVNLEFBR0E7Ozs7Ozs7Ozs7O2tHQU0yTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFvQjNOLEFBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFRQSIsImZpbGUiOiJhdXRvZmlsbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgUGxhdGZvcm0sIG5vcm1hbGl6ZVBhc3NpdmVMaXN0ZW5lck9wdGlvbnMgfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEluamVjdGFibGUsIE5nWm9uZSwgT3V0cHV0LCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29lcmNlRWxlbWVudCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBFTVBUWSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0ICogYXMgaTAgZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCAqIGFzIGkxIGZyb20gXCJAYW5ndWxhci9jZGsvcGxhdGZvcm1cIjtcbi8qKiBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIGFuaW1hdGlvbnN0YXJ0IGxpc3RlbmVyLiAqL1xudmFyIGxpc3RlbmVyT3B0aW9ucyA9IG5vcm1hbGl6ZVBhc3NpdmVMaXN0ZW5lck9wdGlvbnMoeyBwYXNzaXZlOiB0cnVlIH0pO1xuLyoqXG4gKiBBbiBpbmplY3RhYmxlIHNlcnZpY2UgdGhhdCBjYW4gYmUgdXNlZCB0byBtb25pdG9yIHRoZSBhdXRvZmlsbCBzdGF0ZSBvZiBhbiBpbnB1dC5cbiAqIEJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgYmxvZyBwb3N0OlxuICogaHR0cHM6Ly9tZWRpdW0uY29tL0BicnVubi9kZXRlY3RpbmctYXV0b2ZpbGxlZC1maWVsZHMtaW4tamF2YXNjcmlwdC1hZWQ1OThkMjVkYTdcbiAqL1xudmFyIEF1dG9maWxsTW9uaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRvZmlsbE1vbml0b3IoX3BsYXRmb3JtLCBfbmdab25lKSB7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gX3BsYXRmb3JtO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9tb25pdG9yZWRFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgQXV0b2ZpbGxNb25pdG9yLnByb3RvdHlwZS5tb25pdG9yID0gZnVuY3Rpb24gKGVsZW1lbnRPclJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gY29lcmNlRWxlbWVudChlbGVtZW50T3JSZWYpO1xuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuX21vbml0b3JlZEVsZW1lbnRzLmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvLnN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdjZGstdGV4dC1maWVsZC1hdXRvZmlsbGVkJztcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gQW5pbWF0aW9uIGV2ZW50cyBmaXJlIG9uIGluaXRpYWwgZWxlbWVudCByZW5kZXIsIHdlIGNoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlIGF1dG9maWxsXG4gICAgICAgICAgICAvLyBDU1MgY2xhc3MgdG8gbWFrZSBzdXJlIHRoaXMgaXMgYSByZWFsIGNoYW5nZSBpbiBzdGF0ZSwgbm90IGp1c3QgdGhlIGluaXRpYWwgcmVuZGVyIGJlZm9yZVxuICAgICAgICAgICAgLy8gd2UgZmlyZSBvZmYgZXZlbnRzLlxuICAgICAgICAgICAgaWYgKGV2ZW50LmFuaW1hdGlvbk5hbWUgPT09ICdjZGstdGV4dC1maWVsZC1hdXRvZmlsbC1zdGFydCcgJiZcbiAgICAgICAgICAgICAgICAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNzc0NsYXNzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbmdab25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiByZXN1bHQubmV4dCh7IHRhcmdldDogZXZlbnQudGFyZ2V0LCBpc0F1dG9maWxsZWQ6IHRydWUgfSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuYW5pbWF0aW9uTmFtZSA9PT0gJ2Nkay10ZXh0LWZpZWxkLWF1dG9maWxsLWVuZCcgJiZcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjc3NDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY3NzQ2xhc3MpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9uZ1pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdC5uZXh0KHsgdGFyZ2V0OiBldmVudC50YXJnZXQsIGlzQXV0b2ZpbGxlZDogZmFsc2UgfSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uc3RhcnQnLCBsaXN0ZW5lciwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY2RrLXRleHQtZmllbGQtYXV0b2ZpbGwtbW9uaXRvcmVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tb25pdG9yZWRFbGVtZW50cy5zZXQoZWxlbWVudCwge1xuICAgICAgICAgICAgc3ViamVjdDogcmVzdWx0LFxuICAgICAgICAgICAgdW5saXN0ZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbnN0YXJ0JywgbGlzdGVuZXIsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgQXV0b2ZpbGxNb25pdG9yLnByb3RvdHlwZS5zdG9wTW9uaXRvcmluZyA9IGZ1bmN0aW9uIChlbGVtZW50T3JSZWYpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjb2VyY2VFbGVtZW50KGVsZW1lbnRPclJlZik7XG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5fbW9uaXRvcmVkRWxlbWVudHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaW5mby51bmxpc3RlbigpO1xuICAgICAgICAgICAgaW5mby5zdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2Nkay10ZXh0LWZpZWxkLWF1dG9maWxsLW1vbml0b3JlZCcpO1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjZGstdGV4dC1maWVsZC1hdXRvZmlsbGVkJyk7XG4gICAgICAgICAgICB0aGlzLl9tb25pdG9yZWRFbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9maWxsTW9uaXRvci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX21vbml0b3JlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKF9pbmZvLCBlbGVtZW50KSB7IHJldHVybiBfdGhpcy5zdG9wTW9uaXRvcmluZyhlbGVtZW50KTsgfSk7XG4gICAgfTtcbiAgICBBdXRvZmlsbE1vbml0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfSxdIH1cbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEF1dG9maWxsTW9uaXRvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBQbGF0Zm9ybSB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICBBdXRvZmlsbE1vbml0b3IuybVwcm92ID0gaTAuybXJtWRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBBdXRvZmlsbE1vbml0b3JfRmFjdG9yeSgpIHsgcmV0dXJuIG5ldyBBdXRvZmlsbE1vbml0b3IoaTAuybXJtWluamVjdChpMS5QbGF0Zm9ybSksIGkwLsm1ybVpbmplY3QoaTAuTmdab25lKSk7IH0sIHRva2VuOiBBdXRvZmlsbE1vbml0b3IsIHByb3ZpZGVkSW46IFwicm9vdFwiIH0pO1xuICAgIHJldHVybiBBdXRvZmlsbE1vbml0b3I7XG59KCkpO1xuZXhwb3J0IHsgQXV0b2ZpbGxNb25pdG9yIH07XG4vKiogQSBkaXJlY3RpdmUgdGhhdCBjYW4gYmUgdXNlZCB0byBtb25pdG9yIHRoZSBhdXRvZmlsbCBzdGF0ZSBvZiBhbiBpbnB1dC4gKi9cbnZhciBDZGtBdXRvZmlsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZGtBdXRvZmlsbChfZWxlbWVudFJlZiwgX2F1dG9maWxsTW9uaXRvcikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2F1dG9maWxsTW9uaXRvciA9IF9hdXRvZmlsbE1vbml0b3I7XG4gICAgICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBhdXRvZmlsbCBzdGF0ZSBvZiB0aGUgZWxlbWVudCBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLmNka0F1dG9maWxsID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBDZGtBdXRvZmlsbC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2F1dG9maWxsTW9uaXRvclxuICAgICAgICAgICAgLm1vbml0b3IodGhpcy5fZWxlbWVudFJlZilcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5jZGtBdXRvZmlsbC5lbWl0KGV2ZW50KTsgfSk7XG4gICAgfTtcbiAgICBDZGtBdXRvZmlsbC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2F1dG9maWxsTW9uaXRvci5zdG9wTW9uaXRvcmluZyh0aGlzLl9lbGVtZW50UmVmKTtcbiAgICB9O1xuICAgIENka0F1dG9maWxsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGtBdXRvZmlsbF0nLFxuICAgICAgICAgICAgICAgIH0sXSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBDZGtBdXRvZmlsbC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogQXV0b2ZpbGxNb25pdG9yIH1cbiAgICBdOyB9O1xuICAgIENka0F1dG9maWxsLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICBjZGtBdXRvZmlsbDogW3sgdHlwZTogT3V0cHV0IH1dXG4gICAgfTtcbiAgICByZXR1cm4gQ2RrQXV0b2ZpbGw7XG59KCkpO1xuZXhwb3J0IHsgQ2RrQXV0b2ZpbGwgfTtcbiJdfQ==