/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __extends } from "tslib";
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { Platform, _getShadowRoot } from '@angular/cdk/platform';
import { DOCUMENT } from '@angular/common';
import { ChangeDetectionStrategy, Component, ElementRef, Inject, InjectionToken, Input, Optional, ViewEncapsulation, } from '@angular/core';
import { mixinColor } from '@angular/material/core';
import { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';
/**
 * Base reference size of the spinner.
 * @docs-private
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/platform';
import * as ɵngcc2 from '@angular/common';

function MatProgressSpinner__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 3);
} if (rf & 2) {
    var ctx_r33 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("animation-name", "mat-progress-spinner-stroke-rotate-" + ctx_r33.diameter)("stroke-dashoffset", ctx_r33._strokeDashOffset, "px")("stroke-dasharray", ctx_r33._strokeCircumference, "px")("stroke-width", ctx_r33._circleStrokeWidth, "%");
    ɵngcc0.ɵɵattribute("r", ctx_r33._circleRadius);
} }
function MatProgressSpinner__svg_circle_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 3);
} if (rf & 2) {
    var ctx_r34 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("stroke-dashoffset", ctx_r34._strokeDashOffset, "px")("stroke-dasharray", ctx_r34._strokeCircumference, "px")("stroke-width", ctx_r34._circleStrokeWidth, "%");
    ɵngcc0.ɵɵattribute("r", ctx_r34._circleRadius);
} }
function MatSpinner__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 3);
} if (rf & 2) {
    var ctx_r35 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("animation-name", "mat-progress-spinner-stroke-rotate-" + ctx_r35.diameter)("stroke-dashoffset", ctx_r35._strokeDashOffset, "px")("stroke-dasharray", ctx_r35._strokeCircumference, "px")("stroke-width", ctx_r35._circleStrokeWidth, "%");
    ɵngcc0.ɵɵattribute("r", ctx_r35._circleRadius);
} }
function MatSpinner__svg_circle_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 3);
} if (rf & 2) {
    var ctx_r36 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("stroke-dashoffset", ctx_r36._strokeDashOffset, "px")("stroke-dasharray", ctx_r36._strokeCircumference, "px")("stroke-width", ctx_r36._circleStrokeWidth, "%");
    ɵngcc0.ɵɵattribute("r", ctx_r36._circleRadius);
} }
var BASE_SIZE = 100;
/**
 * Base reference stroke width of the spinner.
 * @docs-private
 */
var BASE_STROKE_WIDTH = 10;
// Boilerplate for applying mixins to MatProgressSpinner.
/** @docs-private */
var MatProgressSpinnerBase = /** @class */ (function () {
    function MatProgressSpinnerBase(_elementRef) {
        this._elementRef = _elementRef;
    }
    return MatProgressSpinnerBase;
}());
var _MatProgressSpinnerMixinBase = mixinColor(MatProgressSpinnerBase, 'primary');
/** Injection token to be used to override the default options for `mat-progress-spinner`. */
export var MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS = new InjectionToken('mat-progress-spinner-default-options', {
    providedIn: 'root',
    factory: MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY,
});
/** @docs-private */
export function MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY() {
    return { diameter: BASE_SIZE };
}
// .0001 percentage difference is necessary in order to avoid unwanted animation frames
// for example because the animation duration is 4 seconds, .1% accounts to 4ms
// which are enough to see the flicker described in
// https://github.com/angular/components/issues/8984
var INDETERMINATE_ANIMATION_TEMPLATE = "\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n";
/**
 * `<mat-progress-spinner>` component.
 */
var MatProgressSpinner = /** @class */ (function (_super) {
    __extends(MatProgressSpinner, _super);
    function MatProgressSpinner(_elementRef, platform, _document, animationMode, defaults) {
        var _this = _super.call(this, _elementRef) || this;
        _this._elementRef = _elementRef;
        _this._document = _document;
        _this._diameter = BASE_SIZE;
        _this._value = 0;
        _this._fallbackAnimation = false;
        /** Mode of the progress circle */
        _this.mode = 'determinate';
        var trackedDiameters = MatProgressSpinner._diameters;
        // The base size is already inserted via the component's structural styles. We still
        // need to track it so we don't end up adding the same styles again.
        if (!trackedDiameters.has(_document.head)) {
            trackedDiameters.set(_document.head, new Set([BASE_SIZE]));
        }
        _this._fallbackAnimation = platform.EDGE || platform.TRIDENT;
        _this._noopAnimations = animationMode === 'NoopAnimations' &&
            (!!defaults && !defaults._forceAnimations);
        if (defaults) {
            if (defaults.diameter) {
                _this.diameter = defaults.diameter;
            }
            if (defaults.strokeWidth) {
                _this.strokeWidth = defaults.strokeWidth;
            }
        }
        return _this;
    }
    Object.defineProperty(MatProgressSpinner.prototype, "diameter", {
        /** The diameter of the progress spinner (will set width and height of svg). */
        get: function () { return this._diameter; },
        set: function (size) {
            this._diameter = coerceNumberProperty(size);
            // If this is set before `ngOnInit`, the style root may not have been resolved yet.
            if (!this._fallbackAnimation && this._styleRoot) {
                this._attachStyleNode();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatProgressSpinner.prototype, "strokeWidth", {
        /** Stroke width of the progress spinner. */
        get: function () {
            return this._strokeWidth || this.diameter / 10;
        },
        set: function (value) {
            this._strokeWidth = coerceNumberProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatProgressSpinner.prototype, "value", {
        /** Value of the progress circle. */
        get: function () {
            return this.mode === 'determinate' ? this._value : 0;
        },
        set: function (newValue) {
            this._value = Math.max(0, Math.min(100, coerceNumberProperty(newValue)));
        },
        enumerable: true,
        configurable: true
    });
    MatProgressSpinner.prototype.ngOnInit = function () {
        var element = this._elementRef.nativeElement;
        // Note that we need to look up the root node in ngOnInit, rather than the constructor, because
        // Angular seems to create the element outside the shadow root and then moves it inside, if the
        // node is inside an `ngIf` and a ShadowDom-encapsulated component.
        this._styleRoot = _getShadowRoot(element) || this._document.head;
        this._attachStyleNode();
        // On IE and Edge, we can't animate the `stroke-dashoffset`
        // reliably so we fall back to a non-spec animation.
        var animationClass = "mat-progress-spinner-indeterminate" + (this._fallbackAnimation ? '-fallback' : '') + "-animation";
        element.classList.add(animationClass);
    };
    Object.defineProperty(MatProgressSpinner.prototype, "_circleRadius", {
        /** The radius of the spinner, adjusted for stroke width. */
        get: function () {
            return (this.diameter - BASE_STROKE_WIDTH) / 2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatProgressSpinner.prototype, "_viewBox", {
        /** The view box of the spinner's svg element. */
        get: function () {
            var viewBox = this._circleRadius * 2 + this.strokeWidth;
            return "0 0 " + viewBox + " " + viewBox;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatProgressSpinner.prototype, "_strokeCircumference", {
        /** The stroke circumference of the svg circle. */
        get: function () {
            return 2 * Math.PI * this._circleRadius;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatProgressSpinner.prototype, "_strokeDashOffset", {
        /** The dash offset of the svg circle. */
        get: function () {
            if (this.mode === 'determinate') {
                return this._strokeCircumference * (100 - this._value) / 100;
            }
            // In fallback mode set the circle to 80% and rotate it with CSS.
            if (this._fallbackAnimation && this.mode === 'indeterminate') {
                return this._strokeCircumference * 0.2;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatProgressSpinner.prototype, "_circleStrokeWidth", {
        /** Stroke width of the circle in percent. */
        get: function () {
            return this.strokeWidth / this.diameter * 100;
        },
        enumerable: true,
        configurable: true
    });
    /** Dynamically generates a style tag containing the correct animation for this diameter. */
    MatProgressSpinner.prototype._attachStyleNode = function () {
        var styleRoot = this._styleRoot;
        var currentDiameter = this._diameter;
        var diameters = MatProgressSpinner._diameters;
        var diametersForElement = diameters.get(styleRoot);
        if (!diametersForElement || !diametersForElement.has(currentDiameter)) {
            var styleTag = this._document.createElement('style');
            styleTag.setAttribute('mat-spinner-animation', currentDiameter + '');
            styleTag.textContent = this._getAnimationText();
            styleRoot.appendChild(styleTag);
            if (!diametersForElement) {
                diametersForElement = new Set();
                diameters.set(styleRoot, diametersForElement);
            }
            diametersForElement.add(currentDiameter);
        }
    };
    /** Generates animation styles adjusted for the spinner's diameter. */
    MatProgressSpinner.prototype._getAnimationText = function () {
        return INDETERMINATE_ANIMATION_TEMPLATE
            // Animation should begin at 5% and end at 80%
            .replace(/START_VALUE/g, "" + 0.95 * this._strokeCircumference)
            .replace(/END_VALUE/g, "" + 0.2 * this._strokeCircumference)
            .replace(/DIAMETER/g, "" + this.diameter);
    };
    /**
     * Tracks diameters of existing instances to de-dupe generated styles (default d = 100).
     * We need to keep track of which elements the diameters were attached to, because for
     * elements in the Shadow DOM the style tags are attached to the shadow root, rather
     * than the document head.
     */
    MatProgressSpinner._diameters = new WeakMap();
    /** @nocollapse */
    MatProgressSpinner.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Platform },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,] }] }
    ]; };
    MatProgressSpinner.propDecorators = {
        diameter: [{ type: Input }],
        strokeWidth: [{ type: Input }],
        mode: [{ type: Input }],
        value: [{ type: Input }]
    };
MatProgressSpinner.ɵfac = function MatProgressSpinner_Factory(t) { return new (t || MatProgressSpinner)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), ɵngcc0.ɵɵdirectiveInject(MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS)); };
MatProgressSpinner.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatProgressSpinner, selectors: [["mat-progress-spinner"]], hostAttrs: ["role", "progressbar", 1, "mat-progress-spinner"], hostVars: 10, hostBindings: function MatProgressSpinner_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.mode === "determinate" ? 0 : null)("aria-valuemax", ctx.mode === "determinate" ? 100 : null)("aria-valuenow", ctx.mode === "determinate" ? ctx.value : null)("mode", ctx.mode);
        ɵngcc0.ɵɵstyleProp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        ɵngcc0.ɵɵclassProp("_mat-animation-noopable", ctx._noopAnimations);
    } }, inputs: { color: "color", diameter: "diameter", strokeWidth: "strokeWidth", value: "value", mode: "mode" }, exportAs: ["matProgressSpinner"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 8, consts: [["preserveAspectRatio", "xMidYMid meet", "focusable", "false", 3, "ngSwitch"], ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%"]], template: function MatProgressSpinner_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "svg", 0);
        ɵngcc0.ɵɵtemplate(1, MatProgressSpinner__svg_circle_1_Template, 1, 9, "circle", 1);
        ɵngcc0.ɵɵtemplate(2, MatProgressSpinner__svg_circle_2_Template, 1, 7, "circle", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.mode === "indeterminate");
        ɵngcc0.ɵɵattribute("viewBox", ctx._viewBox);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", false);
    } }, directives: [ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase], styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatProgressSpinner, [{
        type: Component,
        args: [{
                selector: 'mat-progress-spinner',
                exportAs: 'matProgressSpinner',
                host: {
                    'role': 'progressbar',
                    'class': 'mat-progress-spinner',
                    '[class._mat-animation-noopable]': "_noopAnimations",
                    '[style.width.px]': 'diameter',
                    '[style.height.px]': 'diameter',
                    '[attr.aria-valuemin]': 'mode === "determinate" ? 0 : null',
                    '[attr.aria-valuemax]': 'mode === "determinate" ? 100 : null',
                    '[attr.aria-valuenow]': 'mode === "determinate" ? value : null',
                    '[attr.mode]': 'mode'
                },
                inputs: ['color'],
                template: "<!--\n  preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's\n  center. The center of the circle will remain at the center of the mat-progress-spinner\n  element containing the SVG. `focusable=\"false\"` prevents IE from allowing the user to\n  tab into the SVG element.\n-->\n\n<svg\n  [style.width.px]=\"diameter\"\n  [style.height.px]=\"diameter\"\n  [attr.viewBox]=\"_viewBox\"\n  preserveAspectRatio=\"xMidYMid meet\"\n  focusable=\"false\"\n  [ngSwitch]=\"mode === 'indeterminate'\">\n\n  <!--\n    Technically we can reuse the same `circle` element, however Safari has an issue that breaks\n    the SVG rendering in determinate mode, after switching between indeterminate and determinate.\n    Using a different element avoids the issue. An alternative to this is adding `display: none`\n    for a split second and then removing it when switching between modes, but it's hard to know\n    for how long to hide the element and it can cause the UI to blink.\n  -->\n  <circle\n    *ngSwitchCase=\"true\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_circleRadius\"\n    [style.animation-name]=\"'mat-progress-spinner-stroke-rotate-' + diameter\"\n    [style.stroke-dashoffset.px]=\"_strokeDashOffset\"\n    [style.stroke-dasharray.px]=\"_strokeCircumference\"\n    [style.stroke-width.%]=\"_circleStrokeWidth\"></circle>\n\n  <circle\n    *ngSwitchCase=\"false\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_circleRadius\"\n    [style.stroke-dashoffset.px]=\"_strokeDashOffset\"\n    [style.stroke-dasharray.px]=\"_strokeCircumference\"\n    [style.stroke-width.%]=\"_circleStrokeWidth\"></circle>\n</svg>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.Platform }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS]
            }] }]; }, { diameter: [{
            type: Input
        }], strokeWidth: [{
            type: Input
        }], value: [{
            type: Input
        }], mode: [{
            type: Input
        }] }); })();
    return MatProgressSpinner;
}(_MatProgressSpinnerMixinBase));
export { MatProgressSpinner };
/**
 * `<mat-spinner>` component.
 *
 * This is a component definition to be used as a convenience reference to create an
 * indeterminate `<mat-progress-spinner>` instance.
 */
var MatSpinner = /** @class */ (function (_super) {
    __extends(MatSpinner, _super);
    function MatSpinner(elementRef, platform, document, animationMode, defaults) {
        var _this = _super.call(this, elementRef, platform, document, animationMode, defaults) || this;
        _this.mode = 'indeterminate';
        return _this;
    }
    /** @nocollapse */
    MatSpinner.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Platform },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,] }] }
    ]; };
MatSpinner.ɵfac = function MatSpinner_Factory(t) { return new (t || MatSpinner)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), ɵngcc0.ɵɵdirectiveInject(MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS)); };
MatSpinner.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSpinner, selectors: [["mat-spinner"]], hostAttrs: ["role", "progressbar", "mode", "indeterminate", 1, "mat-spinner", "mat-progress-spinner"], hostVars: 6, hostBindings: function MatSpinner_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        ɵngcc0.ɵɵclassProp("_mat-animation-noopable", ctx._noopAnimations);
    } }, inputs: { color: "color" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 8, consts: [["preserveAspectRatio", "xMidYMid meet", "focusable", "false", 3, "ngSwitch"], ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%"]], template: function MatSpinner_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "svg", 0);
        ɵngcc0.ɵɵtemplate(1, MatSpinner__svg_circle_1_Template, 1, 9, "circle", 1);
        ɵngcc0.ɵɵtemplate(2, MatSpinner__svg_circle_2_Template, 1, 7, "circle", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.mode === "indeterminate");
        ɵngcc0.ɵɵattribute("viewBox", ctx._viewBox);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", false);
    } }, directives: [ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase], styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSpinner, [{
        type: Component,
        args: [{
                selector: 'mat-spinner',
                host: {
                    'role': 'progressbar',
                    'mode': 'indeterminate',
                    'class': 'mat-spinner mat-progress-spinner',
                    '[class._mat-animation-noopable]': "_noopAnimations",
                    '[style.width.px]': 'diameter',
                    '[style.height.px]': 'diameter'
                },
                inputs: ['color'],
                template: "<!--\n  preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's\n  center. The center of the circle will remain at the center of the mat-progress-spinner\n  element containing the SVG. `focusable=\"false\"` prevents IE from allowing the user to\n  tab into the SVG element.\n-->\n\n<svg\n  [style.width.px]=\"diameter\"\n  [style.height.px]=\"diameter\"\n  [attr.viewBox]=\"_viewBox\"\n  preserveAspectRatio=\"xMidYMid meet\"\n  focusable=\"false\"\n  [ngSwitch]=\"mode === 'indeterminate'\">\n\n  <!--\n    Technically we can reuse the same `circle` element, however Safari has an issue that breaks\n    the SVG rendering in determinate mode, after switching between indeterminate and determinate.\n    Using a different element avoids the issue. An alternative to this is adding `display: none`\n    for a split second and then removing it when switching between modes, but it's hard to know\n    for how long to hide the element and it can cause the UI to blink.\n  -->\n  <circle\n    *ngSwitchCase=\"true\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_circleRadius\"\n    [style.animation-name]=\"'mat-progress-spinner-stroke-rotate-' + diameter\"\n    [style.stroke-dashoffset.px]=\"_strokeDashOffset\"\n    [style.stroke-dasharray.px]=\"_strokeCircumference\"\n    [style.stroke-width.%]=\"_circleStrokeWidth\"></circle>\n\n  <circle\n    *ngSwitchCase=\"false\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_circleRadius\"\n    [style.stroke-dashoffset.px]=\"_strokeDashOffset\"\n    [style.stroke-dasharray.px]=\"_strokeCircumference\"\n    [style.stroke-width.%]=\"_circleStrokeWidth\"></circle>\n</svg>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.Platform }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS]
            }] }]; }, null); })();
    return MatSpinner;
}(MatProgressSpinner));
export { MatSpinner };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9AYW5ndWxhci9tYXRlcmlhbC9lc201L3Byb2dyZXNzLXNwaW5uZXIvcHJvZ3Jlc3Mtc3Bpbm5lci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0RBNkxrRCxBQXNCNUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFjQTs7Ozs7Ozs7Ozs7Ozs7OztLQWdCRCxBQWtCQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBUUciLCJmaWxlIjoicHJvZ3Jlc3Mtc3Bpbm5lci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBjb2VyY2VOdW1iZXJQcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBQbGF0Zm9ybSwgX2dldFNoYWRvd1Jvb3QgfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3Rpb25Ub2tlbiwgSW5wdXQsIE9wdGlvbmFsLCBWaWV3RW5jYXBzdWxhdGlvbiwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG1peGluQ29sb3IgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcbmltcG9ydCB7IEFOSU1BVElPTl9NT0RVTEVfVFlQRSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG4vKipcbiAqIEJhc2UgcmVmZXJlbmNlIHNpemUgb2YgdGhlIHNwaW5uZXIuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBCQVNFX1NJWkUgPSAxMDA7XG4vKipcbiAqIEJhc2UgcmVmZXJlbmNlIHN0cm9rZSB3aWR0aCBvZiB0aGUgc3Bpbm5lci5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIEJBU0VfU1RST0tFX1dJRFRIID0gMTA7XG4vLyBCb2lsZXJwbGF0ZSBmb3IgYXBwbHlpbmcgbWl4aW5zIHRvIE1hdFByb2dyZXNzU3Bpbm5lci5cbi8qKiBAZG9jcy1wcml2YXRlICovXG52YXIgTWF0UHJvZ3Jlc3NTcGlubmVyQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRQcm9ncmVzc1NwaW5uZXJCYXNlKF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdFByb2dyZXNzU3Bpbm5lckJhc2U7XG59KCkpO1xudmFyIF9NYXRQcm9ncmVzc1NwaW5uZXJNaXhpbkJhc2UgPSBtaXhpbkNvbG9yKE1hdFByb2dyZXNzU3Bpbm5lckJhc2UsICdwcmltYXJ5Jyk7XG4vKiogSW5qZWN0aW9uIHRva2VuIHRvIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgYG1hdC1wcm9ncmVzcy1zcGlubmVyYC4gKi9cbmV4cG9ydCB2YXIgTUFUX1BST0dSRVNTX1NQSU5ORVJfREVGQVVMVF9PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuKCdtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1kZWZhdWx0LW9wdGlvbnMnLCB7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxuICAgIGZhY3Rvcnk6IE1BVF9QUk9HUkVTU19TUElOTkVSX0RFRkFVTFRfT1BUSU9OU19GQUNUT1JZLFxufSk7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1BVF9QUk9HUkVTU19TUElOTkVSX0RFRkFVTFRfT1BUSU9OU19GQUNUT1JZKCkge1xuICAgIHJldHVybiB7IGRpYW1ldGVyOiBCQVNFX1NJWkUgfTtcbn1cbi8vIC4wMDAxIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gYXZvaWQgdW53YW50ZWQgYW5pbWF0aW9uIGZyYW1lc1xuLy8gZm9yIGV4YW1wbGUgYmVjYXVzZSB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGlzIDQgc2Vjb25kcywgLjElIGFjY291bnRzIHRvIDRtc1xuLy8gd2hpY2ggYXJlIGVub3VnaCB0byBzZWUgdGhlIGZsaWNrZXIgZGVzY3JpYmVkIGluXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9jb21wb25lbnRzL2lzc3Vlcy84OTg0XG52YXIgSU5ERVRFUk1JTkFURV9BTklNQVRJT05fVEVNUExBVEUgPSBcIlxcbiBAa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLXN0cm9rZS1yb3RhdGUtRElBTUVURVIge1xcbiAgICAwJSAgICAgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IFNUQVJUX1ZBTFVFOyAgdHJhbnNmb3JtOiByb3RhdGUoMCk7IH1cXG4gICAgMTIuNSUgICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBFTkRfVkFMVUU7ICAgIHRyYW5zZm9ybTogcm90YXRlKDApOyB9XFxuICAgIDEyLjUwMDElICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBFTkRfVkFMVUU7ICAgIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpIHJvdGF0ZSg3Mi41ZGVnKTsgfVxcbiAgICAyNSUgICAgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IFNUQVJUX1ZBTFVFOyAgdHJhbnNmb3JtOiByb3RhdGVYKDE4MGRlZykgcm90YXRlKDcyLjVkZWcpOyB9XFxuXFxuICAgIDI1LjAwMDElICAgeyBzdHJva2UtZGFzaG9mZnNldDogU1RBUlRfVkFMVUU7ICB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpOyB9XFxuICAgIDM3LjUlICAgeyBzdHJva2UtZGFzaG9mZnNldDogRU5EX1ZBTFVFOyAgICB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpOyB9XFxuICAgIDM3LjUwMDElICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBFTkRfVkFMVUU7ICAgIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpIHJvdGF0ZSgxNjEuNWRlZyk7IH1cXG4gICAgNTAlICAgICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTsgIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpIHJvdGF0ZSgxNjEuNWRlZyk7IH1cXG5cXG4gICAgNTAuMDAwMSUgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IFNUQVJUX1ZBTFVFOyAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxcbiAgICA2Mi41JSAgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IEVORF9WQUxVRTsgICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxcbiAgICA2Mi41MDAxJSAgeyBzdHJva2UtZGFzaG9mZnNldDogRU5EX1ZBTFVFOyAgICB0cmFuc2Zvcm06IHJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoMjUxLjVkZWcpOyB9XFxuICAgIDc1JSAgICAgeyBzdHJva2UtZGFzaG9mZnNldDogU1RBUlRfVkFMVUU7ICB0cmFuc2Zvcm06IHJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoMjUxLjVkZWcpOyB9XFxuXFxuICAgIDc1LjAwMDElICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTsgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTsgfVxcbiAgICA4Ny41JSAgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IEVORF9WQUxVRTsgICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpOyB9XFxuICAgIDg3LjUwMDElICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBFTkRfVkFMVUU7ICAgIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpIHJvdGF0ZSgzNDEuNWRlZyk7IH1cXG4gICAgMTAwJSAgICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTsgIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpIHJvdGF0ZSgzNDEuNWRlZyk7IH1cXG4gIH1cXG5cIjtcbi8qKlxuICogYDxtYXQtcHJvZ3Jlc3Mtc3Bpbm5lcj5gIGNvbXBvbmVudC5cbiAqL1xudmFyIE1hdFByb2dyZXNzU3Bpbm5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF0UHJvZ3Jlc3NTcGlubmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hdFByb2dyZXNzU3Bpbm5lcihfZWxlbWVudFJlZiwgcGxhdGZvcm0sIF9kb2N1bWVudCwgYW5pbWF0aW9uTW9kZSwgZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX2VsZW1lbnRSZWYpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIF90aGlzLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcbiAgICAgICAgX3RoaXMuX2RpYW1ldGVyID0gQkFTRV9TSVpFO1xuICAgICAgICBfdGhpcy5fdmFsdWUgPSAwO1xuICAgICAgICBfdGhpcy5fZmFsbGJhY2tBbmltYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqIE1vZGUgb2YgdGhlIHByb2dyZXNzIGNpcmNsZSAqL1xuICAgICAgICBfdGhpcy5tb2RlID0gJ2RldGVybWluYXRlJztcbiAgICAgICAgdmFyIHRyYWNrZWREaWFtZXRlcnMgPSBNYXRQcm9ncmVzc1NwaW5uZXIuX2RpYW1ldGVycztcbiAgICAgICAgLy8gVGhlIGJhc2Ugc2l6ZSBpcyBhbHJlYWR5IGluc2VydGVkIHZpYSB0aGUgY29tcG9uZW50J3Mgc3RydWN0dXJhbCBzdHlsZXMuIFdlIHN0aWxsXG4gICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgaXQgc28gd2UgZG9uJ3QgZW5kIHVwIGFkZGluZyB0aGUgc2FtZSBzdHlsZXMgYWdhaW4uXG4gICAgICAgIGlmICghdHJhY2tlZERpYW1ldGVycy5oYXMoX2RvY3VtZW50LmhlYWQpKSB7XG4gICAgICAgICAgICB0cmFja2VkRGlhbWV0ZXJzLnNldChfZG9jdW1lbnQuaGVhZCwgbmV3IFNldChbQkFTRV9TSVpFXSkpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9mYWxsYmFja0FuaW1hdGlvbiA9IHBsYXRmb3JtLkVER0UgfHwgcGxhdGZvcm0uVFJJREVOVDtcbiAgICAgICAgX3RoaXMuX25vb3BBbmltYXRpb25zID0gYW5pbWF0aW9uTW9kZSA9PT0gJ05vb3BBbmltYXRpb25zJyAmJlxuICAgICAgICAgICAgKCEhZGVmYXVsdHMgJiYgIWRlZmF1bHRzLl9mb3JjZUFuaW1hdGlvbnMpO1xuICAgICAgICBpZiAoZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0cy5kaWFtZXRlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpYW1ldGVyID0gZGVmYXVsdHMuZGlhbWV0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3Ryb2tlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdHJva2VXaWR0aCA9IGRlZmF1bHRzLnN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwiZGlhbWV0ZXJcIiwge1xuICAgICAgICAvKiogVGhlIGRpYW1ldGVyIG9mIHRoZSBwcm9ncmVzcyBzcGlubmVyICh3aWxsIHNldCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHN2ZykuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlhbWV0ZXI7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpYW1ldGVyID0gY29lcmNlTnVtYmVyUHJvcGVydHkoc2l6ZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHNldCBiZWZvcmUgYG5nT25Jbml0YCwgdGhlIHN0eWxlIHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVzb2x2ZWQgeWV0LlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9mYWxsYmFja0FuaW1hdGlvbiAmJiB0aGlzLl9zdHlsZVJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hTdHlsZU5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwge1xuICAgICAgICAvKiogU3Ryb2tlIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBzcGlubmVyLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJva2VXaWR0aCB8fCB0aGlzLmRpYW1ldGVyIC8gMTA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2VXaWR0aCA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKiogVmFsdWUgb2YgdGhlIHByb2dyZXNzIGNpcmNsZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAnZGV0ZXJtaW5hdGUnID8gdGhpcy5fdmFsdWUgOiAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIGNvZXJjZU51bWJlclByb3BlcnR5KG5ld1ZhbHVlKSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYXRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIG5lZWQgdG8gbG9vayB1cCB0aGUgcm9vdCBub2RlIGluIG5nT25Jbml0LCByYXRoZXIgdGhhbiB0aGUgY29uc3RydWN0b3IsIGJlY2F1c2VcbiAgICAgICAgLy8gQW5ndWxhciBzZWVtcyB0byBjcmVhdGUgdGhlIGVsZW1lbnQgb3V0c2lkZSB0aGUgc2hhZG93IHJvb3QgYW5kIHRoZW4gbW92ZXMgaXQgaW5zaWRlLCBpZiB0aGVcbiAgICAgICAgLy8gbm9kZSBpcyBpbnNpZGUgYW4gYG5nSWZgIGFuZCBhIFNoYWRvd0RvbS1lbmNhcHN1bGF0ZWQgY29tcG9uZW50LlxuICAgICAgICB0aGlzLl9zdHlsZVJvb3QgPSBfZ2V0U2hhZG93Um9vdChlbGVtZW50KSB8fCB0aGlzLl9kb2N1bWVudC5oZWFkO1xuICAgICAgICB0aGlzLl9hdHRhY2hTdHlsZU5vZGUoKTtcbiAgICAgICAgLy8gT24gSUUgYW5kIEVkZ2UsIHdlIGNhbid0IGFuaW1hdGUgdGhlIGBzdHJva2UtZGFzaG9mZnNldGBcbiAgICAgICAgLy8gcmVsaWFibHkgc28gd2UgZmFsbCBiYWNrIHRvIGEgbm9uLXNwZWMgYW5pbWF0aW9uLlxuICAgICAgICB2YXIgYW5pbWF0aW9uQ2xhc3MgPSBcIm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGVcIiArICh0aGlzLl9mYWxsYmFja0FuaW1hdGlvbiA/ICctZmFsbGJhY2snIDogJycpICsgXCItYW5pbWF0aW9uXCI7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChhbmltYXRpb25DbGFzcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0UHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZSwgXCJfY2lyY2xlUmFkaXVzXCIsIHtcbiAgICAgICAgLyoqIFRoZSByYWRpdXMgb2YgdGhlIHNwaW5uZXIsIGFkanVzdGVkIGZvciBzdHJva2Ugd2lkdGguICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRpYW1ldGVyIC0gQkFTRV9TVFJPS0VfV0lEVEgpIC8gMjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwiX3ZpZXdCb3hcIiwge1xuICAgICAgICAvKiogVGhlIHZpZXcgYm94IG9mIHRoZSBzcGlubmVyJ3Mgc3ZnIGVsZW1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZpZXdCb3ggPSB0aGlzLl9jaXJjbGVSYWRpdXMgKiAyICsgdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgICAgIHJldHVybiBcIjAgMCBcIiArIHZpZXdCb3ggKyBcIiBcIiArIHZpZXdCb3g7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcIl9zdHJva2VDaXJjdW1mZXJlbmNlXCIsIHtcbiAgICAgICAgLyoqIFRoZSBzdHJva2UgY2lyY3VtZmVyZW5jZSBvZiB0aGUgc3ZnIGNpcmNsZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIE1hdGguUEkgKiB0aGlzLl9jaXJjbGVSYWRpdXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcIl9zdHJva2VEYXNoT2Zmc2V0XCIsIHtcbiAgICAgICAgLyoqIFRoZSBkYXNoIG9mZnNldCBvZiB0aGUgc3ZnIGNpcmNsZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnZGV0ZXJtaW5hdGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0cm9rZUNpcmN1bWZlcmVuY2UgKiAoMTAwIC0gdGhpcy5fdmFsdWUpIC8gMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW4gZmFsbGJhY2sgbW9kZSBzZXQgdGhlIGNpcmNsZSB0byA4MCUgYW5kIHJvdGF0ZSBpdCB3aXRoIENTUy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mYWxsYmFja0FuaW1hdGlvbiAmJiB0aGlzLm1vZGUgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJva2VDaXJjdW1mZXJlbmNlICogMC4yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcIl9jaXJjbGVTdHJva2VXaWR0aFwiLCB7XG4gICAgICAgIC8qKiBTdHJva2Ugd2lkdGggb2YgdGhlIGNpcmNsZSBpbiBwZXJjZW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cm9rZVdpZHRoIC8gdGhpcy5kaWFtZXRlciAqIDEwMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIER5bmFtaWNhbGx5IGdlbmVyYXRlcyBhIHN0eWxlIHRhZyBjb250YWluaW5nIHRoZSBjb3JyZWN0IGFuaW1hdGlvbiBmb3IgdGhpcyBkaWFtZXRlci4gKi9cbiAgICBNYXRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLl9hdHRhY2hTdHlsZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHlsZVJvb3QgPSB0aGlzLl9zdHlsZVJvb3Q7XG4gICAgICAgIHZhciBjdXJyZW50RGlhbWV0ZXIgPSB0aGlzLl9kaWFtZXRlcjtcbiAgICAgICAgdmFyIGRpYW1ldGVycyA9IE1hdFByb2dyZXNzU3Bpbm5lci5fZGlhbWV0ZXJzO1xuICAgICAgICB2YXIgZGlhbWV0ZXJzRm9yRWxlbWVudCA9IGRpYW1ldGVycy5nZXQoc3R5bGVSb290KTtcbiAgICAgICAgaWYgKCFkaWFtZXRlcnNGb3JFbGVtZW50IHx8ICFkaWFtZXRlcnNGb3JFbGVtZW50LmhhcyhjdXJyZW50RGlhbWV0ZXIpKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVUYWcgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdtYXQtc3Bpbm5lci1hbmltYXRpb24nLCBjdXJyZW50RGlhbWV0ZXIgKyAnJyk7XG4gICAgICAgICAgICBzdHlsZVRhZy50ZXh0Q29udGVudCA9IHRoaXMuX2dldEFuaW1hdGlvblRleHQoKTtcbiAgICAgICAgICAgIHN0eWxlUm9vdC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG4gICAgICAgICAgICBpZiAoIWRpYW1ldGVyc0ZvckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkaWFtZXRlcnNGb3JFbGVtZW50ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGRpYW1ldGVycy5zZXQoc3R5bGVSb290LCBkaWFtZXRlcnNGb3JFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpYW1ldGVyc0ZvckVsZW1lbnQuYWRkKGN1cnJlbnREaWFtZXRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBHZW5lcmF0ZXMgYW5pbWF0aW9uIHN0eWxlcyBhZGp1c3RlZCBmb3IgdGhlIHNwaW5uZXIncyBkaWFtZXRlci4gKi9cbiAgICBNYXRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLl9nZXRBbmltYXRpb25UZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gSU5ERVRFUk1JTkFURV9BTklNQVRJT05fVEVNUExBVEVcbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbiBzaG91bGQgYmVnaW4gYXQgNSUgYW5kIGVuZCBhdCA4MCVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9TVEFSVF9WQUxVRS9nLCBcIlwiICsgMC45NSAqIHRoaXMuX3N0cm9rZUNpcmN1bWZlcmVuY2UpXG4gICAgICAgICAgICAucmVwbGFjZSgvRU5EX1ZBTFVFL2csIFwiXCIgKyAwLjIgKiB0aGlzLl9zdHJva2VDaXJjdW1mZXJlbmNlKVxuICAgICAgICAgICAgLnJlcGxhY2UoL0RJQU1FVEVSL2csIFwiXCIgKyB0aGlzLmRpYW1ldGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYWNrcyBkaWFtZXRlcnMgb2YgZXhpc3RpbmcgaW5zdGFuY2VzIHRvIGRlLWR1cGUgZ2VuZXJhdGVkIHN0eWxlcyAoZGVmYXVsdCBkID0gMTAwKS5cbiAgICAgKiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZWxlbWVudHMgdGhlIGRpYW1ldGVycyB3ZXJlIGF0dGFjaGVkIHRvLCBiZWNhdXNlIGZvclxuICAgICAqIGVsZW1lbnRzIGluIHRoZSBTaGFkb3cgRE9NIHRoZSBzdHlsZSB0YWdzIGFyZSBhdHRhY2hlZCB0byB0aGUgc2hhZG93IHJvb3QsIHJhdGhlclxuICAgICAqIHRoYW4gdGhlIGRvY3VtZW50IGhlYWQuXG4gICAgICovXG4gICAgTWF0UHJvZ3Jlc3NTcGlubmVyLl9kaWFtZXRlcnMgPSBuZXcgV2Vha01hcCgpO1xuICAgIE1hdFByb2dyZXNzU3Bpbm5lci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYXQtcHJvZ3Jlc3Mtc3Bpbm5lcicsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbWF0UHJvZ3Jlc3NTcGlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1wcm9ncmVzcy1zcGlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MuX21hdC1hbmltYXRpb24tbm9vcGFibGVdJzogXCJfbm9vcEFuaW1hdGlvbnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICdbc3R5bGUud2lkdGgucHhdJzogJ2RpYW1ldGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbc3R5bGUuaGVpZ2h0LnB4XSc6ICdkaWFtZXRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS12YWx1ZW1pbl0nOiAnbW9kZSA9PT0gXCJkZXRlcm1pbmF0ZVwiID8gMCA6IG51bGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtYXhdJzogJ21vZGUgPT09IFwiZGV0ZXJtaW5hdGVcIiA/IDEwMCA6IG51bGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVub3ddJzogJ21vZGUgPT09IFwiZGV0ZXJtaW5hdGVcIiA/IHZhbHVlIDogbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIubW9kZV0nOiAnbW9kZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydjb2xvciddLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8IS0tXFxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvIG9mIHhNaWRZTWlkIG1lZXQgYXMgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgaXMgdGhlIGNpcmNsZSdzXFxuICBjZW50ZXIuIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSB3aWxsIHJlbWFpbiBhdCB0aGUgY2VudGVyIG9mIHRoZSBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lclxcbiAgZWxlbWVudCBjb250YWluaW5nIHRoZSBTVkcuIGBmb2N1c2FibGU9XFxcImZhbHNlXFxcImAgcHJldmVudHMgSUUgZnJvbSBhbGxvd2luZyB0aGUgdXNlciB0b1xcbiAgdGFiIGludG8gdGhlIFNWRyBlbGVtZW50Llxcbi0tPlxcblxcbjxzdmdcXG4gIFtzdHlsZS53aWR0aC5weF09XFxcImRpYW1ldGVyXFxcIlxcbiAgW3N0eWxlLmhlaWdodC5weF09XFxcImRpYW1ldGVyXFxcIlxcbiAgW2F0dHIudmlld0JveF09XFxcIl92aWV3Qm94XFxcIlxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCJcXG4gIGZvY3VzYWJsZT1cXFwiZmFsc2VcXFwiXFxuICBbbmdTd2l0Y2hdPVxcXCJtb2RlID09PSAnaW5kZXRlcm1pbmF0ZSdcXFwiPlxcblxcbiAgPCEtLVxcbiAgICBUZWNobmljYWxseSB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgYGNpcmNsZWAgZWxlbWVudCwgaG93ZXZlciBTYWZhcmkgaGFzIGFuIGlzc3VlIHRoYXQgYnJlYWtzXFxuICAgIHRoZSBTVkcgcmVuZGVyaW5nIGluIGRldGVybWluYXRlIG1vZGUsIGFmdGVyIHN3aXRjaGluZyBiZXR3ZWVuIGluZGV0ZXJtaW5hdGUgYW5kIGRldGVybWluYXRlLlxcbiAgICBVc2luZyBhIGRpZmZlcmVudCBlbGVtZW50IGF2b2lkcyB0aGUgaXNzdWUuIEFuIGFsdGVybmF0aXZlIHRvIHRoaXMgaXMgYWRkaW5nIGBkaXNwbGF5OiBub25lYFxcbiAgICBmb3IgYSBzcGxpdCBzZWNvbmQgYW5kIHRoZW4gcmVtb3ZpbmcgaXQgd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBtb2RlcywgYnV0IGl0J3MgaGFyZCB0byBrbm93XFxuICAgIGZvciBob3cgbG9uZyB0byBoaWRlIHRoZSBlbGVtZW50IGFuZCBpdCBjYW4gY2F1c2UgdGhlIFVJIHRvIGJsaW5rLlxcbiAgLS0+XFxuICA8Y2lyY2xlXFxuICAgICpuZ1N3aXRjaENhc2U9XFxcInRydWVcXFwiXFxuICAgIGN4PVxcXCI1MCVcXFwiXFxuICAgIGN5PVxcXCI1MCVcXFwiXFxuICAgIFthdHRyLnJdPVxcXCJfY2lyY2xlUmFkaXVzXFxcIlxcbiAgICBbc3R5bGUuYW5pbWF0aW9uLW5hbWVdPVxcXCInbWF0LXByb2dyZXNzLXNwaW5uZXItc3Ryb2tlLXJvdGF0ZS0nICsgZGlhbWV0ZXJcXFwiXFxuICAgIFtzdHlsZS5zdHJva2UtZGFzaG9mZnNldC5weF09XFxcIl9zdHJva2VEYXNoT2Zmc2V0XFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLWRhc2hhcnJheS5weF09XFxcIl9zdHJva2VDaXJjdW1mZXJlbmNlXFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoLiVdPVxcXCJfY2lyY2xlU3Ryb2tlV2lkdGhcXFwiPjwvY2lyY2xlPlxcblxcbiAgPGNpcmNsZVxcbiAgICAqbmdTd2l0Y2hDYXNlPVxcXCJmYWxzZVxcXCJcXG4gICAgY3g9XFxcIjUwJVxcXCJcXG4gICAgY3k9XFxcIjUwJVxcXCJcXG4gICAgW2F0dHIucl09XFxcIl9jaXJjbGVSYWRpdXNcXFwiXFxuICAgIFtzdHlsZS5zdHJva2UtZGFzaG9mZnNldC5weF09XFxcIl9zdHJva2VEYXNoT2Zmc2V0XFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLWRhc2hhcnJheS5weF09XFxcIl9zdHJva2VDaXJjdW1mZXJlbmNlXFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoLiVdPVxcXCJfY2lyY2xlU3Ryb2tlV2lkdGhcXFwiPjwvY2lyY2xlPlxcbjwvc3ZnPlxcblwiLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXByb2dyZXNzLXNwaW5uZXJ7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LXByb2dyZXNzLXNwaW5uZXIgc3Zne3Bvc2l0aW9uOmFic29sdXRlO3RyYW5zZm9ybTpyb3RhdGUoLTkwZGVnKTt0b3A6MDtsZWZ0OjA7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXI7b3ZlcmZsb3c6dmlzaWJsZX0ubWF0LXByb2dyZXNzLXNwaW5uZXIgY2lyY2xle2ZpbGw6dHJhbnNwYXJlbnQ7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXI7dHJhbnNpdGlvbjpzdHJva2UtZGFzaG9mZnNldCAyMjVtcyBsaW5lYXJ9Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlLm1hdC1wcm9ncmVzcy1zcGlubmVyIGNpcmNsZXt0cmFuc2l0aW9uOm5vbmU7YW5pbWF0aW9uOm5vbmV9Lm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV17YW5pbWF0aW9uOm1hdC1wcm9ncmVzcy1zcGlubmVyLWxpbmVhci1yb3RhdGUgMjAwMG1zIGxpbmVhciBpbmZpbml0ZX0uX21hdC1hbmltYXRpb24tbm9vcGFibGUubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXXt0cmFuc2l0aW9uOm5vbmU7YW5pbWF0aW9uOm5vbmV9Lm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV0gY2lyY2xle3RyYW5zaXRpb24tcHJvcGVydHk6c3Ryb2tlO2FuaW1hdGlvbi1kdXJhdGlvbjo0MDAwbXM7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSk7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZX0uX21hdC1hbmltYXRpb24tbm9vcGFibGUubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXSBjaXJjbGV7dHJhbnNpdGlvbjpub25lO2FuaW1hdGlvbjpub25lfS5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1pbmRldGVybWluYXRlLWZhbGxiYWNrLWFuaW1hdGlvblttb2RlPWluZGV0ZXJtaW5hdGVde2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zdHJva2Utcm90YXRlLWZhbGxiYWNrIDEwMDAwbXMgY3ViaWMtYmV6aWVyKDAuODcsIDAuMDMsIDAuMzMsIDEpIGluZmluaXRlfS5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZS5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1pbmRldGVybWluYXRlLWZhbGxiYWNrLWFuaW1hdGlvblttb2RlPWluZGV0ZXJtaW5hdGVde3RyYW5zaXRpb246bm9uZTthbmltYXRpb246bm9uZX0ubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1mYWxsYmFjay1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXSBjaXJjbGV7dHJhbnNpdGlvbi1wcm9wZXJ0eTpzdHJva2V9Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlLm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtZmFsbGJhY2stYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV0gY2lyY2xle3RyYW5zaXRpb246bm9uZTthbmltYXRpb246bm9uZX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLWxpbmVhci1yb3RhdGV7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zdHJva2Utcm90YXRlLTEwMHswJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMi41JXtzdHJva2UtZGFzaG9mZnNldDo1Ni41NDg2Njc3cHg7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMi41MDAxJXtzdHJva2UtZGFzaG9mZnNldDo1Ni41NDg2Njc3cHg7dHJhbnNmb3JtOnJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoNzIuNWRlZyl9MjUle3N0cm9rZS1kYXNob2Zmc2V0OjI2OC42MDYxNzE1NzVweDt0cmFuc2Zvcm06cm90YXRlWCgxODBkZWcpIHJvdGF0ZSg3Mi41ZGVnKX0yNS4wMDAxJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpfTM3LjUle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlKDI3MGRlZyl9MzcuNTAwMSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDE2MS41ZGVnKX01MCV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDE2MS41ZGVnKX01MC4wMDAxJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfTYyLjUle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlKDE4MGRlZyl9NjIuNTAwMSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDI1MS41ZGVnKX03NSV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDI1MS41ZGVnKX03NS4wMDAxJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyl9ODcuNSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfTg3LjUwMDEle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlWCgxODBkZWcpIHJvdGF0ZSgzNDEuNWRlZyl9MTAwJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoMzQxLjVkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLXN0cm9rZS1yb3RhdGUtZmFsbGJhY2t7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0yNSV7dHJhbnNmb3JtOnJvdGF0ZSgxMTcwZGVnKX01MCV7dHJhbnNmb3JtOnJvdGF0ZSgyMzQwZGVnKX03NSV7dHJhbnNmb3JtOnJvdGF0ZSgzNTEwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoNDY4MGRlZyl9fVxcblwiXVxuICAgICAgICAgICAgICAgIH1dIH1cbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE1hdFByb2dyZXNzU3Bpbm5lci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogUGxhdGZvcm0gfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbRE9DVU1FTlQsXSB9XSB9LFxuICAgICAgICB7IHR5cGU6IFN0cmluZywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtBTklNQVRJT05fTU9EVUxFX1RZUEUsXSB9XSB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTUFUX1BST0dSRVNTX1NQSU5ORVJfREVGQVVMVF9PUFRJT05TLF0gfV0gfVxuICAgIF07IH07XG4gICAgTWF0UHJvZ3Jlc3NTcGlubmVyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICBkaWFtZXRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgbW9kZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XVxuICAgIH07XG4gICAgcmV0dXJuIE1hdFByb2dyZXNzU3Bpbm5lcjtcbn0oX01hdFByb2dyZXNzU3Bpbm5lck1peGluQmFzZSkpO1xuZXhwb3J0IHsgTWF0UHJvZ3Jlc3NTcGlubmVyIH07XG4vKipcbiAqIGA8bWF0LXNwaW5uZXI+YCBjb21wb25lbnQuXG4gKlxuICogVGhpcyBpcyBhIGNvbXBvbmVudCBkZWZpbml0aW9uIHRvIGJlIHVzZWQgYXMgYSBjb252ZW5pZW5jZSByZWZlcmVuY2UgdG8gY3JlYXRlIGFuXG4gKiBpbmRldGVybWluYXRlIGA8bWF0LXByb2dyZXNzLXNwaW5uZXI+YCBpbnN0YW5jZS5cbiAqL1xudmFyIE1hdFNwaW5uZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hdFNwaW5uZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF0U3Bpbm5lcihlbGVtZW50UmVmLCBwbGF0Zm9ybSwgZG9jdW1lbnQsIGFuaW1hdGlvbk1vZGUsIGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnRSZWYsIHBsYXRmb3JtLCBkb2N1bWVudCwgYW5pbWF0aW9uTW9kZSwgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1vZGUgPSAnaW5kZXRlcm1pbmF0ZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWF0U3Bpbm5lci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYXQtc3Bpbm5lcicsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtb2RlJzogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1zcGlubmVyIG1hdC1wcm9ncmVzcy1zcGlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MuX21hdC1hbmltYXRpb24tbm9vcGFibGVdJzogXCJfbm9vcEFuaW1hdGlvbnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICdbc3R5bGUud2lkdGgucHhdJzogJ2RpYW1ldGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbc3R5bGUuaGVpZ2h0LnB4XSc6ICdkaWFtZXRlcicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydjb2xvciddLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8IS0tXFxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvIG9mIHhNaWRZTWlkIG1lZXQgYXMgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgaXMgdGhlIGNpcmNsZSdzXFxuICBjZW50ZXIuIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSB3aWxsIHJlbWFpbiBhdCB0aGUgY2VudGVyIG9mIHRoZSBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lclxcbiAgZWxlbWVudCBjb250YWluaW5nIHRoZSBTVkcuIGBmb2N1c2FibGU9XFxcImZhbHNlXFxcImAgcHJldmVudHMgSUUgZnJvbSBhbGxvd2luZyB0aGUgdXNlciB0b1xcbiAgdGFiIGludG8gdGhlIFNWRyBlbGVtZW50Llxcbi0tPlxcblxcbjxzdmdcXG4gIFtzdHlsZS53aWR0aC5weF09XFxcImRpYW1ldGVyXFxcIlxcbiAgW3N0eWxlLmhlaWdodC5weF09XFxcImRpYW1ldGVyXFxcIlxcbiAgW2F0dHIudmlld0JveF09XFxcIl92aWV3Qm94XFxcIlxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCJcXG4gIGZvY3VzYWJsZT1cXFwiZmFsc2VcXFwiXFxuICBbbmdTd2l0Y2hdPVxcXCJtb2RlID09PSAnaW5kZXRlcm1pbmF0ZSdcXFwiPlxcblxcbiAgPCEtLVxcbiAgICBUZWNobmljYWxseSB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgYGNpcmNsZWAgZWxlbWVudCwgaG93ZXZlciBTYWZhcmkgaGFzIGFuIGlzc3VlIHRoYXQgYnJlYWtzXFxuICAgIHRoZSBTVkcgcmVuZGVyaW5nIGluIGRldGVybWluYXRlIG1vZGUsIGFmdGVyIHN3aXRjaGluZyBiZXR3ZWVuIGluZGV0ZXJtaW5hdGUgYW5kIGRldGVybWluYXRlLlxcbiAgICBVc2luZyBhIGRpZmZlcmVudCBlbGVtZW50IGF2b2lkcyB0aGUgaXNzdWUuIEFuIGFsdGVybmF0aXZlIHRvIHRoaXMgaXMgYWRkaW5nIGBkaXNwbGF5OiBub25lYFxcbiAgICBmb3IgYSBzcGxpdCBzZWNvbmQgYW5kIHRoZW4gcmVtb3ZpbmcgaXQgd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBtb2RlcywgYnV0IGl0J3MgaGFyZCB0byBrbm93XFxuICAgIGZvciBob3cgbG9uZyB0byBoaWRlIHRoZSBlbGVtZW50IGFuZCBpdCBjYW4gY2F1c2UgdGhlIFVJIHRvIGJsaW5rLlxcbiAgLS0+XFxuICA8Y2lyY2xlXFxuICAgICpuZ1N3aXRjaENhc2U9XFxcInRydWVcXFwiXFxuICAgIGN4PVxcXCI1MCVcXFwiXFxuICAgIGN5PVxcXCI1MCVcXFwiXFxuICAgIFthdHRyLnJdPVxcXCJfY2lyY2xlUmFkaXVzXFxcIlxcbiAgICBbc3R5bGUuYW5pbWF0aW9uLW5hbWVdPVxcXCInbWF0LXByb2dyZXNzLXNwaW5uZXItc3Ryb2tlLXJvdGF0ZS0nICsgZGlhbWV0ZXJcXFwiXFxuICAgIFtzdHlsZS5zdHJva2UtZGFzaG9mZnNldC5weF09XFxcIl9zdHJva2VEYXNoT2Zmc2V0XFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLWRhc2hhcnJheS5weF09XFxcIl9zdHJva2VDaXJjdW1mZXJlbmNlXFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoLiVdPVxcXCJfY2lyY2xlU3Ryb2tlV2lkdGhcXFwiPjwvY2lyY2xlPlxcblxcbiAgPGNpcmNsZVxcbiAgICAqbmdTd2l0Y2hDYXNlPVxcXCJmYWxzZVxcXCJcXG4gICAgY3g9XFxcIjUwJVxcXCJcXG4gICAgY3k9XFxcIjUwJVxcXCJcXG4gICAgW2F0dHIucl09XFxcIl9jaXJjbGVSYWRpdXNcXFwiXFxuICAgIFtzdHlsZS5zdHJva2UtZGFzaG9mZnNldC5weF09XFxcIl9zdHJva2VEYXNoT2Zmc2V0XFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLWRhc2hhcnJheS5weF09XFxcIl9zdHJva2VDaXJjdW1mZXJlbmNlXFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoLiVdPVxcXCJfY2lyY2xlU3Ryb2tlV2lkdGhcXFwiPjwvY2lyY2xlPlxcbjwvc3ZnPlxcblwiLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXByb2dyZXNzLXNwaW5uZXJ7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LXByb2dyZXNzLXNwaW5uZXIgc3Zne3Bvc2l0aW9uOmFic29sdXRlO3RyYW5zZm9ybTpyb3RhdGUoLTkwZGVnKTt0b3A6MDtsZWZ0OjA7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXI7b3ZlcmZsb3c6dmlzaWJsZX0ubWF0LXByb2dyZXNzLXNwaW5uZXIgY2lyY2xle2ZpbGw6dHJhbnNwYXJlbnQ7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXI7dHJhbnNpdGlvbjpzdHJva2UtZGFzaG9mZnNldCAyMjVtcyBsaW5lYXJ9Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlLm1hdC1wcm9ncmVzcy1zcGlubmVyIGNpcmNsZXt0cmFuc2l0aW9uOm5vbmU7YW5pbWF0aW9uOm5vbmV9Lm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV17YW5pbWF0aW9uOm1hdC1wcm9ncmVzcy1zcGlubmVyLWxpbmVhci1yb3RhdGUgMjAwMG1zIGxpbmVhciBpbmZpbml0ZX0uX21hdC1hbmltYXRpb24tbm9vcGFibGUubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXXt0cmFuc2l0aW9uOm5vbmU7YW5pbWF0aW9uOm5vbmV9Lm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV0gY2lyY2xle3RyYW5zaXRpb24tcHJvcGVydHk6c3Ryb2tlO2FuaW1hdGlvbi1kdXJhdGlvbjo0MDAwbXM7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSk7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZX0uX21hdC1hbmltYXRpb24tbm9vcGFibGUubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXSBjaXJjbGV7dHJhbnNpdGlvbjpub25lO2FuaW1hdGlvbjpub25lfS5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1pbmRldGVybWluYXRlLWZhbGxiYWNrLWFuaW1hdGlvblttb2RlPWluZGV0ZXJtaW5hdGVde2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zdHJva2Utcm90YXRlLWZhbGxiYWNrIDEwMDAwbXMgY3ViaWMtYmV6aWVyKDAuODcsIDAuMDMsIDAuMzMsIDEpIGluZmluaXRlfS5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZS5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1pbmRldGVybWluYXRlLWZhbGxiYWNrLWFuaW1hdGlvblttb2RlPWluZGV0ZXJtaW5hdGVde3RyYW5zaXRpb246bm9uZTthbmltYXRpb246bm9uZX0ubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1mYWxsYmFjay1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXSBjaXJjbGV7dHJhbnNpdGlvbi1wcm9wZXJ0eTpzdHJva2V9Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlLm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtZmFsbGJhY2stYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV0gY2lyY2xle3RyYW5zaXRpb246bm9uZTthbmltYXRpb246bm9uZX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLWxpbmVhci1yb3RhdGV7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zdHJva2Utcm90YXRlLTEwMHswJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMi41JXtzdHJva2UtZGFzaG9mZnNldDo1Ni41NDg2Njc3cHg7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMi41MDAxJXtzdHJva2UtZGFzaG9mZnNldDo1Ni41NDg2Njc3cHg7dHJhbnNmb3JtOnJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoNzIuNWRlZyl9MjUle3N0cm9rZS1kYXNob2Zmc2V0OjI2OC42MDYxNzE1NzVweDt0cmFuc2Zvcm06cm90YXRlWCgxODBkZWcpIHJvdGF0ZSg3Mi41ZGVnKX0yNS4wMDAxJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpfTM3LjUle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlKDI3MGRlZyl9MzcuNTAwMSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDE2MS41ZGVnKX01MCV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDE2MS41ZGVnKX01MC4wMDAxJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfTYyLjUle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlKDE4MGRlZyl9NjIuNTAwMSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDI1MS41ZGVnKX03NSV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDI1MS41ZGVnKX03NS4wMDAxJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyl9ODcuNSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfTg3LjUwMDEle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlWCgxODBkZWcpIHJvdGF0ZSgzNDEuNWRlZyl9MTAwJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoMzQxLjVkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLXN0cm9rZS1yb3RhdGUtZmFsbGJhY2t7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0yNSV7dHJhbnNmb3JtOnJvdGF0ZSgxMTcwZGVnKX01MCV7dHJhbnNmb3JtOnJvdGF0ZSgyMzQwZGVnKX03NSV7dHJhbnNmb3JtOnJvdGF0ZSgzNTEwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoNDY4MGRlZyl9fVxcblwiXVxuICAgICAgICAgICAgICAgIH1dIH1cbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE1hdFNwaW5uZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IFBsYXRmb3JtIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0RPQ1VNRU5ULF0gfV0gfSxcbiAgICAgICAgeyB0eXBlOiBTdHJpbmcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbQU5JTUFUSU9OX01PRFVMRV9UWVBFLF0gfV0gfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW01BVF9QUk9HUkVTU19TUElOTkVSX0RFRkFVTFRfT1BUSU9OUyxdIH1dIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBNYXRTcGlubmVyO1xufShNYXRQcm9ncmVzc1NwaW5uZXIpKTtcbmV4cG9ydCB7IE1hdFNwaW5uZXIgfTtcbiJdfQ==