/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NgModule, Directive, } from '@angular/core';
import { startWith } from 'rxjs/operators';
import { MatCommonModule } from '../common-behaviors/common-module';
/**
 * Shared directive to count lines inside a text area, such as a list item.
 * Line elements can be extracted with a @ContentChildren(MatLine) query, then
 * counted by checking the query list's length.
 */
import * as ɵngcc0 from '@angular/core';
var MatLine = /** @class */ (function () {
    function MatLine() {
    }
MatLine.ɵfac = function MatLine_Factory(t) { return new (t || MatLine)(); };
MatLine.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatLine, selectors: [["", "mat-line", ""], ["", "matLine", ""]], hostAttrs: [1, "mat-line"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatLine, [{
        type: Directive,
        args: [{
                selector: '[mat-line], [matLine]',
                host: { 'class': 'mat-line' }
            }]
    }], function () { return []; }, null); })();
    return MatLine;
}());
export { MatLine };
/**
 * Helper that takes a query list of lines and sets the correct class on the host.
 * @docs-private
 */
export function setLines(lines, element, prefix) {
    if (prefix === void 0) { prefix = 'mat'; }
    // Note: doesn't need to unsubscribe, because `changes`
    // gets completed by Angular when the view is destroyed.
    lines.changes.pipe(startWith(lines)).subscribe(function (_a) {
        var length = _a.length;
        setClass(element, prefix + "-2-line", false);
        setClass(element, prefix + "-3-line", false);
        setClass(element, prefix + "-multi-line", false);
        if (length === 2 || length === 3) {
            setClass(element, prefix + "-" + length + "-line", true);
        }
        else if (length > 3) {
            setClass(element, prefix + "-multi-line", true);
        }
    });
}
/** Adds or removes a class from an element. */
function setClass(element, className, isAdd) {
    var classList = element.nativeElement.classList;
    isAdd ? classList.add(className) : classList.remove(className);
}
/**
 * Helper that takes a query list of lines and sets the correct class on the host.
 * @docs-private
 * @deprecated Use `setLines` instead.
 * @breaking-change 8.0.0
 */
var MatLineSetter = /** @class */ (function () {
    function MatLineSetter(lines, element) {
        setLines(lines, element);
    }
    return MatLineSetter;
}());
export { MatLineSetter };
var MatLineModule = /** @class */ (function () {
    function MatLineModule() {
    }
MatLineModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatLineModule });
MatLineModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MatLineModule_Factory(t) { return new (t || MatLineModule)(); }, imports: [[MatCommonModule],
        MatCommonModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatLineModule, { declarations: function () { return [MatLine]; }, imports: function () { return [MatCommonModule]; }, exports: function () { return [MatLine,
        MatCommonModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatLineModule, [{
        type: NgModule,
        args: [{
                imports: [MatCommonModule],
                exports: [MatLine, MatCommonModule],
                declarations: [MatLine]
            }]
    }], function () { return []; }, null); })();
    return MatLineModule;
}());
export { MatLineModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9AYW5ndWxhci9tYXRlcmlhbC9lc201L2NvcmUvbGluZS9saW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7O0tBRUs7Ozs7Ozs7OztnREFNQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBNkNEOzs7Ozs7Ozs7Ozs7O2dEQU9DIiwiZmlsZSI6ImxpbmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7IE5nTW9kdWxlLCBEaXJlY3RpdmUsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBzdGFydFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBNYXRDb21tb25Nb2R1bGUgfSBmcm9tICcuLi9jb21tb24tYmVoYXZpb3JzL2NvbW1vbi1tb2R1bGUnO1xuLyoqXG4gKiBTaGFyZWQgZGlyZWN0aXZlIHRvIGNvdW50IGxpbmVzIGluc2lkZSBhIHRleHQgYXJlYSwgc3VjaCBhcyBhIGxpc3QgaXRlbS5cbiAqIExpbmUgZWxlbWVudHMgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGEgQENvbnRlbnRDaGlsZHJlbihNYXRMaW5lKSBxdWVyeSwgdGhlblxuICogY291bnRlZCBieSBjaGVja2luZyB0aGUgcXVlcnkgbGlzdCdzIGxlbmd0aC5cbiAqL1xudmFyIE1hdExpbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0TGluZSgpIHtcbiAgICB9XG4gICAgTWF0TGluZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWF0LWxpbmVdLCBbbWF0TGluZV0nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtbGluZScgfVxuICAgICAgICAgICAgICAgIH0sXSB9XG4gICAgXTtcbiAgICByZXR1cm4gTWF0TGluZTtcbn0oKSk7XG5leHBvcnQgeyBNYXRMaW5lIH07XG4vKipcbiAqIEhlbHBlciB0aGF0IHRha2VzIGEgcXVlcnkgbGlzdCBvZiBsaW5lcyBhbmQgc2V0cyB0aGUgY29ycmVjdCBjbGFzcyBvbiB0aGUgaG9zdC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExpbmVzKGxpbmVzLCBlbGVtZW50LCBwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4ID09PSB2b2lkIDApIHsgcHJlZml4ID0gJ21hdCc7IH1cbiAgICAvLyBOb3RlOiBkb2Vzbid0IG5lZWQgdG8gdW5zdWJzY3JpYmUsIGJlY2F1c2UgYGNoYW5nZXNgXG4gICAgLy8gZ2V0cyBjb21wbGV0ZWQgYnkgQW5ndWxhciB3aGVuIHRoZSB2aWV3IGlzIGRlc3Ryb3llZC5cbiAgICBsaW5lcy5jaGFuZ2VzLnBpcGUoc3RhcnRXaXRoKGxpbmVzKSkuc3Vic2NyaWJlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gX2EubGVuZ3RoO1xuICAgICAgICBzZXRDbGFzcyhlbGVtZW50LCBwcmVmaXggKyBcIi0yLWxpbmVcIiwgZmFsc2UpO1xuICAgICAgICBzZXRDbGFzcyhlbGVtZW50LCBwcmVmaXggKyBcIi0zLWxpbmVcIiwgZmFsc2UpO1xuICAgICAgICBzZXRDbGFzcyhlbGVtZW50LCBwcmVmaXggKyBcIi1tdWx0aS1saW5lXCIsIGZhbHNlKTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMiB8fCBsZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHNldENsYXNzKGVsZW1lbnQsIHByZWZpeCArIFwiLVwiICsgbGVuZ3RoICsgXCItbGluZVwiLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPiAzKSB7XG4gICAgICAgICAgICBzZXRDbGFzcyhlbGVtZW50LCBwcmVmaXggKyBcIi1tdWx0aS1saW5lXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKiogQWRkcyBvciByZW1vdmVzIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50LiAqL1xuZnVuY3Rpb24gc2V0Q2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBpc0FkZCkge1xuICAgIHZhciBjbGFzc0xpc3QgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0O1xuICAgIGlzQWRkID8gY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpIDogY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdGhhdCB0YWtlcyBhIHF1ZXJ5IGxpc3Qgb2YgbGluZXMgYW5kIHNldHMgdGhlIGNvcnJlY3QgY2xhc3Mgb24gdGhlIGhvc3QuXG4gKiBAZG9jcy1wcml2YXRlXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHNldExpbmVzYCBpbnN0ZWFkLlxuICogQGJyZWFraW5nLWNoYW5nZSA4LjAuMFxuICovXG52YXIgTWF0TGluZVNldHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRMaW5lU2V0dGVyKGxpbmVzLCBlbGVtZW50KSB7XG4gICAgICAgIHNldExpbmVzKGxpbmVzLCBlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdExpbmVTZXR0ZXI7XG59KCkpO1xuZXhwb3J0IHsgTWF0TGluZVNldHRlciB9O1xudmFyIE1hdExpbmVNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0TGluZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWF0TGluZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWF0Q29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW01hdExpbmUsIE1hdENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01hdExpbmVdLFxuICAgICAgICAgICAgICAgIH0sXSB9XG4gICAgXTtcbiAgICByZXR1cm4gTWF0TGluZU1vZHVsZTtcbn0oKSk7XG5leHBvcnQgeyBNYXRMaW5lTW9kdWxlIH07XG4iXX0=