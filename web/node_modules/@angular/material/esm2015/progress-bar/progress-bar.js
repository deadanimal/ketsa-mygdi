/**
 * @fileoverview added by tsickle
 * Generated from: src/material/progress-bar/progress-bar.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { DOCUMENT } from '@angular/common';
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Inject, inject, InjectionToken, Input, NgZone, Optional, Output, ViewChild, ViewEncapsulation, } from '@angular/core';
import { mixinColor } from '@angular/material/core';
import { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';
import { fromEvent, Subscription } from 'rxjs';
import { filter } from 'rxjs/operators';
/**
 * Last animation end data.
 * @record
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["primaryValueBar"];
export function ProgressAnimationEnd() { }
if (false) {
    /** @type {?} */
    ProgressAnimationEnd.prototype.value;
}
// Boilerplate for applying mixins to MatProgressBar.
/**
 * \@docs-private
 */
class MatProgressBarBase {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}
if (false) {
    /** @type {?} */
    MatProgressBarBase.prototype._elementRef;
}
/** @type {?} */
const _MatProgressBarMixinBase = mixinColor(MatProgressBarBase, 'primary');
/**
 * Injection token used to provide the current location to `MatProgressBar`.
 * Used to handle server-side rendering and to stub out during unit tests.
 * \@docs-private
 * @type {?}
 */
export const MAT_PROGRESS_BAR_LOCATION = new InjectionToken('mat-progress-bar-location', { providedIn: 'root', factory: MAT_PROGRESS_BAR_LOCATION_FACTORY });
/**
 * Stubbed out location for `MatProgressBar`.
 * \@docs-private
 * @record
 */
export function MatProgressBarLocation() { }
if (false) {
    /** @type {?} */
    MatProgressBarLocation.prototype.getPathname;
}
/**
 * \@docs-private
 * @return {?}
 */
export function MAT_PROGRESS_BAR_LOCATION_FACTORY() {
    /** @type {?} */
    const _document = inject(DOCUMENT);
    /** @type {?} */
    const _location = _document ? _document.location : null;
    return {
        // Note that this needs to be a function, rather than a property, because Angular
        // will only resolve it once, but we want the current path on each call.
        getPathname: (/**
         * @return {?}
         */
        () => _location ? (_location.pathname + _location.search) : '')
    };
}
/**
 * Counter used to generate unique IDs for progress bars.
 * @type {?}
 */
let progressbarId = 0;
/**
 * `<mat-progress-bar>` component.
 */
export class MatProgressBar extends _MatProgressBarMixinBase {
    /**
     * @param {?} _elementRef
     * @param {?} _ngZone
     * @param {?=} _animationMode
     * @param {?=} location
     */
    constructor(_elementRef, _ngZone, _animationMode, 
    /**
     * @deprecated `location` parameter to be made required.
     * @breaking-change 8.0.0
     */
    location) {
        super(_elementRef);
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this._animationMode = _animationMode;
        /**
         * Flag that indicates whether NoopAnimations mode is set to true.
         */
        this._isNoopAnimation = false;
        this._value = 0;
        this._bufferValue = 0;
        /**
         * Event emitted when animation of the primary progress bar completes. This event will not
         * be emitted when animations are disabled, nor will it be emitted for modes with continuous
         * animations (indeterminate and query).
         */
        this.animationEnd = new EventEmitter();
        /**
         * Reference to animation end subscription to be unsubscribed on destroy.
         */
        this._animationEndSubscription = Subscription.EMPTY;
        /**
         * Mode of the progress bar.
         *
         * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to
         * 'determinate'.
         * Mirrored to mode attribute.
         */
        this.mode = 'determinate';
        /**
         * ID of the progress bar.
         */
        this.progressbarId = `mat-progress-bar-${progressbarId++}`;
        // We need to prefix the SVG reference with the current path, otherwise they won't work
        // in Safari if the page has a `<base>` tag. Note that we need quotes inside the `url()`,
        // because named route URLs can contain parentheses (see #12338). Also we don't use since
        // we can't tell the difference between whether
        // the consumer is using the hash location strategy or not, because `Location` normalizes
        // both `/#/foo/bar` and `/foo/bar` to the same thing.
        /** @type {?} */
        const path = location ? location.getPathname().split('#')[0] : '';
        this._rectangleFillValue = `url('${path}#${this.progressbarId}')`;
        this._isNoopAnimation = _animationMode === 'NoopAnimations';
    }
    /**
     * Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow.
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        this._value = clamp(coerceNumberProperty(v) || 0);
    }
    /**
     * Buffer value of the progress bar. Defaults to zero.
     * @return {?}
     */
    get bufferValue() { return this._bufferValue; }
    /**
     * @param {?} v
     * @return {?}
     */
    set bufferValue(v) { this._bufferValue = clamp(v || 0); }
    /**
     * Gets the current transform value for the progress bar's primary indicator.
     * @return {?}
     */
    _primaryTransform() {
        /** @type {?} */
        const scale = this.value / 100;
        return { transform: `scaleX(${scale})` };
    }
    /**
     * Gets the current transform value for the progress bar's buffer indicator. Only used if the
     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.
     * @return {?}
     */
    _bufferTransform() {
        if (this.mode === 'buffer') {
            /** @type {?} */
            const scale = this.bufferValue / 100;
            return { transform: `scaleX(${scale})` };
        }
        return null;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Run outside angular so change detection didn't get triggered on every transition end
        // instead only on the animation that we care about (primary value bar's transitionend)
        this._ngZone.runOutsideAngular(((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const element = this._primaryValueBar.nativeElement;
            this._animationEndSubscription =
                ((/** @type {?} */ (fromEvent(element, 'transitionend'))))
                    .pipe(filter(((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => e.target === element))))
                    .subscribe((/**
                 * @return {?}
                 */
                () => {
                    if (this.mode === 'determinate' || this.mode === 'buffer') {
                        this._ngZone.run((/**
                         * @return {?}
                         */
                        () => this.animationEnd.next({ value: this.value })));
                    }
                }));
        })));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._animationEndSubscription.unsubscribe();
    }
}
MatProgressBar.ɵfac = function MatProgressBar_Factory(t) { return new (t || MatProgressBar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), ɵngcc0.ɵɵdirectiveInject(MAT_PROGRESS_BAR_LOCATION, 8)); };
MatProgressBar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatProgressBar, selectors: [["mat-progress-bar"]], viewQuery: function MatProgressBar_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._primaryValueBar = _t.first);
    } }, hostAttrs: ["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", 1, "mat-progress-bar"], hostVars: 4, hostBindings: function MatProgressBar_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuenow", ctx.mode === "indeterminate" || ctx.mode === "query" ? null : ctx.value)("mode", ctx.mode);
        ɵngcc0.ɵɵclassProp("_mat-animation-noopable", ctx._isNoopAnimation);
    } }, inputs: { color: "color", mode: "mode", value: "value", bufferValue: "bufferValue" }, outputs: { animationEnd: "animationEnd" }, exportAs: ["matProgressBar"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 9, vars: 4, consts: [["width", "100%", "height", "4", "focusable", "false", 1, "mat-progress-bar-background", "mat-progress-bar-element"], ["x", "4", "y", "0", "width", "8", "height", "4", "patternUnits", "userSpaceOnUse", 3, "id"], ["cx", "2", "cy", "2", "r", "2"], ["width", "100%", "height", "100%"], [1, "mat-progress-bar-buffer", "mat-progress-bar-element", 3, "ngStyle"], [1, "mat-progress-bar-primary", "mat-progress-bar-fill", "mat-progress-bar-element", 3, "ngStyle"], ["primaryValueBar", ""], [1, "mat-progress-bar-secondary", "mat-progress-bar-fill", "mat-progress-bar-element"]], template: function MatProgressBar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "svg", 0);
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "pattern", 1);
        ɵngcc0.ɵɵelement(3, "circle", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "rect", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(5, "div", 4);
        ɵngcc0.ɵɵelement(6, "div", 5, 6);
        ɵngcc0.ɵɵelement(8, "div", 7);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.progressbarId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("fill", ctx._rectangleFillValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._bufferTransform());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._primaryTransform());
    } }, directives: [ɵngcc1.NgStyle], styles: [".mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-background{display:none}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:\"\";display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2000ms infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2000ms infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background{animation:none;transition-duration:1ms}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\n"], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
MatProgressBar.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_PROGRESS_BAR_LOCATION,] }] }
];
MatProgressBar.propDecorators = {
    value: [{ type: Input }],
    bufferValue: [{ type: Input }],
    _primaryValueBar: [{ type: ViewChild, args: ['primaryValueBar',] }],
    animationEnd: [{ type: Output }],
    mode: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatProgressBar, [{
        type: Component,
        args: [{
                selector: 'mat-progress-bar',
                exportAs: 'matProgressBar',
                host: {
                    'role': 'progressbar',
                    'aria-valuemin': '0',
                    'aria-valuemax': '100',
                    '[attr.aria-valuenow]': '(mode === "indeterminate" || mode === "query") ? null : value',
                    '[attr.mode]': 'mode',
                    'class': 'mat-progress-bar',
                    '[class._mat-animation-noopable]': '_isNoopAnimation'
                },
                inputs: ['color'],
                template: "<!--\n  The background div is named as such because it appears below the other divs and is not sized based\n  on values.\n-->\n<svg width=\"100%\" height=\"4\" focusable=\"false\" class=\"mat-progress-bar-background mat-progress-bar-element\">\n  <defs>\n    <pattern [id]=\"progressbarId\" x=\"4\" y=\"0\" width=\"8\" height=\"4\" patternUnits=\"userSpaceOnUse\">\n      <circle cx=\"2\" cy=\"2\" r=\"2\"/>\n    </pattern>\n  </defs>\n  <rect [attr.fill]=\"_rectangleFillValue\" width=\"100%\" height=\"100%\"/>\n</svg>\n<div class=\"mat-progress-bar-buffer mat-progress-bar-element\" [ngStyle]=\"_bufferTransform()\"></div>\n<div class=\"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\" [ngStyle]=\"_primaryTransform()\" #primaryValueBar></div>\n<div class=\"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\"></div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-background{display:none}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:\"\";display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2000ms infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2000ms infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background{animation:none;transition-duration:1ms}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MAT_PROGRESS_BAR_LOCATION]
            }] }]; }, { animationEnd: [{
            type: Output
        }], mode: [{
            type: Input
        }], value: [{
            type: Input
        }], bufferValue: [{
            type: Input
        }], _primaryValueBar: [{
            type: ViewChild,
            args: ['primaryValueBar']
        }] }); })();
if (false) {
    /** @type {?} */
    MatProgressBar.ngAcceptInputType_value;
    /**
     * Flag that indicates whether NoopAnimations mode is set to true.
     * @type {?}
     */
    MatProgressBar.prototype._isNoopAnimation;
    /**
     * @type {?}
     * @private
     */
    MatProgressBar.prototype._value;
    /**
     * @type {?}
     * @private
     */
    MatProgressBar.prototype._bufferValue;
    /** @type {?} */
    MatProgressBar.prototype._primaryValueBar;
    /**
     * Event emitted when animation of the primary progress bar completes. This event will not
     * be emitted when animations are disabled, nor will it be emitted for modes with continuous
     * animations (indeterminate and query).
     * @type {?}
     */
    MatProgressBar.prototype.animationEnd;
    /**
     * Reference to animation end subscription to be unsubscribed on destroy.
     * @type {?}
     * @private
     */
    MatProgressBar.prototype._animationEndSubscription;
    /**
     * Mode of the progress bar.
     *
     * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to
     * 'determinate'.
     * Mirrored to mode attribute.
     * @type {?}
     */
    MatProgressBar.prototype.mode;
    /**
     * ID of the progress bar.
     * @type {?}
     */
    MatProgressBar.prototype.progressbarId;
    /**
     * Attribute to be used for the `fill` attribute on the internal `rect` element.
     * @type {?}
     */
    MatProgressBar.prototype._rectangleFillValue;
    /** @type {?} */
    MatProgressBar.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MatProgressBar.prototype._ngZone;
    /** @type {?} */
    MatProgressBar.prototype._animationMode;
}
/**
 * Clamps a value to be between two numbers, by default 0 and 100.
 * @param {?} v
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
function clamp(v, min = 0, max = 100) {
    return Math.max(min, Math.min(max, v));
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9AYW5ndWxhci9tYXRlcmlhbC9lc20yMDE1L3Byb2dyZXNzLWJhci9wcm9ncmVzcy1iYXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNE1DLDRnS0FvQkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQWNBIiwiZmlsZSI6InByb2dyZXNzLWJhci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBHZW5lcmF0ZWQgZnJvbTogc3JjL21hdGVyaWFsL3Byb2dyZXNzLWJhci9wcm9ncmVzcy1iYXIudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBjb2VyY2VOdW1iZXJQcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEluamVjdCwgaW5qZWN0LCBJbmplY3Rpb25Ub2tlbiwgSW5wdXQsIE5nWm9uZSwgT3B0aW9uYWwsIE91dHB1dCwgVmlld0NoaWxkLCBWaWV3RW5jYXBzdWxhdGlvbiwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG1peGluQ29sb3IgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcbmltcG9ydCB7IEFOSU1BVElPTl9NT0RVTEVfVFlQRSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuLyoqXG4gKiBMYXN0IGFuaW1hdGlvbiBlbmQgZGF0YS5cbiAqIEByZWNvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFByb2dyZXNzQW5pbWF0aW9uRW5kKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUHJvZ3Jlc3NBbmltYXRpb25FbmQucHJvdG90eXBlLnZhbHVlO1xufVxuLy8gQm9pbGVycGxhdGUgZm9yIGFwcGx5aW5nIG1peGlucyB0byBNYXRQcm9ncmVzc0Jhci5cbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbmNsYXNzIE1hdFByb2dyZXNzQmFyQmFzZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG59XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTWF0UHJvZ3Jlc3NCYXJCYXNlLnByb3RvdHlwZS5fZWxlbWVudFJlZjtcbn1cbi8qKiBAdHlwZSB7P30gKi9cbmNvbnN0IF9NYXRQcm9ncmVzc0Jhck1peGluQmFzZSA9IG1peGluQ29sb3IoTWF0UHJvZ3Jlc3NCYXJCYXNlLCAncHJpbWFyeScpO1xuLyoqXG4gKiBJbmplY3Rpb24gdG9rZW4gdXNlZCB0byBwcm92aWRlIHRoZSBjdXJyZW50IGxvY2F0aW9uIHRvIGBNYXRQcm9ncmVzc0JhcmAuXG4gKiBVc2VkIHRvIGhhbmRsZSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgYW5kIHRvIHN0dWIgb3V0IGR1cmluZyB1bml0IHRlc3RzLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAdHlwZSB7P31cbiAqL1xuZXhwb3J0IGNvbnN0IE1BVF9QUk9HUkVTU19CQVJfTE9DQVRJT04gPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ21hdC1wcm9ncmVzcy1iYXItbG9jYXRpb24nLCB7IHByb3ZpZGVkSW46ICdyb290JywgZmFjdG9yeTogTUFUX1BST0dSRVNTX0JBUl9MT0NBVElPTl9GQUNUT1JZIH0pO1xuLyoqXG4gKiBTdHViYmVkIG91dCBsb2NhdGlvbiBmb3IgYE1hdFByb2dyZXNzQmFyYC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJlY29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gTWF0UHJvZ3Jlc3NCYXJMb2NhdGlvbigpIHsgfVxuaWYgKGZhbHNlKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1hdFByb2dyZXNzQmFyTG9jYXRpb24ucHJvdG90eXBlLmdldFBhdGhuYW1lO1xufVxuLyoqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNQVRfUFJPR1JFU1NfQkFSX0xPQ0FUSU9OX0ZBQ1RPUlkoKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIGNvbnN0IF9kb2N1bWVudCA9IGluamVjdChET0NVTUVOVCk7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIGNvbnN0IF9sb2NhdGlvbiA9IF9kb2N1bWVudCA/IF9kb2N1bWVudC5sb2NhdGlvbiA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbmVlZHMgdG8gYmUgYSBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBwcm9wZXJ0eSwgYmVjYXVzZSBBbmd1bGFyXG4gICAgICAgIC8vIHdpbGwgb25seSByZXNvbHZlIGl0IG9uY2UsIGJ1dCB3ZSB3YW50IHRoZSBjdXJyZW50IHBhdGggb24gZWFjaCBjYWxsLlxuICAgICAgICBnZXRQYXRobmFtZTogKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgKCkgPT4gX2xvY2F0aW9uID8gKF9sb2NhdGlvbi5wYXRobmFtZSArIF9sb2NhdGlvbi5zZWFyY2gpIDogJycpXG4gICAgfTtcbn1cbi8qKlxuICogQ291bnRlciB1c2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMgZm9yIHByb2dyZXNzIGJhcnMuXG4gKiBAdHlwZSB7P31cbiAqL1xubGV0IHByb2dyZXNzYmFySWQgPSAwO1xuLyoqXG4gKiBgPG1hdC1wcm9ncmVzcy1iYXI+YCBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRQcm9ncmVzc0JhciBleHRlbmRzIF9NYXRQcm9ncmVzc0Jhck1peGluQmFzZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqIEBwYXJhbSB7Pz19IF9hbmltYXRpb25Nb2RlXG4gICAgICogQHBhcmFtIHs/PX0gbG9jYXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudFJlZiwgX25nWm9uZSwgX2FuaW1hdGlvbk1vZGUsIFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIGBsb2NhdGlvbmAgcGFyYW1ldGVyIHRvIGJlIG1hZGUgcmVxdWlyZWQuXG4gICAgICogQGJyZWFraW5nLWNoYW5nZSA4LjAuMFxuICAgICAqL1xuICAgIGxvY2F0aW9uKSB7XG4gICAgICAgIHN1cGVyKF9lbGVtZW50UmVmKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9hbmltYXRpb25Nb2RlID0gX2FuaW1hdGlvbk1vZGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgTm9vcEFuaW1hdGlvbnMgbW9kZSBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzTm9vcEFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuX2J1ZmZlclZhbHVlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBhbmltYXRpb24gb2YgdGhlIHByaW1hcnkgcHJvZ3Jlc3MgYmFyIGNvbXBsZXRlcy4gVGhpcyBldmVudCB3aWxsIG5vdFxuICAgICAgICAgKiBiZSBlbWl0dGVkIHdoZW4gYW5pbWF0aW9ucyBhcmUgZGlzYWJsZWQsIG5vciB3aWxsIGl0IGJlIGVtaXR0ZWQgZm9yIG1vZGVzIHdpdGggY29udGludW91c1xuICAgICAgICAgKiBhbmltYXRpb25zIChpbmRldGVybWluYXRlIGFuZCBxdWVyeSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBhbmltYXRpb24gZW5kIHN1YnNjcmlwdGlvbiB0byBiZSB1bnN1YnNjcmliZWQgb24gZGVzdHJveS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkVuZFN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGUgb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICAgICAgICpcbiAgICAgICAgICogSW5wdXQgbXVzdCBiZSBvbmUgb2YgdGhlc2UgdmFsdWVzOiBkZXRlcm1pbmF0ZSwgaW5kZXRlcm1pbmF0ZSwgYnVmZmVyLCBxdWVyeSwgZGVmYXVsdHMgdG9cbiAgICAgICAgICogJ2RldGVybWluYXRlJy5cbiAgICAgICAgICogTWlycm9yZWQgdG8gbW9kZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGUgPSAnZGV0ZXJtaW5hdGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogSUQgb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NiYXJJZCA9IGBtYXQtcHJvZ3Jlc3MtYmFyLSR7cHJvZ3Jlc3NiYXJJZCsrfWA7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcHJlZml4IHRoZSBTVkcgcmVmZXJlbmNlIHdpdGggdGhlIGN1cnJlbnQgcGF0aCwgb3RoZXJ3aXNlIHRoZXkgd29uJ3Qgd29ya1xuICAgICAgICAvLyBpbiBTYWZhcmkgaWYgdGhlIHBhZ2UgaGFzIGEgYDxiYXNlPmAgdGFnLiBOb3RlIHRoYXQgd2UgbmVlZCBxdW90ZXMgaW5zaWRlIHRoZSBgdXJsKClgLFxuICAgICAgICAvLyBiZWNhdXNlIG5hbWVkIHJvdXRlIFVSTHMgY2FuIGNvbnRhaW4gcGFyZW50aGVzZXMgKHNlZSAjMTIzMzgpLiBBbHNvIHdlIGRvbid0IHVzZSBzaW5jZVxuICAgICAgICAvLyB3ZSBjYW4ndCB0ZWxsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gd2hldGhlclxuICAgICAgICAvLyB0aGUgY29uc3VtZXIgaXMgdXNpbmcgdGhlIGhhc2ggbG9jYXRpb24gc3RyYXRlZ3kgb3Igbm90LCBiZWNhdXNlIGBMb2NhdGlvbmAgbm9ybWFsaXplc1xuICAgICAgICAvLyBib3RoIGAvIy9mb28vYmFyYCBhbmQgYC9mb28vYmFyYCB0byB0aGUgc2FtZSB0aGluZy5cbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBwYXRoID0gbG9jYXRpb24gPyBsb2NhdGlvbi5nZXRQYXRobmFtZSgpLnNwbGl0KCcjJylbMF0gOiAnJztcbiAgICAgICAgdGhpcy5fcmVjdGFuZ2xlRmlsbFZhbHVlID0gYHVybCgnJHtwYXRofSMke3RoaXMucHJvZ3Jlc3NiYXJJZH0nKWA7XG4gICAgICAgIHRoaXMuX2lzTm9vcEFuaW1hdGlvbiA9IF9hbmltYXRpb25Nb2RlID09PSAnTm9vcEFuaW1hdGlvbnMnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiBEZWZhdWx0cyB0byB6ZXJvLiBNaXJyb3JlZCB0byBhcmlhLXZhbHVlbm93LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gY2xhbXAoY29lcmNlTnVtYmVyUHJvcGVydHkodikgfHwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1ZmZlciB2YWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiBEZWZhdWx0cyB0byB6ZXJvLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IGJ1ZmZlclZhbHVlKCkgeyByZXR1cm4gdGhpcy5fYnVmZmVyVmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldCBidWZmZXJWYWx1ZSh2KSB7IHRoaXMuX2J1ZmZlclZhbHVlID0gY2xhbXAodiB8fCAwKTsgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtIHZhbHVlIGZvciB0aGUgcHJvZ3Jlc3MgYmFyJ3MgcHJpbWFyeSBpbmRpY2F0b3IuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfcHJpbWFyeVRyYW5zZm9ybSgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMudmFsdWUgLyAxMDA7XG4gICAgICAgIHJldHVybiB7IHRyYW5zZm9ybTogYHNjYWxlWCgke3NjYWxlfSlgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtIHZhbHVlIGZvciB0aGUgcHJvZ3Jlc3MgYmFyJ3MgYnVmZmVyIGluZGljYXRvci4gT25seSB1c2VkIGlmIHRoZVxuICAgICAqIHByb2dyZXNzIG1vZGUgaXMgc2V0IHRvIGJ1ZmZlciwgb3RoZXJ3aXNlIHJldHVybnMgYW4gdW5kZWZpbmVkLCBjYXVzaW5nIG5vIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2J1ZmZlclRyYW5zZm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5idWZmZXJWYWx1ZSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiB7IHRyYW5zZm9ybTogYHNjYWxlWCgke3NjYWxlfSlgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICAvLyBSdW4gb3V0c2lkZSBhbmd1bGFyIHNvIGNoYW5nZSBkZXRlY3Rpb24gZGlkbid0IGdldCB0cmlnZ2VyZWQgb24gZXZlcnkgdHJhbnNpdGlvbiBlbmRcbiAgICAgICAgLy8gaW5zdGVhZCBvbmx5IG9uIHRoZSBhbmltYXRpb24gdGhhdCB3ZSBjYXJlIGFib3V0IChwcmltYXJ5IHZhbHVlIGJhcidzIHRyYW5zaXRpb25lbmQpXG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3ByaW1hcnlWYWx1ZUJhci5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uRW5kU3Vic2NyaXB0aW9uID1cbiAgICAgICAgICAgICAgICAoKC8qKiBAdHlwZSB7P30gKi8gKGZyb21FdmVudChlbGVtZW50LCAndHJhbnNpdGlvbmVuZCcpKSkpXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKC8qKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgKGUpID0+IGUudGFyZ2V0ID09PSBlbGVtZW50KSkpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgvKipcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2RldGVybWluYXRlJyB8fCB0aGlzLm1vZGUgPT09ICdidWZmZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHRoaXMuYW5pbWF0aW9uRW5kLm5leHQoeyB2YWx1ZTogdGhpcy52YWx1ZSB9KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9hbmltYXRpb25FbmRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG5NYXRQcm9ncmVzc0Jhci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWF0LXByb2dyZXNzLWJhcicsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtYXRQcm9ncmVzc0JhcicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdwcm9ncmVzc2JhcicsXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLXZhbHVlbWluJzogJzAnLFxuICAgICAgICAgICAgICAgICAgICAnYXJpYS12YWx1ZW1heCc6ICcxMDAnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS12YWx1ZW5vd10nOiAnKG1vZGUgPT09IFwiaW5kZXRlcm1pbmF0ZVwiIHx8IG1vZGUgPT09IFwicXVlcnlcIikgPyBudWxsIDogdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIubW9kZV0nOiAnbW9kZScsXG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtcHJvZ3Jlc3MtYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZV0nOiAnX2lzTm9vcEFuaW1hdGlvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sb3InXSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8IS0tXFxuICBUaGUgYmFja2dyb3VuZCBkaXYgaXMgbmFtZWQgYXMgc3VjaCBiZWNhdXNlIGl0IGFwcGVhcnMgYmVsb3cgdGhlIG90aGVyIGRpdnMgYW5kIGlzIG5vdCBzaXplZCBiYXNlZFxcbiAgb24gdmFsdWVzLlxcbi0tPlxcbjxzdmcgd2lkdGg9XFxcIjEwMCVcXFwiIGhlaWdodD1cXFwiNFxcXCIgZm9jdXNhYmxlPVxcXCJmYWxzZVxcXCIgY2xhc3M9XFxcIm1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZCBtYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnRcXFwiPlxcbiAgPGRlZnM+XFxuICAgIDxwYXR0ZXJuIFtpZF09XFxcInByb2dyZXNzYmFySWRcXFwiIHg9XFxcIjRcXFwiIHk9XFxcIjBcXFwiIHdpZHRoPVxcXCI4XFxcIiBoZWlnaHQ9XFxcIjRcXFwiIHBhdHRlcm5Vbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiPlxcbiAgICAgIDxjaXJjbGUgY3g9XFxcIjJcXFwiIGN5PVxcXCIyXFxcIiByPVxcXCIyXFxcIi8+XFxuICAgIDwvcGF0dGVybj5cXG4gIDwvZGVmcz5cXG4gIDxyZWN0IFthdHRyLmZpbGxdPVxcXCJfcmVjdGFuZ2xlRmlsbFZhbHVlXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCIgaGVpZ2h0PVxcXCIxMDAlXFxcIi8+XFxuPC9zdmc+XFxuPGRpdiBjbGFzcz1cXFwibWF0LXByb2dyZXNzLWJhci1idWZmZXIgbWF0LXByb2dyZXNzLWJhci1lbGVtZW50XFxcIiBbbmdTdHlsZV09XFxcIl9idWZmZXJUcmFuc2Zvcm0oKVxcXCI+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwibWF0LXByb2dyZXNzLWJhci1wcmltYXJ5IG1hdC1wcm9ncmVzcy1iYXItZmlsbCBtYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnRcXFwiIFtuZ1N0eWxlXT1cXFwiX3ByaW1hcnlUcmFuc2Zvcm0oKVxcXCIgI3ByaW1hcnlWYWx1ZUJhcj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJtYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeSBtYXQtcHJvZ3Jlc3MtYmFyLWZpbGwgbWF0LXByb2dyZXNzLWJhci1lbGVtZW50XFxcIj48L2Rpdj5cXG5cIixcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1wcm9ncmVzcy1iYXJ7ZGlzcGxheTpibG9jaztoZWlnaHQ6NHB4O292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uOm9wYWNpdHkgMjUwbXMgbGluZWFyO3dpZHRoOjEwMCV9Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlLm1hdC1wcm9ncmVzcy1iYXJ7dHJhbnNpdGlvbjpub25lO2FuaW1hdGlvbjpub25lfS5tYXQtcHJvZ3Jlc3MtYmFyIC5tYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnQsLm1hdC1wcm9ncmVzcy1iYXIgLm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXJ7aGVpZ2h0OjEwMCU7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJX0ubWF0LXByb2dyZXNzLWJhciAubWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5ke3dpZHRoOmNhbGMoMTAwJSArIDEwcHgpfS5jZGstaGlnaC1jb250cmFzdC1hY3RpdmUgLm1hdC1wcm9ncmVzcy1iYXIgLm1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZHtkaXNwbGF5Om5vbmV9Lm1hdC1wcm9ncmVzcy1iYXIgLm1hdC1wcm9ncmVzcy1iYXItYnVmZmVye3RyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMjUwbXMgZWFzZX0uY2RrLWhpZ2gtY29udHJhc3QtYWN0aXZlIC5tYXQtcHJvZ3Jlc3MtYmFyIC5tYXQtcHJvZ3Jlc3MtYmFyLWJ1ZmZlcntib3JkZXItdG9wOnNvbGlkIDVweDtvcGFjaXR5Oi41fS5tYXQtcHJvZ3Jlc3MtYmFyIC5tYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeXtkaXNwbGF5Om5vbmV9Lm1hdC1wcm9ncmVzcy1iYXIgLm1hdC1wcm9ncmVzcy1iYXItZmlsbHthbmltYXRpb246bm9uZTt0cmFuc2Zvcm0tb3JpZ2luOnRvcCBsZWZ0O3RyYW5zaXRpb246dHJhbnNmb3JtIDI1MG1zIGVhc2V9LmNkay1oaWdoLWNvbnRyYXN0LWFjdGl2ZSAubWF0LXByb2dyZXNzLWJhciAubWF0LXByb2dyZXNzLWJhci1maWxse2JvcmRlci10b3A6c29saWQgNHB4fS5tYXQtcHJvZ3Jlc3MtYmFyIC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVye2FuaW1hdGlvbjpub25lO2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGVmdDowfS5tYXQtcHJvZ3Jlc3MtYmFyW2Rpcj1ydGxdLFtkaXI9cnRsXSAubWF0LXByb2dyZXNzLWJhcnt0cmFuc2Zvcm06cm90YXRlWSgxODBkZWcpfS5tYXQtcHJvZ3Jlc3MtYmFyW21vZGU9cXVlcnlde3RyYW5zZm9ybTpyb3RhdGVaKDE4MGRlZyl9Lm1hdC1wcm9ncmVzcy1iYXJbbW9kZT1xdWVyeV1bZGlyPXJ0bF0sW2Rpcj1ydGxdIC5tYXQtcHJvZ3Jlc3MtYmFyW21vZGU9cXVlcnlde3RyYW5zZm9ybTpyb3RhdGVaKDE4MGRlZykgcm90YXRlWSgxODBkZWcpfS5tYXQtcHJvZ3Jlc3MtYmFyW21vZGU9aW5kZXRlcm1pbmF0ZV0gLm1hdC1wcm9ncmVzcy1iYXItZmlsbCwubWF0LXByb2dyZXNzLWJhclttb2RlPXF1ZXJ5XSAubWF0LXByb2dyZXNzLWJhci1maWxse3RyYW5zaXRpb246bm9uZX0ubWF0LXByb2dyZXNzLWJhclttb2RlPWluZGV0ZXJtaW5hdGVdIC5tYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnksLm1hdC1wcm9ncmVzcy1iYXJbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeXstd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO2JhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGUgMjAwMG1zIGluZmluaXRlIGxpbmVhcjtsZWZ0Oi0xNDUuMTY2NjExJX0ubWF0LXByb2dyZXNzLWJhclttb2RlPWluZGV0ZXJtaW5hdGVdIC5tYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnkubWF0LXByb2dyZXNzLWJhci1maWxsOjphZnRlciwubWF0LXByb2dyZXNzLWJhclttb2RlPXF1ZXJ5XSAubWF0LXByb2dyZXNzLWJhci1wcmltYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXJ7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjtiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjthbmltYXRpb246bWF0LXByb2dyZXNzLWJhci1wcmltYXJ5LWluZGV0ZXJtaW5hdGUtc2NhbGUgMjAwMG1zIGluZmluaXRlIGxpbmVhcn0ubWF0LXByb2dyZXNzLWJhclttb2RlPWluZGV0ZXJtaW5hdGVdIC5tYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeSwubWF0LXByb2dyZXNzLWJhclttb2RlPXF1ZXJ5XSAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnl7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjtiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjthbmltYXRpb246bWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGUgMjAwMG1zIGluZmluaXRlIGxpbmVhcjtsZWZ0Oi01NC44ODg4OTElO2Rpc3BsYXk6YmxvY2t9Lm1hdC1wcm9ncmVzcy1iYXJbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnkubWF0LXByb2dyZXNzLWJhci1maWxsOjphZnRlciwubWF0LXByb2dyZXNzLWJhclttb2RlPXF1ZXJ5XSAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnkubWF0LXByb2dyZXNzLWJhci1maWxsOjphZnRlcnstd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO2JhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeS1pbmRldGVybWluYXRlLXNjYWxlIDIwMDBtcyBpbmZpbml0ZSBsaW5lYXJ9Lm1hdC1wcm9ncmVzcy1iYXJbbW9kZT1idWZmZXJdIC5tYXQtcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmR7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjtiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjthbmltYXRpb246bWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5kLXNjcm9sbCAyNTBtcyBpbmZpbml0ZSBsaW5lYXI7ZGlzcGxheTpibG9ja30ubWF0LXByb2dyZXNzLWJhci5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZSAubWF0LXByb2dyZXNzLWJhci1maWxsLC5tYXQtcHJvZ3Jlc3MtYmFyLl9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlIC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVyLC5tYXQtcHJvZ3Jlc3MtYmFyLl9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlIC5tYXQtcHJvZ3Jlc3MtYmFyLWJ1ZmZlciwubWF0LXByb2dyZXNzLWJhci5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZSAubWF0LXByb2dyZXNzLWJhci1wcmltYXJ5LC5tYXQtcHJvZ3Jlc3MtYmFyLl9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlIC5tYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnkubWF0LXByb2dyZXNzLWJhci1maWxsOjphZnRlciwubWF0LXByb2dyZXNzLWJhci5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZSAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnksLm1hdC1wcm9ncmVzcy1iYXIuX21hdC1hbmltYXRpb24tbm9vcGFibGUgLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXIsLm1hdC1wcm9ncmVzcy1iYXIuX21hdC1hbmltYXRpb24tbm9vcGFibGUgLm1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZHthbmltYXRpb246bm9uZTt0cmFuc2l0aW9uLWR1cmF0aW9uOjFtc31Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeS1pbmRldGVybWluYXRlLXRyYW5zbGF0ZXswJXt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKX0yMCV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC41LCAwLCAwLjcwMTczMiwgMC40OTU4MTkpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApfTU5LjE1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjMwMjQzNSwgMC4zODEzNTIsIDAuNTUsIDAuOTU2MzUyKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCg4My42NzE0MiUpfTEwMCV7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMjAwLjYxMTA1NyUpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeS1pbmRldGVybWluYXRlLXNjYWxlezAle3RyYW5zZm9ybTpzY2FsZVgoMC4wOCl9MzYuNjUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuMzM0NzMxLCAwLjEyNDgyLCAwLjc4NTg0NCwgMSk7dHJhbnNmb3JtOnNjYWxlWCgwLjA4KX02OS4xNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4wNiwgMC4xMSwgMC42LCAxKTt0cmFuc2Zvcm06c2NhbGVYKDAuNjYxNDc5KX0xMDAle3RyYW5zZm9ybTpzY2FsZVgoMC4wOCl9fUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGV7MCV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4xNSwgMCwgMC41MTUwNTgsIDAuNDA5Njg1KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKX0yNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4zMTAzMywgMC4yODQwNTgsIDAuOCwgMC43MzM3MTIpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDM3LjY1MTkxMyUpfTQ4LjM1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjQsIDAuNjI3MDM1LCAwLjYsIDAuOTAyMDI2KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCg4NC4zODYxNjUlKX0xMDAle3RyYW5zZm9ybTp0cmFuc2xhdGVYKDE2MC4yNzc3ODIlKX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeS1pbmRldGVybWluYXRlLXNjYWxlezAle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuMTUsIDAsIDAuNTE1MDU4LCAwLjQwOTY4NSk7dHJhbnNmb3JtOnNjYWxlWCgwLjA4KX0xOS4xNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4zMTAzMywgMC4yODQwNTgsIDAuOCwgMC43MzM3MTIpO3RyYW5zZm9ybTpzY2FsZVgoMC40NTcxMDQpfTQ0LjE1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjQsIDAuNjI3MDM1LCAwLjYsIDAuOTAyMDI2KTt0cmFuc2Zvcm06c2NhbGVYKDAuNzI3OTYpfTEwMCV7dHJhbnNmb3JtOnNjYWxlWCgwLjA4KX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQtc2Nyb2xse3Rve3RyYW5zZm9ybTp0cmFuc2xhdGVYKC04cHgpfX1cXG5cIl1cbiAgICAgICAgICAgIH1dIH1cbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbk1hdFByb2dyZXNzQmFyLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBTdHJpbmcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbQU5JTUFUSU9OX01PRFVMRV9UWVBFLF0gfV0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNQVRfUFJPR1JFU1NfQkFSX0xPQ0FUSU9OLF0gfV0gfVxuXTtcbk1hdFByb2dyZXNzQmFyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBidWZmZXJWYWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgX3ByaW1hcnlWYWx1ZUJhcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3ByaW1hcnlWYWx1ZUJhcicsXSB9XSxcbiAgICBhbmltYXRpb25FbmQ6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBtb2RlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbmlmIChmYWxzZSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBNYXRQcm9ncmVzc0Jhci5uZ0FjY2VwdElucHV0VHlwZV92YWx1ZTtcbiAgICAvKipcbiAgICAgKiBGbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgTm9vcEFuaW1hdGlvbnMgbW9kZSBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXRQcm9ncmVzc0Jhci5wcm90b3R5cGUuX2lzTm9vcEFuaW1hdGlvbjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdFByb2dyZXNzQmFyLnByb3RvdHlwZS5fdmFsdWU7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNYXRQcm9ncmVzc0Jhci5wcm90b3R5cGUuX2J1ZmZlclZhbHVlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBNYXRQcm9ncmVzc0Jhci5wcm90b3R5cGUuX3ByaW1hcnlWYWx1ZUJhcjtcbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gYW5pbWF0aW9uIG9mIHRoZSBwcmltYXJ5IHByb2dyZXNzIGJhciBjb21wbGV0ZXMuIFRoaXMgZXZlbnQgd2lsbCBub3RcbiAgICAgKiBiZSBlbWl0dGVkIHdoZW4gYW5pbWF0aW9ucyBhcmUgZGlzYWJsZWQsIG5vciB3aWxsIGl0IGJlIGVtaXR0ZWQgZm9yIG1vZGVzIHdpdGggY29udGludW91c1xuICAgICAqIGFuaW1hdGlvbnMgKGluZGV0ZXJtaW5hdGUgYW5kIHF1ZXJ5KS5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXRQcm9ncmVzc0Jhci5wcm90b3R5cGUuYW5pbWF0aW9uRW5kO1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBhbmltYXRpb24gZW5kIHN1YnNjcmlwdGlvbiB0byBiZSB1bnN1YnNjcmliZWQgb24gZGVzdHJveS5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdFByb2dyZXNzQmFyLnByb3RvdHlwZS5fYW5pbWF0aW9uRW5kU3Vic2NyaXB0aW9uO1xuICAgIC8qKlxuICAgICAqIE1vZGUgb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICAgKlxuICAgICAqIElucHV0IG11c3QgYmUgb25lIG9mIHRoZXNlIHZhbHVlczogZGV0ZXJtaW5hdGUsIGluZGV0ZXJtaW5hdGUsIGJ1ZmZlciwgcXVlcnksIGRlZmF1bHRzIHRvXG4gICAgICogJ2RldGVybWluYXRlJy5cbiAgICAgKiBNaXJyb3JlZCB0byBtb2RlIGF0dHJpYnV0ZS5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXRQcm9ncmVzc0Jhci5wcm90b3R5cGUubW9kZTtcbiAgICAvKipcbiAgICAgKiBJRCBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE1hdFByb2dyZXNzQmFyLnByb3RvdHlwZS5wcm9ncmVzc2JhcklkO1xuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZSB0byBiZSB1c2VkIGZvciB0aGUgYGZpbGxgIGF0dHJpYnV0ZSBvbiB0aGUgaW50ZXJuYWwgYHJlY3RgIGVsZW1lbnQuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTWF0UHJvZ3Jlc3NCYXIucHJvdG90eXBlLl9yZWN0YW5nbGVGaWxsVmFsdWU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1hdFByb2dyZXNzQmFyLnByb3RvdHlwZS5fZWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdFByb2dyZXNzQmFyLnByb3RvdHlwZS5fbmdab25lO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBNYXRQcm9ncmVzc0Jhci5wcm90b3R5cGUuX2FuaW1hdGlvbk1vZGU7XG59XG4vKipcbiAqIENsYW1wcyBhIHZhbHVlIHRvIGJlIGJldHdlZW4gdHdvIG51bWJlcnMsIGJ5IGRlZmF1bHQgMCBhbmQgMTAwLlxuICogQHBhcmFtIHs/fSB2XG4gKiBAcGFyYW0gez89fSBtaW5cbiAqIEBwYXJhbSB7Pz19IG1heFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2xhbXAodiwgbWluID0gMCwgbWF4ID0gMTAwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2KSk7XG59XG4iXX0=