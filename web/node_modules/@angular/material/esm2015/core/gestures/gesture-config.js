/**
 * @fileoverview added by tsickle
 * Generated from: src/material/core/gestures/gesture-config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injectable, InjectionToken, Inject, Optional } from '@angular/core';
import { HammerGestureConfig } from '@angular/platform-browser';
import { MatCommonModule } from '../common-behaviors/common-module';
/**
 * Injection token that can be used to provide options to the Hammerjs instance.
 * More info at http://hammerjs.github.io/api/.
 * @deprecated No longer being used. To be removed.
 * \@breaking-change 10.0.0
 * @type {?}
 */
import * as ɵngcc0 from '@angular/core';
export const MAT_HAMMER_OPTIONS = new InjectionToken('MAT_HAMMER_OPTIONS');
/** @type {?} */
const ANGULAR_MATERIAL_SUPPORTED_HAMMER_GESTURES = [
    'longpress',
    'slide',
    'slidestart',
    'slideend',
    'slideright',
    'slideleft'
];
const ɵ0 = /**
 * @return {?}
 */
() => { }, ɵ1 = /**
 * @return {?}
 */
() => { };
/**
 * Fake HammerInstance that is used when a Hammer instance is requested when HammerJS has not
 * been loaded on the page.
 * @type {?}
 */
const noopHammerInstance = {
    on: (ɵ0),
    off: (ɵ1),
};
/**
 * Adjusts configuration of our gesture library, Hammer.
 * @deprecated No longer being used. To be removed.
 * \@breaking-change 10.0.0
 */
export class GestureConfig extends HammerGestureConfig {
    /**
     * @param {?=} _hammerOptions
     * @param {?=} _commonModule
     */
    constructor(_hammerOptions, _commonModule) {
        super();
        this._hammerOptions = _hammerOptions;
        /**
         * List of new event names to add to the gesture support list
         */
        this.events = ANGULAR_MATERIAL_SUPPORTED_HAMMER_GESTURES;
    }
    /**
     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
     *
     * Our gesture names come from the Material Design gestures spec:
     * https://material.io/design/#gestures-touch-mechanics
     *
     * More information on default recognizers can be found in Hammer docs:
     * http://hammerjs.github.io/recognizer-pan/
     * http://hammerjs.github.io/recognizer-press/
     *
     * @param {?} element Element to which to assign the new HammerJS gestures.
     * @return {?} Newly-created HammerJS instance.
     */
    buildHammer(element) {
        /** @type {?} */
        const hammer = typeof window !== 'undefined' ? ((/** @type {?} */ (window))).Hammer : null;
        if (!hammer) {
            // If HammerJS is not loaded here, return the noop HammerInstance. This is necessary to
            // ensure that omitting HammerJS completely will not cause any errors while *also* supporting
            // the lazy-loading of HammerJS via the HAMMER_LOADER token introduced in Angular 6.1.
            // Because we can't depend on HAMMER_LOADER's existance until 7.0, we have to always set
            // `this.events` to the set we support, instead of conditionally setting it to `[]` if
            // `HAMMER_LOADER` is present (and then throwing an Error here if `window.Hammer` is
            // undefined).
            // @breaking-change 8.0.0
            return noopHammerInstance;
        }
        /** @type {?} */
        const mc = new hammer(element, this._hammerOptions || undefined);
        // Default Hammer Recognizers.
        /** @type {?} */
        const pan = new hammer.Pan();
        /** @type {?} */
        const swipe = new hammer.Swipe();
        /** @type {?} */
        const press = new hammer.Press();
        // Notice that a HammerJS recognizer can only depend on one other recognizer once.
        // Otherwise the previous `recognizeWith` will be dropped.
        // TODO: Confirm threshold numbers with Material Design UX Team
        /** @type {?} */
        const slide = this._createRecognizer(pan, { event: 'slide', threshold: 0 }, swipe);
        /** @type {?} */
        const longpress = this._createRecognizer(press, { event: 'longpress', time: 500 });
        // Overwrite the default `pan` event to use the swipe event.
        pan.recognizeWith(swipe);
        // Since the slide event threshold is set to zero, the slide recognizer can fire and
        // accidentally reset the longpress recognizer. In order to make sure that the two
        // recognizers can run simultaneously but don't affect each other, we allow the slide
        // recognizer to recognize while a longpress is being processed.
        // See: https://github.com/hammerjs/hammer.js/blob/master/src/manager.js#L123-L124
        longpress.recognizeWith(slide);
        // Add customized gestures to Hammer manager
        mc.add([swipe, press, pan, slide, longpress]);
        return (/** @type {?} */ (mc));
    }
    /**
     * Creates a new recognizer, without affecting the default recognizers of HammerJS
     * @private
     * @param {?} base
     * @param {?} options
     * @param {...?} inheritances
     * @return {?}
     */
    _createRecognizer(base, options, ...inheritances) {
        /** @type {?} */
        let recognizer = new ((/** @type {?} */ (base.constructor)))(options);
        inheritances.push(base);
        inheritances.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => recognizer.recognizeWith(item)));
        return recognizer;
    }
}
GestureConfig.ɵfac = function GestureConfig_Factory(t) { return new (t || GestureConfig)(ɵngcc0.ɵɵinject(MAT_HAMMER_OPTIONS, 8), ɵngcc0.ɵɵinject(MatCommonModule, 8)); };
GestureConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: GestureConfig, factory: GestureConfig.ɵfac });
/** @nocollapse */
GestureConfig.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_HAMMER_OPTIONS,] }] },
    { type: MatCommonModule, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GestureConfig, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MAT_HAMMER_OPTIONS]
            }] }, { type: MatCommonModule, decorators: [{
                type: Optional
            }] }]; }, null); })();
if (false) {
    /**
     * List of new event names to add to the gesture support list
     * @type {?}
     */
    GestureConfig.prototype.events;
    /**
     * @type {?}
     * @private
     */
    GestureConfig.prototype._hammerOptions;
}
export { ɵ0, ɵ1 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9AYW5ndWxhci9tYXRlcmlhbC9lc20yMDE1L2NvcmUvZ2VzdHVyZXMvZ2VzdHVyZS1jb25maWcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzSEMsc0dBR0M7Ozs7Ozs7Ozs7Ozs7OztrQ0FLQSIsImZpbGUiOiJnZXN0dXJlLWNvbmZpZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBHZW5lcmF0ZWQgZnJvbTogc3JjL21hdGVyaWFsL2NvcmUvZ2VzdHVyZXMvZ2VzdHVyZS1jb25maWcudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSGFtbWVyR2VzdHVyZUNvbmZpZyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgTWF0Q29tbW9uTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uLWJlaGF2aW9ycy9jb21tb24tbW9kdWxlJztcbi8qKlxuICogSW5qZWN0aW9uIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBvcHRpb25zIHRvIHRoZSBIYW1tZXJqcyBpbnN0YW5jZS5cbiAqIE1vcmUgaW5mbyBhdCBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2FwaS8uXG4gKiBAZGVwcmVjYXRlZCBObyBsb25nZXIgYmVpbmcgdXNlZC4gVG8gYmUgcmVtb3ZlZC5cbiAqIFxcQGJyZWFraW5nLWNoYW5nZSAxMC4wLjBcbiAqIEB0eXBlIHs/fVxuICovXG5leHBvcnQgY29uc3QgTUFUX0hBTU1FUl9PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuKCdNQVRfSEFNTUVSX09QVElPTlMnKTtcbi8qKiBAdHlwZSB7P30gKi9cbmNvbnN0IEFOR1VMQVJfTUFURVJJQUxfU1VQUE9SVEVEX0hBTU1FUl9HRVNUVVJFUyA9IFtcbiAgICAnbG9uZ3ByZXNzJyxcbiAgICAnc2xpZGUnLFxuICAgICdzbGlkZXN0YXJ0JyxcbiAgICAnc2xpZGVlbmQnLFxuICAgICdzbGlkZXJpZ2h0JyxcbiAgICAnc2xpZGVsZWZ0J1xuXTtcbmNvbnN0IMm1MCA9IC8qKlxuICogQHJldHVybiB7P31cbiAqL1xuKCkgPT4geyB9LCDJtTEgPSAvKipcbiAqIEByZXR1cm4gez99XG4gKi9cbigpID0+IHsgfTtcbi8qKlxuICogRmFrZSBIYW1tZXJJbnN0YW5jZSB0aGF0IGlzIHVzZWQgd2hlbiBhIEhhbW1lciBpbnN0YW5jZSBpcyByZXF1ZXN0ZWQgd2hlbiBIYW1tZXJKUyBoYXMgbm90XG4gKiBiZWVuIGxvYWRlZCBvbiB0aGUgcGFnZS5cbiAqIEB0eXBlIHs/fVxuICovXG5jb25zdCBub29wSGFtbWVySW5zdGFuY2UgPSB7XG4gICAgb246ICjJtTApLFxuICAgIG9mZjogKMm1MSksXG59O1xuLyoqXG4gKiBBZGp1c3RzIGNvbmZpZ3VyYXRpb24gb2Ygb3VyIGdlc3R1cmUgbGlicmFyeSwgSGFtbWVyLlxuICogQGRlcHJlY2F0ZWQgTm8gbG9uZ2VyIGJlaW5nIHVzZWQuIFRvIGJlIHJlbW92ZWQuXG4gKiBcXEBicmVha2luZy1jaGFuZ2UgMTAuMC4wXG4gKi9cbmV4cG9ydCBjbGFzcyBHZXN0dXJlQ29uZmlnIGV4dGVuZHMgSGFtbWVyR2VzdHVyZUNvbmZpZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX2hhbW1lck9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBfY29tbW9uTW9kdWxlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2hhbW1lck9wdGlvbnMsIF9jb21tb25Nb2R1bGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faGFtbWVyT3B0aW9ucyA9IF9oYW1tZXJPcHRpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBuZXcgZXZlbnQgbmFtZXMgdG8gYWRkIHRvIHRoZSBnZXN0dXJlIHN1cHBvcnQgbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudHMgPSBBTkdVTEFSX01BVEVSSUFMX1NVUFBPUlRFRF9IQU1NRVJfR0VTVFVSRVM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBIYW1tZXIgaW5zdGFuY2UgbWFudWFsbHkgdG8gYWRkIGN1c3RvbSByZWNvZ25pemVycyB0aGF0IG1hdGNoIHRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYy5cbiAgICAgKlxuICAgICAqIE91ciBnZXN0dXJlIG5hbWVzIGNvbWUgZnJvbSB0aGUgTWF0ZXJpYWwgRGVzaWduIGdlc3R1cmVzIHNwZWM6XG4gICAgICogaHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vI2dlc3R1cmVzLXRvdWNoLW1lY2hhbmljc1xuICAgICAqXG4gICAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZhdWx0IHJlY29nbml6ZXJzIGNhbiBiZSBmb3VuZCBpbiBIYW1tZXIgZG9jczpcbiAgICAgKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlY29nbml6ZXItcGFuL1xuICAgICAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vcmVjb2duaXplci1wcmVzcy9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBFbGVtZW50IHRvIHdoaWNoIHRvIGFzc2lnbiB0aGUgbmV3IEhhbW1lckpTIGdlc3R1cmVzLlxuICAgICAqIEByZXR1cm4gez99IE5ld2x5LWNyZWF0ZWQgSGFtbWVySlMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYnVpbGRIYW1tZXIoZWxlbWVudCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGhhbW1lciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gKCgvKiogQHR5cGUgez99ICovICh3aW5kb3cpKSkuSGFtbWVyIDogbnVsbDtcbiAgICAgICAgaWYgKCFoYW1tZXIpIHtcbiAgICAgICAgICAgIC8vIElmIEhhbW1lckpTIGlzIG5vdCBsb2FkZWQgaGVyZSwgcmV0dXJuIHRoZSBub29wIEhhbW1lckluc3RhbmNlLiBUaGlzIGlzIG5lY2Vzc2FyeSB0b1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgb21pdHRpbmcgSGFtbWVySlMgY29tcGxldGVseSB3aWxsIG5vdCBjYXVzZSBhbnkgZXJyb3JzIHdoaWxlICphbHNvKiBzdXBwb3J0aW5nXG4gICAgICAgICAgICAvLyB0aGUgbGF6eS1sb2FkaW5nIG9mIEhhbW1lckpTIHZpYSB0aGUgSEFNTUVSX0xPQURFUiB0b2tlbiBpbnRyb2R1Y2VkIGluIEFuZ3VsYXIgNi4xLlxuICAgICAgICAgICAgLy8gQmVjYXVzZSB3ZSBjYW4ndCBkZXBlbmQgb24gSEFNTUVSX0xPQURFUidzIGV4aXN0YW5jZSB1bnRpbCA3LjAsIHdlIGhhdmUgdG8gYWx3YXlzIHNldFxuICAgICAgICAgICAgLy8gYHRoaXMuZXZlbnRzYCB0byB0aGUgc2V0IHdlIHN1cHBvcnQsIGluc3RlYWQgb2YgY29uZGl0aW9uYWxseSBzZXR0aW5nIGl0IHRvIGBbXWAgaWZcbiAgICAgICAgICAgIC8vIGBIQU1NRVJfTE9BREVSYCBpcyBwcmVzZW50IChhbmQgdGhlbiB0aHJvd2luZyBhbiBFcnJvciBoZXJlIGlmIGB3aW5kb3cuSGFtbWVyYCBpc1xuICAgICAgICAgICAgLy8gdW5kZWZpbmVkKS5cbiAgICAgICAgICAgIC8vIEBicmVha2luZy1jaGFuZ2UgOC4wLjBcbiAgICAgICAgICAgIHJldHVybiBub29wSGFtbWVySW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBtYyA9IG5ldyBoYW1tZXIoZWxlbWVudCwgdGhpcy5faGFtbWVyT3B0aW9ucyB8fCB1bmRlZmluZWQpO1xuICAgICAgICAvLyBEZWZhdWx0IEhhbW1lciBSZWNvZ25pemVycy5cbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBwYW4gPSBuZXcgaGFtbWVyLlBhbigpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHN3aXBlID0gbmV3IGhhbW1lci5Td2lwZSgpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHByZXNzID0gbmV3IGhhbW1lci5QcmVzcygpO1xuICAgICAgICAvLyBOb3RpY2UgdGhhdCBhIEhhbW1lckpTIHJlY29nbml6ZXIgY2FuIG9ubHkgZGVwZW5kIG9uIG9uZSBvdGhlciByZWNvZ25pemVyIG9uY2UuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgcHJldmlvdXMgYHJlY29nbml6ZVdpdGhgIHdpbGwgYmUgZHJvcHBlZC5cbiAgICAgICAgLy8gVE9ETzogQ29uZmlybSB0aHJlc2hvbGQgbnVtYmVycyB3aXRoIE1hdGVyaWFsIERlc2lnbiBVWCBUZWFtXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgc2xpZGUgPSB0aGlzLl9jcmVhdGVSZWNvZ25pemVyKHBhbiwgeyBldmVudDogJ3NsaWRlJywgdGhyZXNob2xkOiAwIH0sIHN3aXBlKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBsb25ncHJlc3MgPSB0aGlzLl9jcmVhdGVSZWNvZ25pemVyKHByZXNzLCB7IGV2ZW50OiAnbG9uZ3ByZXNzJywgdGltZTogNTAwIH0pO1xuICAgICAgICAvLyBPdmVyd3JpdGUgdGhlIGRlZmF1bHQgYHBhbmAgZXZlbnQgdG8gdXNlIHRoZSBzd2lwZSBldmVudC5cbiAgICAgICAgcGFuLnJlY29nbml6ZVdpdGgoc3dpcGUpO1xuICAgICAgICAvLyBTaW5jZSB0aGUgc2xpZGUgZXZlbnQgdGhyZXNob2xkIGlzIHNldCB0byB6ZXJvLCB0aGUgc2xpZGUgcmVjb2duaXplciBjYW4gZmlyZSBhbmRcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHJlc2V0IHRoZSBsb25ncHJlc3MgcmVjb2duaXplci4gSW4gb3JkZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHR3b1xuICAgICAgICAvLyByZWNvZ25pemVycyBjYW4gcnVuIHNpbXVsdGFuZW91c2x5IGJ1dCBkb24ndCBhZmZlY3QgZWFjaCBvdGhlciwgd2UgYWxsb3cgdGhlIHNsaWRlXG4gICAgICAgIC8vIHJlY29nbml6ZXIgdG8gcmVjb2duaXplIHdoaWxlIGEgbG9uZ3ByZXNzIGlzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaGFtbWVyanMvaGFtbWVyLmpzL2Jsb2IvbWFzdGVyL3NyYy9tYW5hZ2VyLmpzI0wxMjMtTDEyNFxuICAgICAgICBsb25ncHJlc3MucmVjb2duaXplV2l0aChzbGlkZSk7XG4gICAgICAgIC8vIEFkZCBjdXN0b21pemVkIGdlc3R1cmVzIHRvIEhhbW1lciBtYW5hZ2VyXG4gICAgICAgIG1jLmFkZChbc3dpcGUsIHByZXNzLCBwYW4sIHNsaWRlLCBsb25ncHJlc3NdKTtcbiAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgez99ICovIChtYykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJlY29nbml6ZXIsIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBkZWZhdWx0IHJlY29nbml6ZXJzIG9mIEhhbW1lckpTXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGJhc2VcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gey4uLj99IGluaGVyaXRhbmNlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2NyZWF0ZVJlY29nbml6ZXIoYmFzZSwgb3B0aW9ucywgLi4uaW5oZXJpdGFuY2VzKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgbGV0IHJlY29nbml6ZXIgPSBuZXcgKCgvKiogQHR5cGUgez99ICovIChiYXNlLmNvbnN0cnVjdG9yKSkpKG9wdGlvbnMpO1xuICAgICAgICBpbmhlcml0YW5jZXMucHVzaChiYXNlKTtcbiAgICAgICAgaW5oZXJpdGFuY2VzLmZvckVhY2goKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGl0ZW1cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW0gPT4gcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW0pKSk7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH1cbn1cbkdlc3R1cmVDb25maWcuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuR2VzdHVyZUNvbmZpZy5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNQVRfSEFNTUVSX09QVElPTlMsXSB9XSB9LFxuICAgIHsgdHlwZTogTWF0Q29tbW9uTW9kdWxlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBuZXcgZXZlbnQgbmFtZXMgdG8gYWRkIHRvIHRoZSBnZXN0dXJlIHN1cHBvcnQgbGlzdFxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIEdlc3R1cmVDb25maWcucHJvdG90eXBlLmV2ZW50cztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEdlc3R1cmVDb25maWcucHJvdG90eXBlLl9oYW1tZXJPcHRpb25zO1xufVxuZXhwb3J0IHsgybUwLCDJtTEgfTtcbiJdfQ==