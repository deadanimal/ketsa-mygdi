/**
 * @fileoverview added by tsickle
 * Generated from: src/material/dialog/dialog-content-directives.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, Input, Optional, ElementRef, } from '@angular/core';
import { MatDialog } from './dialog';
import { MatDialogRef } from './dialog-ref';
/**
 * Counter used to generate unique IDs for dialog elements.
 * @type {?}
 */
import * as ɵngcc0 from '@angular/core';
let dialogElementUid = 0;
/**
 * Button that will close the current dialog.
 */
export class MatDialogClose {
    /**
     * @param {?} dialogRef
     * @param {?} _elementRef
     * @param {?} _dialog
     */
    constructor(dialogRef, _elementRef, _dialog) {
        this.dialogRef = dialogRef;
        this._elementRef = _elementRef;
        this._dialog = _dialog;
        /**
         * Default to "button" to prevents accidental form submits.
         */
        this.type = 'button';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.dialogRef) {
            // When this directive is included in a dialog via TemplateRef (rather than being
            // in a Component), the DialogRef isn't available via injection because embedded
            // views cannot be given a custom injector. Instead, we look up the DialogRef by
            // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
            // be resolved at constructor time.
            this.dialogRef = (/** @type {?} */ (getClosestDialog(this._elementRef, this._dialog.openDialogs)));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];
        if (proxiedChange) {
            this.dialogResult = proxiedChange.currentValue;
        }
    }
}
MatDialogClose.ɵfac = function MatDialogClose_Factory(t) { return new (t || MatDialogClose)(ɵngcc0.ɵɵdirectiveInject(MatDialogRef, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MatDialog)); };
MatDialogClose.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatDialogClose, selectors: [["", "mat-dialog-close", ""], ["", "matDialogClose", ""]], hostVars: 2, hostBindings: function MatDialogClose_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function MatDialogClose_click_HostBindingHandler($event) { return ctx.dialogRef.close(ctx.dialogResult); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel || null)("type", ctx.type);
    } }, inputs: { type: "type", dialogResult: ["mat-dialog-close", "dialogResult"], ariaLabel: ["aria-label", "ariaLabel"], _matDialogClose: ["matDialogClose", "_matDialogClose"] }, exportAs: ["matDialogClose"], features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/** @nocollapse */
MatDialogClose.ctorParameters = () => [
    { type: MatDialogRef, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: MatDialog }
];
MatDialogClose.propDecorators = {
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    type: [{ type: Input }],
    dialogResult: [{ type: Input, args: ['mat-dialog-close',] }],
    _matDialogClose: [{ type: Input, args: ['matDialogClose',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatDialogClose, [{
        type: Directive,
        args: [{
                selector: '[mat-dialog-close], [matDialogClose]',
                exportAs: 'matDialogClose',
                host: {
                    '(click)': 'dialogRef.close(dialogResult)',
                    '[attr.aria-label]': 'ariaLabel || null',
                    '[attr.type]': 'type'
                }
            }]
    }], function () { return [{ type: MatDialogRef, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ElementRef }, { type: MatDialog }]; }, { type: [{
            type: Input
        }], dialogResult: [{
            type: Input,
            args: ['mat-dialog-close']
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], _matDialogClose: [{
            type: Input,
            args: ['matDialogClose']
        }] }); })();
if (false) {
    /**
     * Screenreader label for the button.
     * @type {?}
     */
    MatDialogClose.prototype.ariaLabel;
    /**
     * Default to "button" to prevents accidental form submits.
     * @type {?}
     */
    MatDialogClose.prototype.type;
    /**
     * Dialog close input.
     * @type {?}
     */
    MatDialogClose.prototype.dialogResult;
    /** @type {?} */
    MatDialogClose.prototype._matDialogClose;
    /** @type {?} */
    MatDialogClose.prototype.dialogRef;
    /**
     * @type {?}
     * @private
     */
    MatDialogClose.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MatDialogClose.prototype._dialog;
}
/**
 * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.
 */
export class MatDialogTitle {
    /**
     * @param {?} _dialogRef
     * @param {?} _elementRef
     * @param {?} _dialog
     */
    constructor(_dialogRef, _elementRef, _dialog) {
        this._dialogRef = _dialogRef;
        this._elementRef = _elementRef;
        this._dialog = _dialog;
        this.id = `mat-dialog-title-${dialogElementUid++}`;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this._dialogRef) {
            this._dialogRef = (/** @type {?} */ (getClosestDialog(this._elementRef, this._dialog.openDialogs)));
        }
        if (this._dialogRef) {
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const container = this._dialogRef._containerInstance;
                if (container && !container._ariaLabelledBy) {
                    container._ariaLabelledBy = this.id;
                }
            }));
        }
    }
}
MatDialogTitle.ɵfac = function MatDialogTitle_Factory(t) { return new (t || MatDialogTitle)(ɵngcc0.ɵɵdirectiveInject(MatDialogRef, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MatDialog)); };
MatDialogTitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatDialogTitle, selectors: [["", "mat-dialog-title", ""], ["", "matDialogTitle", ""]], hostAttrs: [1, "mat-dialog-title"], hostVars: 1, hostBindings: function MatDialogTitle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.id);
    } }, inputs: { id: "id" }, exportAs: ["matDialogTitle"] });
/** @nocollapse */
MatDialogTitle.ctorParameters = () => [
    { type: MatDialogRef, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: MatDialog }
];
MatDialogTitle.propDecorators = {
    id: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatDialogTitle, [{
        type: Directive,
        args: [{
                selector: '[mat-dialog-title], [matDialogTitle]',
                exportAs: 'matDialogTitle',
                host: {
                    'class': 'mat-dialog-title',
                    '[id]': 'id'
                }
            }]
    }], function () { return [{ type: MatDialogRef, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ElementRef }, { type: MatDialog }]; }, { id: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    MatDialogTitle.prototype.id;
    /**
     * @type {?}
     * @private
     */
    MatDialogTitle.prototype._dialogRef;
    /**
     * @type {?}
     * @private
     */
    MatDialogTitle.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MatDialogTitle.prototype._dialog;
}
/**
 * Scrollable content container of a dialog.
 */
export class MatDialogContent {
}
MatDialogContent.ɵfac = function MatDialogContent_Factory(t) { return new (t || MatDialogContent)(); };
MatDialogContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatDialogContent, selectors: [["", "mat-dialog-content", ""], ["mat-dialog-content"], ["", "matDialogContent", ""]], hostAttrs: [1, "mat-dialog-content"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatDialogContent, [{
        type: Directive,
        args: [{
                selector: `[mat-dialog-content], mat-dialog-content, [matDialogContent]`,
                host: { 'class': 'mat-dialog-content' }
            }]
    }], null, null); })();
/**
 * Container for the bottom action buttons in a dialog.
 * Stays fixed to the bottom when scrolling.
 */
export class MatDialogActions {
}
MatDialogActions.ɵfac = function MatDialogActions_Factory(t) { return new (t || MatDialogActions)(); };
MatDialogActions.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatDialogActions, selectors: [["", "mat-dialog-actions", ""], ["mat-dialog-actions"], ["", "matDialogActions", ""]], hostAttrs: [1, "mat-dialog-actions"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatDialogActions, [{
        type: Directive,
        args: [{
                selector: `[mat-dialog-actions], mat-dialog-actions, [matDialogActions]`,
                host: { 'class': 'mat-dialog-actions' }
            }]
    }], null, null); })();
/**
 * Finds the closest MatDialogRef to an element by looking at the DOM.
 * @param {?} element Element relative to which to look for a dialog.
 * @param {?} openDialogs References to the currently-open dialogs.
 * @return {?}
 */
function getClosestDialog(element, openDialogs) {
    /** @type {?} */
    let parent = element.nativeElement.parentElement;
    while (parent && !parent.classList.contains('mat-dialog-container')) {
        parent = parent.parentElement;
    }
    return parent ? openDialogs.find((/**
     * @param {?} dialog
     * @return {?}
     */
    dialog => dialog.id === (/** @type {?} */ (parent)).id)) : null;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9AYW5ndWxhci9tYXRlcmlhbC9lc20yMDE1L2RpYWxvZy9kaWFsb2ctY29udGVudC1kaXJlY3RpdmVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJDQyxpUUFXQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtRUQsOERBVUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkQ7Ozs7Ozs7MEJBTUM7Ozs7Ozs7O0NBTUQ7Ozs7Ozs7MEJBTUMiLCJmaWxlIjoiZGlhbG9nLWNvbnRlbnQtZGlyZWN0aXZlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBHZW5lcmF0ZWQgZnJvbTogc3JjL21hdGVyaWFsL2RpYWxvZy9kaWFsb2ctY29udGVudC1kaXJlY3RpdmVzLnRzXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT3B0aW9uYWwsIEVsZW1lbnRSZWYsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXREaWFsb2cgfSBmcm9tICcuL2RpYWxvZyc7XG5pbXBvcnQgeyBNYXREaWFsb2dSZWYgfSBmcm9tICcuL2RpYWxvZy1yZWYnO1xuLyoqXG4gKiBDb3VudGVyIHVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyBmb3IgZGlhbG9nIGVsZW1lbnRzLlxuICogQHR5cGUgez99XG4gKi9cbmxldCBkaWFsb2dFbGVtZW50VWlkID0gMDtcbi8qKlxuICogQnV0dG9uIHRoYXQgd2lsbCBjbG9zZSB0aGUgY3VycmVudCBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXREaWFsb2dDbG9zZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaWFsb2dSZWZcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfZGlhbG9nXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGlhbG9nUmVmLCBfZWxlbWVudFJlZiwgX2RpYWxvZykge1xuICAgICAgICB0aGlzLmRpYWxvZ1JlZiA9IGRpYWxvZ1JlZjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9kaWFsb2cgPSBfZGlhbG9nO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCB0byBcImJ1dHRvblwiIHRvIHByZXZlbnRzIGFjY2lkZW50YWwgZm9ybSBzdWJtaXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ2J1dHRvbic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaWFsb2dSZWYpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhpcyBkaXJlY3RpdmUgaXMgaW5jbHVkZWQgaW4gYSBkaWFsb2cgdmlhIFRlbXBsYXRlUmVmIChyYXRoZXIgdGhhbiBiZWluZ1xuICAgICAgICAgICAgLy8gaW4gYSBDb21wb25lbnQpLCB0aGUgRGlhbG9nUmVmIGlzbid0IGF2YWlsYWJsZSB2aWEgaW5qZWN0aW9uIGJlY2F1c2UgZW1iZWRkZWRcbiAgICAgICAgICAgIC8vIHZpZXdzIGNhbm5vdCBiZSBnaXZlbiBhIGN1c3RvbSBpbmplY3Rvci4gSW5zdGVhZCwgd2UgbG9vayB1cCB0aGUgRGlhbG9nUmVmIGJ5XG4gICAgICAgICAgICAvLyBJRC4gVGhpcyBtdXN0IG9jY3VyIGluIGBvbkluaXRgLCBhcyB0aGUgSUQgYmluZGluZyBmb3IgdGhlIGRpYWxvZyBjb250YWluZXIgd29uJ3RcbiAgICAgICAgICAgIC8vIGJlIHJlc29sdmVkIGF0IGNvbnN0cnVjdG9yIHRpbWUuXG4gICAgICAgICAgICB0aGlzLmRpYWxvZ1JlZiA9ICgvKiogQHR5cGUgez99ICovIChnZXRDbG9zZXN0RGlhbG9nKHRoaXMuX2VsZW1lbnRSZWYsIHRoaXMuX2RpYWxvZy5vcGVuRGlhbG9ncykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBwcm94aWVkQ2hhbmdlID0gY2hhbmdlc1snX21hdERpYWxvZ0Nsb3NlJ10gfHwgY2hhbmdlc1snX21hdERpYWxvZ0Nsb3NlUmVzdWx0J107XG4gICAgICAgIGlmIChwcm94aWVkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmRpYWxvZ1Jlc3VsdCA9IHByb3hpZWRDaGFuZ2UuY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuTWF0RGlhbG9nQ2xvc2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYXQtZGlhbG9nLWNsb3NlXSwgW21hdERpYWxvZ0Nsb3NlXScsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtYXREaWFsb2dDbG9zZScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdkaWFsb2dSZWYuY2xvc2UoZGlhbG9nUmVzdWx0KScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdhcmlhTGFiZWwgfHwgbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci50eXBlXSc6ICd0eXBlJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTWF0RGlhbG9nQ2xvc2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBNYXREaWFsb2dSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBNYXREaWFsb2cgfVxuXTtcbk1hdERpYWxvZ0Nsb3NlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGFyaWFMYWJlbDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnYXJpYS1sYWJlbCcsXSB9XSxcbiAgICB0eXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaWFsb2dSZXN1bHQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21hdC1kaWFsb2ctY2xvc2UnLF0gfV0sXG4gICAgX21hdERpYWxvZ0Nsb3NlOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXREaWFsb2dDbG9zZScsXSB9XVxufTtcbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIFNjcmVlbnJlYWRlciBsYWJlbCBmb3IgdGhlIGJ1dHRvbi5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXREaWFsb2dDbG9zZS5wcm90b3R5cGUuYXJpYUxhYmVsO1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdG8gXCJidXR0b25cIiB0byBwcmV2ZW50cyBhY2NpZGVudGFsIGZvcm0gc3VibWl0cy5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXREaWFsb2dDbG9zZS5wcm90b3R5cGUudHlwZTtcbiAgICAvKipcbiAgICAgKiBEaWFsb2cgY2xvc2UgaW5wdXQuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTWF0RGlhbG9nQ2xvc2UucHJvdG90eXBlLmRpYWxvZ1Jlc3VsdDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTWF0RGlhbG9nQ2xvc2UucHJvdG90eXBlLl9tYXREaWFsb2dDbG9zZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTWF0RGlhbG9nQ2xvc2UucHJvdG90eXBlLmRpYWxvZ1JlZjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdERpYWxvZ0Nsb3NlLnByb3RvdHlwZS5fZWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdERpYWxvZ0Nsb3NlLnByb3RvdHlwZS5fZGlhbG9nO1xufVxuLyoqXG4gKiBUaXRsZSBvZiBhIGRpYWxvZyBlbGVtZW50LiBTdGF5cyBmaXhlZCB0byB0aGUgdG9wIG9mIHRoZSBkaWFsb2cgd2hlbiBzY3JvbGxpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXREaWFsb2dUaXRsZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZGlhbG9nUmVmXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX2RpYWxvZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9kaWFsb2dSZWYsIF9lbGVtZW50UmVmLCBfZGlhbG9nKSB7XG4gICAgICAgIHRoaXMuX2RpYWxvZ1JlZiA9IF9kaWFsb2dSZWY7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fZGlhbG9nID0gX2RpYWxvZztcbiAgICAgICAgdGhpcy5pZCA9IGBtYXQtZGlhbG9nLXRpdGxlLSR7ZGlhbG9nRWxlbWVudFVpZCsrfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGlhbG9nUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWFsb2dSZWYgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZ2V0Q2xvc2VzdERpYWxvZyh0aGlzLl9lbGVtZW50UmVmLCB0aGlzLl9kaWFsb2cub3BlbkRpYWxvZ3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpYWxvZ1JlZikge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2RpYWxvZ1JlZi5fY29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lciAmJiAhY29udGFpbmVyLl9hcmlhTGFiZWxsZWRCeSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuX2FyaWFMYWJlbGxlZEJ5ID0gdGhpcy5pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5NYXREaWFsb2dUaXRsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21hdC1kaWFsb2ctdGl0bGVdLCBbbWF0RGlhbG9nVGl0bGVdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21hdERpYWxvZ1RpdGxlJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtZGlhbG9nLXRpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tpZF0nOiAnaWQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTWF0RGlhbG9nVGl0bGUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBNYXREaWFsb2dSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBNYXREaWFsb2cgfVxuXTtcbk1hdERpYWxvZ1RpdGxlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGlkOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbmlmIChmYWxzZSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBNYXREaWFsb2dUaXRsZS5wcm90b3R5cGUuaWQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNYXREaWFsb2dUaXRsZS5wcm90b3R5cGUuX2RpYWxvZ1JlZjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdERpYWxvZ1RpdGxlLnByb3RvdHlwZS5fZWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdERpYWxvZ1RpdGxlLnByb3RvdHlwZS5fZGlhbG9nO1xufVxuLyoqXG4gKiBTY3JvbGxhYmxlIGNvbnRlbnQgY29udGFpbmVyIG9mIGEgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgTWF0RGlhbG9nQ29udGVudCB7XG59XG5NYXREaWFsb2dDb250ZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGBbbWF0LWRpYWxvZy1jb250ZW50XSwgbWF0LWRpYWxvZy1jb250ZW50LCBbbWF0RGlhbG9nQ29udGVudF1gLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21hdC1kaWFsb2ctY29udGVudCcgfVxuICAgICAgICAgICAgfSxdIH1cbl07XG4vKipcbiAqIENvbnRhaW5lciBmb3IgdGhlIGJvdHRvbSBhY3Rpb24gYnV0dG9ucyBpbiBhIGRpYWxvZy5cbiAqIFN0YXlzIGZpeGVkIHRvIHRoZSBib3R0b20gd2hlbiBzY3JvbGxpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXREaWFsb2dBY3Rpb25zIHtcbn1cbk1hdERpYWxvZ0FjdGlvbnMuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogYFttYXQtZGlhbG9nLWFjdGlvbnNdLCBtYXQtZGlhbG9nLWFjdGlvbnMsIFttYXREaWFsb2dBY3Rpb25zXWAsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWRpYWxvZy1hY3Rpb25zJyB9XG4gICAgICAgICAgICB9LF0gfVxuXTtcbi8qKlxuICogRmluZHMgdGhlIGNsb3Nlc3QgTWF0RGlhbG9nUmVmIHRvIGFuIGVsZW1lbnQgYnkgbG9va2luZyBhdCB0aGUgRE9NLlxuICogQHBhcmFtIHs/fSBlbGVtZW50IEVsZW1lbnQgcmVsYXRpdmUgdG8gd2hpY2ggdG8gbG9vayBmb3IgYSBkaWFsb2cuXG4gKiBAcGFyYW0gez99IG9wZW5EaWFsb2dzIFJlZmVyZW5jZXMgdG8gdGhlIGN1cnJlbnRseS1vcGVuIGRpYWxvZ3MuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0RGlhbG9nKGVsZW1lbnQsIG9wZW5EaWFsb2dzKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB3aGlsZSAocGFyZW50ICYmICFwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtYXQtZGlhbG9nLWNvbnRhaW5lcicpKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50ID8gb3BlbkRpYWxvZ3MuZmluZCgoLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaWFsb2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGRpYWxvZyA9PiBkaWFsb2cuaWQgPT09ICgvKiogQHR5cGUgez99ICovIChwYXJlbnQpKS5pZCkpIDogbnVsbDtcbn1cbiJdfQ==