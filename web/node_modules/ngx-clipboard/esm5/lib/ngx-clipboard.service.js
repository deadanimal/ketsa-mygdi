import { __decorate, __param } from "tslib";
import { DOCUMENT } from '@angular/common';
import { Inject, Injectable, Optional } from '@angular/core';
import { WINDOW } from 'ngx-window-token';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "ngx-window-token";
/**
 * The following code is heavily copied from https://github.com/zenorocha/clipboard.js
 */
import * as ɵngcc0 from '@angular/core';
var ClipboardService = /** @class */ (function () {
    function ClipboardService(document, window) {
        this.document = document;
        this.window = window;
        this.copySubject = new Subject();
        this.copyResponse$ = this.copySubject.asObservable();
        this.config = {};
    }
    ClipboardService.prototype.configure = function (config) {
        this.config = config;
    };
    ClipboardService.prototype.copy = function (content) {
        if (!this.isSupported || !content) {
            return this.pushCopyResponse({ isSuccess: false, content: content });
        }
        var copyResult = this.copyFromContent(content);
        if (copyResult) {
            return this.pushCopyResponse({ content: content, isSuccess: copyResult });
        }
        return this.pushCopyResponse({ isSuccess: false, content: content });
    };
    Object.defineProperty(ClipboardService.prototype, "isSupported", {
        get: function () {
            return !!this.document.queryCommandSupported && !!this.document.queryCommandSupported('copy') && !!this.window;
        },
        enumerable: true,
        configurable: true
    });
    ClipboardService.prototype.isTargetValid = function (element) {
        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
            if (element.hasAttribute('disabled')) {
                throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
            }
            return true;
        }
        throw new Error('Target should be input or textarea');
    };
    /**
     * Attempts to copy from an input `targetElm`
     */
    ClipboardService.prototype.copyFromInputElement = function (targetElm, isFocus) {
        if (isFocus === void 0) { isFocus = true; }
        try {
            this.selectTarget(targetElm);
            var re = this.copyText();
            this.clearSelection(isFocus ? targetElm : undefined, this.window);
            return re && this.isCopySuccessInIE11();
        }
        catch (error) {
            return false;
        }
    };
    /**
     * This is a hack for IE11 to return `true` even if copy fails.
     */
    ClipboardService.prototype.isCopySuccessInIE11 = function () {
        var clipboardData = this.window['clipboardData'];
        if (clipboardData && clipboardData.getData) {
            if (!clipboardData.getData('Text')) {
                return false;
            }
        }
        return true;
    };
    /**
     * Creates a fake textarea element, sets its value from `text` property,
     * and makes a selection on it.
     */
    ClipboardService.prototype.copyFromContent = function (content, container) {
        if (container === void 0) { container = this.document.body; }
        // check if the temp textarea still belongs to the current container.
        // In case we have multiple places using ngx-clipboard, one is in a modal using container but the other one is not.
        if (this.tempTextArea && !container.contains(this.tempTextArea)) {
            this.destroy(this.tempTextArea.parentElement);
        }
        if (!this.tempTextArea) {
            this.tempTextArea = this.createTempTextArea(this.document, this.window);
            try {
                container.appendChild(this.tempTextArea);
            }
            catch (error) {
                throw new Error('Container should be a Dom element');
            }
        }
        this.tempTextArea.value = content;
        var toReturn = this.copyFromInputElement(this.tempTextArea, false);
        if (this.config.cleanUpAfterCopy) {
            this.destroy(this.tempTextArea.parentElement);
        }
        return toReturn;
    };
    /**
     * Remove temporary textarea if any exists.
     */
    ClipboardService.prototype.destroy = function (container) {
        if (container === void 0) { container = this.document.body; }
        if (this.tempTextArea) {
            container.removeChild(this.tempTextArea);
            // removeChild doesn't remove the reference from memory
            this.tempTextArea = undefined;
        }
    };
    /**
     * Select the target html input element.
     */
    ClipboardService.prototype.selectTarget = function (inputElement) {
        inputElement.select();
        inputElement.setSelectionRange(0, inputElement.value.length);
        return inputElement.value.length;
    };
    ClipboardService.prototype.copyText = function () {
        return this.document.execCommand('copy');
    };
    /**
     * Moves focus away from `target` and back to the trigger, removes current selection.
     */
    ClipboardService.prototype.clearSelection = function (inputElement, window) {
        inputElement && inputElement.focus();
        window.getSelection().removeAllRanges();
    };
    /**
     * Creates a fake textarea for copy command.
     */
    ClipboardService.prototype.createTempTextArea = function (doc, window) {
        var isRTL = doc.documentElement.getAttribute('dir') === 'rtl';
        var ta;
        ta = doc.createElement('textarea');
        // Prevent zooming on iOS
        ta.style.fontSize = '12pt';
        // Reset box model
        ta.style.border = '0';
        ta.style.padding = '0';
        ta.style.margin = '0';
        // Move element out of screen horizontally
        ta.style.position = 'absolute';
        ta.style[isRTL ? 'right' : 'left'] = '-9999px';
        // Move element to the same position vertically
        var yPosition = window.pageYOffset || doc.documentElement.scrollTop;
        ta.style.top = yPosition + 'px';
        ta.setAttribute('readonly', '');
        return ta;
    };
    /**
     * Pushes copy operation response to copySubject, to provide global access
     * to the response.
     */
    ClipboardService.prototype.pushCopyResponse = function (response) {
        this.copySubject.next(response);
    };
    /**
     * @deprecated use pushCopyResponse instead.
     */
    ClipboardService.prototype.pushCopyReponse = function (response) {
        this.pushCopyResponse(response);
    };
    ClipboardService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [WINDOW,] }] }
    ]; };
    ClipboardService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ClipboardService_Factory() { return new ClipboardService(i0.ɵɵinject(i1.DOCUMENT), i0.ɵɵinject(i2.WINDOW, 8)); }, token: ClipboardService, providedIn: "root" });
    ClipboardService = __decorate([ __param(0, Inject(DOCUMENT)), __param(1, Optional()), __param(1, Inject(WINDOW))
    ], ClipboardService);
ClipboardService.ɵfac = function ClipboardService_Factory(t) { return new (t || ClipboardService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(WINDOW, 8)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClipboardService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [WINDOW]
            }] }]; }, null); })();
    return ClipboardService;
}());
export { ClipboardService };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9uZ3gtY2xpcGJvYXJkL2VzbTUvbGliL25neC1jbGlwYm9hcmQuc2VydmljZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBZ0ttQyxBQUU1Qjs7Ozs7Ozs7Ozs7Ozs7a0NBQ2tCIiwiZmlsZSI6Im5neC1jbGlwYm9hcmQuc2VydmljZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUsIF9fcGFyYW0gfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFdJTkRPVyB9IGZyb20gJ25neC13aW5kb3ctdG9rZW4nO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCAqIGFzIGkwIGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XHJcbmltcG9ydCAqIGFzIGkxIGZyb20gXCJAYW5ndWxhci9jb21tb25cIjtcclxuaW1wb3J0ICogYXMgaTIgZnJvbSBcIm5neC13aW5kb3ctdG9rZW5cIjtcclxuLyoqXHJcbiAqIFRoZSBmb2xsb3dpbmcgY29kZSBpcyBoZWF2aWx5IGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5vcm9jaGEvY2xpcGJvYXJkLmpzXHJcbiAqL1xyXG52YXIgQ2xpcGJvYXJkU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENsaXBib2FyZFNlcnZpY2UoZG9jdW1lbnQsIHdpbmRvdykge1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcclxuICAgICAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcclxuICAgICAgICB0aGlzLmNvcHlTdWJqZWN0ID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgICB0aGlzLmNvcHlSZXNwb25zZSQgPSB0aGlzLmNvcHlTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0ge307XHJcbiAgICB9XHJcbiAgICBDbGlwYm9hcmRTZXJ2aWNlLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9O1xyXG4gICAgQ2xpcGJvYXJkU2VydmljZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkIHx8ICFjb250ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hDb3B5UmVzcG9uc2UoeyBpc1N1Y2Nlc3M6IGZhbHNlLCBjb250ZW50OiBjb250ZW50IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29weVJlc3VsdCA9IHRoaXMuY29weUZyb21Db250ZW50KGNvbnRlbnQpO1xyXG4gICAgICAgIGlmIChjb3B5UmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hDb3B5UmVzcG9uc2UoeyBjb250ZW50OiBjb250ZW50LCBpc1N1Y2Nlc3M6IGNvcHlSZXN1bHQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hDb3B5UmVzcG9uc2UoeyBpc1N1Y2Nlc3M6IGZhbHNlLCBjb250ZW50OiBjb250ZW50IH0pO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGlwYm9hcmRTZXJ2aWNlLnByb3RvdHlwZSwgXCJpc1N1cHBvcnRlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkICYmICEhdGhpcy5kb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQoJ2NvcHknKSAmJiAhIXRoaXMud2luZG93O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQ2xpcGJvYXJkU2VydmljZS5wcm90b3R5cGUuaXNUYXJnZXRWYWxpZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwidGFyZ2V0XCIgYXR0cmlidXRlLiBQbGVhc2UgdXNlIFwicmVhZG9ubHlcIiBpbnN0ZWFkIG9mIFwiZGlzYWJsZWRcIiBhdHRyaWJ1dGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgc2hvdWxkIGJlIGlucHV0IG9yIHRleHRhcmVhJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRlbXB0cyB0byBjb3B5IGZyb20gYW4gaW5wdXQgYHRhcmdldEVsbWBcclxuICAgICAqL1xyXG4gICAgQ2xpcGJvYXJkU2VydmljZS5wcm90b3R5cGUuY29weUZyb21JbnB1dEVsZW1lbnQgPSBmdW5jdGlvbiAodGFyZ2V0RWxtLCBpc0ZvY3VzKSB7XHJcbiAgICAgICAgaWYgKGlzRm9jdXMgPT09IHZvaWQgMCkgeyBpc0ZvY3VzID0gdHJ1ZTsgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0VGFyZ2V0KHRhcmdldEVsbSk7XHJcbiAgICAgICAgICAgIHZhciByZSA9IHRoaXMuY29weVRleHQoKTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbihpc0ZvY3VzID8gdGFyZ2V0RWxtIDogdW5kZWZpbmVkLCB0aGlzLndpbmRvdyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZSAmJiB0aGlzLmlzQ29weVN1Y2Nlc3NJbklFMTEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGEgaGFjayBmb3IgSUUxMSB0byByZXR1cm4gYHRydWVgIGV2ZW4gaWYgY29weSBmYWlscy5cclxuICAgICAqL1xyXG4gICAgQ2xpcGJvYXJkU2VydmljZS5wcm90b3R5cGUuaXNDb3B5U3VjY2Vzc0luSUUxMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2xpcGJvYXJkRGF0YSA9IHRoaXMud2luZG93WydjbGlwYm9hcmREYXRhJ107XHJcbiAgICAgICAgaWYgKGNsaXBib2FyZERhdGEgJiYgY2xpcGJvYXJkRGF0YS5nZXREYXRhKSB7XHJcbiAgICAgICAgICAgIGlmICghY2xpcGJvYXJkRGF0YS5nZXREYXRhKCdUZXh0JykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmYWtlIHRleHRhcmVhIGVsZW1lbnQsIHNldHMgaXRzIHZhbHVlIGZyb20gYHRleHRgIHByb3BlcnR5LFxyXG4gICAgICogYW5kIG1ha2VzIGEgc2VsZWN0aW9uIG9uIGl0LlxyXG4gICAgICovXHJcbiAgICBDbGlwYm9hcmRTZXJ2aWNlLnByb3RvdHlwZS5jb3B5RnJvbUNvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gdm9pZCAwKSB7IGNvbnRhaW5lciA9IHRoaXMuZG9jdW1lbnQuYm9keTsgfVxyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB0ZW1wIHRleHRhcmVhIHN0aWxsIGJlbG9uZ3MgdG8gdGhlIGN1cnJlbnQgY29udGFpbmVyLlxyXG4gICAgICAgIC8vIEluIGNhc2Ugd2UgaGF2ZSBtdWx0aXBsZSBwbGFjZXMgdXNpbmcgbmd4LWNsaXBib2FyZCwgb25lIGlzIGluIGEgbW9kYWwgdXNpbmcgY29udGFpbmVyIGJ1dCB0aGUgb3RoZXIgb25lIGlzIG5vdC5cclxuICAgICAgICBpZiAodGhpcy50ZW1wVGV4dEFyZWEgJiYgIWNvbnRhaW5lci5jb250YWlucyh0aGlzLnRlbXBUZXh0QXJlYSkpIHtcclxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KHRoaXMudGVtcFRleHRBcmVhLnBhcmVudEVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMudGVtcFRleHRBcmVhKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcFRleHRBcmVhID0gdGhpcy5jcmVhdGVUZW1wVGV4dEFyZWEodGhpcy5kb2N1bWVudCwgdGhpcy53aW5kb3cpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGVtcFRleHRBcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGFpbmVyIHNob3VsZCBiZSBhIERvbSBlbGVtZW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50ZW1wVGV4dEFyZWEudmFsdWUgPSBjb250ZW50O1xyXG4gICAgICAgIHZhciB0b1JldHVybiA9IHRoaXMuY29weUZyb21JbnB1dEVsZW1lbnQodGhpcy50ZW1wVGV4dEFyZWEsIGZhbHNlKTtcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2xlYW5VcEFmdGVyQ29weSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kodGhpcy50ZW1wVGV4dEFyZWEucGFyZW50RWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b1JldHVybjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSB0ZW1wb3JhcnkgdGV4dGFyZWEgaWYgYW55IGV4aXN0cy5cclxuICAgICAqL1xyXG4gICAgQ2xpcGJvYXJkU2VydmljZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcclxuICAgICAgICBpZiAoY29udGFpbmVyID09PSB2b2lkIDApIHsgY29udGFpbmVyID0gdGhpcy5kb2N1bWVudC5ib2R5OyB9XHJcbiAgICAgICAgaWYgKHRoaXMudGVtcFRleHRBcmVhKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLnRlbXBUZXh0QXJlYSk7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZUNoaWxkIGRvZXNuJ3QgcmVtb3ZlIHRoZSByZWZlcmVuY2UgZnJvbSBtZW1vcnlcclxuICAgICAgICAgICAgdGhpcy50ZW1wVGV4dEFyZWEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IHRoZSB0YXJnZXQgaHRtbCBpbnB1dCBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBDbGlwYm9hcmRTZXJ2aWNlLnByb3RvdHlwZS5zZWxlY3RUYXJnZXQgPSBmdW5jdGlvbiAoaW5wdXRFbGVtZW50KSB7XHJcbiAgICAgICAgaW5wdXRFbGVtZW50LnNlbGVjdCgpO1xyXG4gICAgICAgIGlucHV0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSgwLCBpbnB1dEVsZW1lbnQudmFsdWUubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gaW5wdXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcclxuICAgIH07XHJcbiAgICBDbGlwYm9hcmRTZXJ2aWNlLnByb3RvdHlwZS5jb3B5VGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgZm9jdXMgYXdheSBmcm9tIGB0YXJnZXRgIGFuZCBiYWNrIHRvIHRoZSB0cmlnZ2VyLCByZW1vdmVzIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBDbGlwYm9hcmRTZXJ2aWNlLnByb3RvdHlwZS5jbGVhclNlbGVjdGlvbiA9IGZ1bmN0aW9uIChpbnB1dEVsZW1lbnQsIHdpbmRvdykge1xyXG4gICAgICAgIGlucHV0RWxlbWVudCAmJiBpbnB1dEVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZmFrZSB0ZXh0YXJlYSBmb3IgY29weSBjb21tYW5kLlxyXG4gICAgICovXHJcbiAgICBDbGlwYm9hcmRTZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGVUZW1wVGV4dEFyZWEgPSBmdW5jdGlvbiAoZG9jLCB3aW5kb3cpIHtcclxuICAgICAgICB2YXIgaXNSVEwgPSBkb2MuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlyJykgPT09ICdydGwnO1xyXG4gICAgICAgIHZhciB0YTtcclxuICAgICAgICB0YSA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xyXG4gICAgICAgIC8vIFByZXZlbnQgem9vbWluZyBvbiBpT1NcclxuICAgICAgICB0YS5zdHlsZS5mb250U2l6ZSA9ICcxMnB0JztcclxuICAgICAgICAvLyBSZXNldCBib3ggbW9kZWxcclxuICAgICAgICB0YS5zdHlsZS5ib3JkZXIgPSAnMCc7XHJcbiAgICAgICAgdGEuc3R5bGUucGFkZGluZyA9ICcwJztcclxuICAgICAgICB0YS5zdHlsZS5tYXJnaW4gPSAnMCc7XHJcbiAgICAgICAgLy8gTW92ZSBlbGVtZW50IG91dCBvZiBzY3JlZW4gaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgdGEuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIHRhLnN0eWxlW2lzUlRMID8gJ3JpZ2h0JyA6ICdsZWZ0J10gPSAnLTk5OTlweCc7XHJcbiAgICAgICAgLy8gTW92ZSBlbGVtZW50IHRvIHRoZSBzYW1lIHBvc2l0aW9uIHZlcnRpY2FsbHlcclxuICAgICAgICB2YXIgeVBvc2l0aW9uID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gICAgICAgIHRhLnN0eWxlLnRvcCA9IHlQb3NpdGlvbiArICdweCc7XHJcbiAgICAgICAgdGEuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICcnKTtcclxuICAgICAgICByZXR1cm4gdGE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQdXNoZXMgY29weSBvcGVyYXRpb24gcmVzcG9uc2UgdG8gY29weVN1YmplY3QsIHRvIHByb3ZpZGUgZ2xvYmFsIGFjY2Vzc1xyXG4gICAgICogdG8gdGhlIHJlc3BvbnNlLlxyXG4gICAgICovXHJcbiAgICBDbGlwYm9hcmRTZXJ2aWNlLnByb3RvdHlwZS5wdXNoQ29weVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgdGhpcy5jb3B5U3ViamVjdC5uZXh0KHJlc3BvbnNlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIHVzZSBwdXNoQ29weVJlc3BvbnNlIGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIENsaXBib2FyZFNlcnZpY2UucHJvdG90eXBlLnB1c2hDb3B5UmVwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgIHRoaXMucHVzaENvcHlSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICB9O1xyXG4gICAgQ2xpcGJvYXJkU2VydmljZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbRE9DVU1FTlQsXSB9XSB9LFxyXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW1dJTkRPVyxdIH1dIH1cclxuICAgIF07IH07XHJcbiAgICBDbGlwYm9hcmRTZXJ2aWNlLsm1cHJvdiA9IGkwLsm1ybVkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gQ2xpcGJvYXJkU2VydmljZV9GYWN0b3J5KCkgeyByZXR1cm4gbmV3IENsaXBib2FyZFNlcnZpY2UoaTAuybXJtWluamVjdChpMS5ET0NVTUVOVCksIGkwLsm1ybVpbmplY3QoaTIuV0lORE9XLCA4KSk7IH0sIHRva2VuOiBDbGlwYm9hcmRTZXJ2aWNlLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcclxuICAgIENsaXBib2FyZFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMCwgSW5qZWN0KERPQ1VNRU5UKSksIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMSwgSW5qZWN0KFdJTkRPVykpXHJcbiAgICBdLCBDbGlwYm9hcmRTZXJ2aWNlKTtcclxuICAgIHJldHVybiBDbGlwYm9hcmRTZXJ2aWNlO1xyXG59KCkpO1xyXG5leHBvcnQgeyBDbGlwYm9hcmRTZXJ2aWNlIH07XHIiXX0=