/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, Output, EventEmitter, ContentChildren, QueryList, KeyValueDiffers, Inject } from '@angular/core';
import { DraggableDirective } from './draggable.directive';
import { DOCUMENT } from '@angular/common';
import * as ɵngcc0 from '@angular/core';
var OrderableDirective = /** @class */ (function () {
    function OrderableDirective(differs, document) {
        this.document = document;
        this.reorder = new EventEmitter();
        this.targetChanged = new EventEmitter();
        this.differ = differs.find({}).create();
    }
    /**
     * @return {?}
     */
    OrderableDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        // HACK: Investigate Better Way
        this.updateSubscriptions();
        this.draggables.changes.subscribe(this.updateSubscriptions.bind(this));
    };
    /**
     * @return {?}
     */
    OrderableDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.draggables.forEach((/**
         * @param {?} d
         * @return {?}
         */
        function (d) {
            d.dragStart.unsubscribe();
            d.dragging.unsubscribe();
            d.dragEnd.unsubscribe();
        }));
    };
    /**
     * @return {?}
     */
    OrderableDirective.prototype.updateSubscriptions = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var diffs = this.differ.diff(this.createMapDiffs());
        if (diffs) {
            /** @type {?} */
            var subscribe = (/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var currentValue = _a.currentValue, previousValue = _a.previousValue;
                unsubscribe_1({ previousValue: previousValue });
                if (currentValue) {
                    currentValue.dragStart.subscribe(_this.onDragStart.bind(_this));
                    currentValue.dragging.subscribe(_this.onDragging.bind(_this));
                    currentValue.dragEnd.subscribe(_this.onDragEnd.bind(_this));
                }
            });
            /** @type {?} */
            var unsubscribe_1 = (/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var previousValue = _a.previousValue;
                if (previousValue) {
                    previousValue.dragStart.unsubscribe();
                    previousValue.dragging.unsubscribe();
                    previousValue.dragEnd.unsubscribe();
                }
            });
            diffs.forEachAddedItem(subscribe);
            // diffs.forEachChangedItem(subscribe.bind(this));
            diffs.forEachRemovedItem(unsubscribe_1);
        }
    };
    /**
     * @return {?}
     */
    OrderableDirective.prototype.onDragStart = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        this.positions = {};
        /** @type {?} */
        var i = 0;
        try {
            for (var _b = tslib_1.__values(this.draggables.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var dragger = _c.value;
                /** @type {?} */
                var elm = dragger.element;
                /** @type {?} */
                var left = parseInt(elm.offsetLeft.toString(), 0);
                this.positions[dragger.dragModel.prop] = {
                    left: left,
                    right: left + parseInt(elm.offsetWidth.toString(), 0),
                    index: i++,
                    element: elm
                };
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    OrderableDirective.prototype.onDragging = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var element = _a.element, model = _a.model, event = _a.event;
        /** @type {?} */
        var prevPos = this.positions[model.prop];
        /** @type {?} */
        var target = this.isTarget(model, event);
        if (target) {
            if (this.lastDraggingIndex !== target.i) {
                this.targetChanged.emit({
                    prevIndex: this.lastDraggingIndex,
                    newIndex: target.i,
                    initialIndex: prevPos.index
                });
                this.lastDraggingIndex = target.i;
            }
        }
        else if (this.lastDraggingIndex !== prevPos.index) {
            this.targetChanged.emit({
                prevIndex: this.lastDraggingIndex,
                initialIndex: prevPos.index
            });
            this.lastDraggingIndex = prevPos.index;
        }
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    OrderableDirective.prototype.onDragEnd = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var element = _a.element, model = _a.model, event = _a.event;
        /** @type {?} */
        var prevPos = this.positions[model.prop];
        /** @type {?} */
        var target = this.isTarget(model, event);
        if (target) {
            this.reorder.emit({
                prevIndex: prevPos.index,
                newIndex: target.i,
                model: model
            });
        }
        this.lastDraggingIndex = undefined;
        element.style.left = 'auto';
    };
    /**
     * @param {?} model
     * @param {?} event
     * @return {?}
     */
    OrderableDirective.prototype.isTarget = /**
     * @param {?} model
     * @param {?} event
     * @return {?}
     */
    function (model, event) {
        /** @type {?} */
        var i = 0;
        /** @type {?} */
        var x = event.x || event.clientX;
        /** @type {?} */
        var y = event.y || event.clientY;
        /** @type {?} */
        var targets = this.document.elementsFromPoint(x, y);
        var _loop_1 = function (prop) {
            // current column position which throws event.
            /** @type {?} */
            var pos = this_1.positions[prop];
            // since we drag the inner span, we need to find it in the elements at the cursor
            if (model.prop !== prop && targets.find((/**
             * @param {?} el
             * @return {?}
             */
            function (el) { return el === pos.element; }))) {
                return { value: {
                        pos: pos,
                        i: i
                    } };
            }
            i++;
        };
        var this_1 = this;
        for (var prop in this.positions) {
            var state_1 = _loop_1(prop);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    };
    /**
     * @private
     * @return {?}
     */
    OrderableDirective.prototype.createMapDiffs = /**
     * @private
     * @return {?}
     */
    function () {
        return this.draggables.toArray().reduce((/**
         * @param {?} acc
         * @param {?} curr
         * @return {?}
         */
        function (acc, curr) {
            acc[curr.dragModel.$$id] = curr;
            return acc;
        }), {});
    };
    /** @nocollapse */
    OrderableDirective.ctorParameters = function () { return [
        { type: KeyValueDiffers },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    OrderableDirective.propDecorators = {
        reorder: [{ type: Output }],
        targetChanged: [{ type: Output }],
        draggables: [{ type: ContentChildren, args: [DraggableDirective, { descendants: true },] }]
    };
OrderableDirective.ɵfac = function OrderableDirective_Factory(t) { return new (t || OrderableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
OrderableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: OrderableDirective, selectors: [["", "orderable", ""]], contentQueries: function OrderableDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DraggableDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.draggables = _t);
    } }, outputs: { reorder: "reorder", targetChanged: "targetChanged" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(OrderableDirective, [{
        type: Directive,
        args: [{ selector: '[orderable]' }]
    }], function () { return [{ type: ɵngcc0.KeyValueDiffers }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { reorder: [{
            type: Output
        }], targetChanged: [{
            type: Output
        }], draggables: [{
            type: ContentChildren,
            args: [DraggableDirective, { descendants: true }]
        }] }); })();
    return OrderableDirective;
}());
export { OrderableDirective };
if (false) {
    /** @type {?} */
    OrderableDirective.prototype.reorder;
    /** @type {?} */
    OrderableDirective.prototype.targetChanged;
    /** @type {?} */
    OrderableDirective.prototype.draggables;
    /** @type {?} */
    OrderableDirective.prototype.positions;
    /** @type {?} */
    OrderableDirective.prototype.differ;
    /** @type {?} */
    OrderableDirective.prototype.lastDraggingIndex;
    /**
     * @type {?}
     * @private
     */
    OrderableDirective.prototype.document;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9Ac3dpbWxhbmUvbmd4LWRhdGF0YWJsZS9lc201L2xpYi9kaXJlY3RpdmVzL29yZGVyYWJsZS5kaXJlY3RpdmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BcU9NLEFBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBVUEiLCJmaWxlIjoib3JkZXJhYmxlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBDb250ZW50Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgS2V5VmFsdWVEaWZmZXJzLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERyYWdnYWJsZURpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZ2dhYmxlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG52YXIgT3JkZXJhYmxlRGlyZWN0aXZlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9yZGVyYWJsZURpcmVjdGl2ZShkaWZmZXJzLCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMucmVvcmRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy50YXJnZXRDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRpZmZlciA9IGRpZmZlcnMuZmluZCh7fSkuY3JlYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3JkZXJhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSEFDSzogSW52ZXN0aWdhdGUgQmV0dGVyIFdheVxuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGVzLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucy5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3JkZXJhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZXMuZm9yRWFjaCgoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGQuZHJhZ1N0YXJ0LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBkLmRyYWdnaW5nLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBkLmRyYWdFbmQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPcmRlcmFibGVEaXJlY3RpdmUucHJvdG90eXBlLnVwZGF0ZVN1YnNjcmlwdGlvbnMgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZlci5kaWZmKHRoaXMuY3JlYXRlTWFwRGlmZnMoKSk7XG4gICAgICAgIGlmIChkaWZmcykge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHN1YnNjcmliZSA9ICgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gX2EuY3VycmVudFZhbHVlLCBwcmV2aW91c1ZhbHVlID0gX2EucHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZV8xKHsgcHJldmlvdXNWYWx1ZTogcHJldmlvdXNWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5kcmFnU3RhcnQuc3Vic2NyaWJlKF90aGlzLm9uRHJhZ1N0YXJ0LmJpbmQoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLmRyYWdnaW5nLnN1YnNjcmliZShfdGhpcy5vbkRyYWdnaW5nLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLmRyYWdFbmQuc3Vic2NyaWJlKF90aGlzLm9uRHJhZ0VuZC5iaW5kKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgdW5zdWJzY3JpYmVfMSA9ICgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IF9hLnByZXZpb3VzVmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZS5kcmFnU3RhcnQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZS5kcmFnZ2luZy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlLmRyYWdFbmQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpZmZzLmZvckVhY2hBZGRlZEl0ZW0oc3Vic2NyaWJlKTtcbiAgICAgICAgICAgIC8vIGRpZmZzLmZvckVhY2hDaGFuZ2VkSXRlbShzdWJzY3JpYmUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBkaWZmcy5mb3JFYWNoUmVtb3ZlZEl0ZW0odW5zdWJzY3JpYmVfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3JkZXJhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSB7fTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IHRzbGliXzEuX192YWx1ZXModGhpcy5kcmFnZ2FibGVzLnRvQXJyYXkoKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ2dlciA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgZWxtID0gZHJhZ2dlci5lbGVtZW50O1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHBhcnNlSW50KGVsbS5vZmZzZXRMZWZ0LnRvU3RyaW5nKCksIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25zW2RyYWdnZXIuZHJhZ01vZGVsLnByb3BdID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogbGVmdCArIHBhcnNlSW50KGVsbS5vZmZzZXRXaWR0aC50b1N0cmluZygpLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGkrKyxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxtXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3JkZXJhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5vbkRyYWdnaW5nID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBfXzBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IF9hLmVsZW1lbnQsIG1vZGVsID0gX2EubW9kZWwsIGV2ZW50ID0gX2EuZXZlbnQ7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHByZXZQb3MgPSB0aGlzLnBvc2l0aW9uc1ttb2RlbC5wcm9wXTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5pc1RhcmdldChtb2RlbCwgZXZlbnQpO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0RHJhZ2dpbmdJbmRleCAhPT0gdGFyZ2V0LmkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldENoYW5nZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIHByZXZJbmRleDogdGhpcy5sYXN0RHJhZ2dpbmdJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXg6IHRhcmdldC5pLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXg6IHByZXZQb3MuaW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3REcmFnZ2luZ0luZGV4ID0gdGFyZ2V0Lmk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5sYXN0RHJhZ2dpbmdJbmRleCAhPT0gcHJldlBvcy5pbmRleCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRDaGFuZ2VkLmVtaXQoe1xuICAgICAgICAgICAgICAgIHByZXZJbmRleDogdGhpcy5sYXN0RHJhZ2dpbmdJbmRleCxcbiAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXg6IHByZXZQb3MuaW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ2dpbmdJbmRleCA9IHByZXZQb3MuaW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPcmRlcmFibGVEaXJlY3RpdmUucHJvdG90eXBlLm9uRHJhZ0VuZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBfYS5lbGVtZW50LCBtb2RlbCA9IF9hLm1vZGVsLCBldmVudCA9IF9hLmV2ZW50O1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBwcmV2UG9zID0gdGhpcy5wb3NpdGlvbnNbbW9kZWwucHJvcF07XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuaXNUYXJnZXQobW9kZWwsIGV2ZW50KTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5yZW9yZGVyLmVtaXQoe1xuICAgICAgICAgICAgICAgIHByZXZJbmRleDogcHJldlBvcy5pbmRleCxcbiAgICAgICAgICAgICAgICBuZXdJbmRleDogdGFyZ2V0LmksXG4gICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3REcmFnZ2luZ0luZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0byc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZGVsXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3JkZXJhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5pc1RhcmdldCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kZWxcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobW9kZWwsIGV2ZW50KSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciB4ID0gZXZlbnQueCB8fCBldmVudC5jbGllbnRYO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciB5ID0gZXZlbnQueSB8fCBldmVudC5jbGllbnRZO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciB0YXJnZXRzID0gdGhpcy5kb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgLy8gY3VycmVudCBjb2x1bW4gcG9zaXRpb24gd2hpY2ggdGhyb3dzIGV2ZW50LlxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXNfMS5wb3NpdGlvbnNbcHJvcF07XG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSBkcmFnIHRoZSBpbm5lciBzcGFuLCB3ZSBuZWVkIHRvIGZpbmQgaXQgaW4gdGhlIGVsZW1lbnRzIGF0IHRoZSBjdXJzb3JcbiAgICAgICAgICAgIGlmIChtb2RlbC5wcm9wICE9PSBwcm9wICYmIHRhcmdldHMuZmluZCgoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsID09PSBwb3MuZWxlbWVudDsgfSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgaTogaVxuICAgICAgICAgICAgICAgICAgICB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMucG9zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEocHJvcCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPcmRlcmFibGVEaXJlY3RpdmUucHJvdG90eXBlLmNyZWF0ZU1hcERpZmZzID0gLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlcy50b0FycmF5KCkucmVkdWNlKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhY2NcbiAgICAgICAgICogQHBhcmFtIHs/fSBjdXJyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoYWNjLCBjdXJyKSB7XG4gICAgICAgICAgICBhY2NbY3Vyci5kcmFnTW9kZWwuJCRpZF0gPSBjdXJyO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSksIHt9KTtcbiAgICB9O1xuICAgIE9yZGVyYWJsZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbb3JkZXJhYmxlXScgfSxdIH1cbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE9yZGVyYWJsZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBLZXlWYWx1ZURpZmZlcnMgfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW0RPQ1VNRU5ULF0gfV0gfVxuICAgIF07IH07XG4gICAgT3JkZXJhYmxlRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICByZW9yZGVyOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIHRhcmdldENoYW5nZWQ6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICAgICAgZHJhZ2dhYmxlczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbRHJhZ2dhYmxlRGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0sXSB9XVxuICAgIH07XG4gICAgcmV0dXJuIE9yZGVyYWJsZURpcmVjdGl2ZTtcbn0oKSk7XG5leHBvcnQgeyBPcmRlcmFibGVEaXJlY3RpdmUgfTtcbmlmIChmYWxzZSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBPcmRlcmFibGVEaXJlY3RpdmUucHJvdG90eXBlLnJlb3JkZXI7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE9yZGVyYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUudGFyZ2V0Q2hhbmdlZDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgT3JkZXJhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5kcmFnZ2FibGVzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBPcmRlcmFibGVEaXJlY3RpdmUucHJvdG90eXBlLnBvc2l0aW9ucztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgT3JkZXJhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5kaWZmZXI7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE9yZGVyYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUubGFzdERyYWdnaW5nSW5kZXg7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBPcmRlcmFibGVEaXJlY3RpdmUucHJvdG90eXBlLmRvY3VtZW50O1xufVxuIl19