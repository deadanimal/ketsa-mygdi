import { __decorate, __metadata, __param } from "tslib";
import { Injectable, Inject } from '@angular/core';
import { JwtHelperService } from './jwthelper.service';
import { JWT_OPTIONS } from './jwtoptions.token';
import { mergeMap } from 'rxjs/operators';
import { parse } from 'url';
import { from } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
let JwtInterceptor = class JwtInterceptor {
    constructor(config, jwtHelper) {
        this.jwtHelper = jwtHelper;
        this.tokenGetter = config.tokenGetter;
        this.headerName = config.headerName || 'Authorization';
        this.authScheme =
            config.authScheme || config.authScheme === ''
                ? config.authScheme
                : 'Bearer ';
        this.whitelistedDomains = config.whitelistedDomains || [];
        this.blacklistedRoutes = config.blacklistedRoutes || [];
        this.throwNoTokenError = config.throwNoTokenError || false;
        this.skipWhenExpired = config.skipWhenExpired;
    }
    isWhitelistedDomain(request) {
        const requestUrl = parse(request.url, false, true);
        return (requestUrl.host === null ||
            this.whitelistedDomains.findIndex(domain => typeof domain === 'string'
                ? domain === requestUrl.host
                : domain instanceof RegExp
                    ? domain.test(requestUrl.host)
                    : false) > -1);
    }
    isBlacklistedRoute(request) {
        const url = request.url;
        return (this.blacklistedRoutes.findIndex(route => typeof route === 'string'
            ? route === url
            : route instanceof RegExp
                ? route.test(url)
                : false) > -1);
    }
    handleInterception(token, request, next) {
        let tokenIsExpired = false;
        if (!token && this.throwNoTokenError) {
            throw new Error('Could not get token from tokenGetter function.');
        }
        if (this.skipWhenExpired) {
            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;
        }
        if (token && tokenIsExpired && this.skipWhenExpired) {
            request = request.clone();
        }
        else if (token) {
            request = request.clone({
                setHeaders: {
                    [this.headerName]: `${this.authScheme}${token}`
                }
            });
        }
        return next.handle(request);
    }
    intercept(request, next) {
        if (!this.isWhitelistedDomain(request) ||
            this.isBlacklistedRoute(request)) {
            return next.handle(request);
        }
        const token = this.tokenGetter();
        if (token instanceof Promise) {
            return from(token).pipe(mergeMap((asyncToken) => {
                return this.handleInterception(asyncToken, request, next);
            }));
        }
        else {
            return this.handleInterception(token, request, next);
        }
    }
};
JwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) { return new (t || JwtInterceptor)(ɵngcc0.ɵɵinject(JWT_OPTIONS), ɵngcc0.ɵɵinject(JwtHelperService)); };
JwtInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: JwtInterceptor, factory: JwtInterceptor.ɵfac });
JwtInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] },
    { type: JwtHelperService }
];
JwtInterceptor = __decorate([ __param(0, Inject(JWT_OPTIONS)),
    __metadata("design:paramtypes", [Object, JwtHelperService])
], JwtInterceptor);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(JwtInterceptor, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [JWT_OPTIONS]
            }] }, { type: JwtHelperService }]; }, null); })();
export { JwtInterceptor };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9waXBlbGluZW5ldHdvcmsva2V0c2EtbXlnZGkvd2ViL25vZGVfbW9kdWxlcy9AYXV0aDAvYW5ndWxhci1qd3QvZXNtMjAxNS9saWIvand0LmludGVyY2VwdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQU9BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswR0FrRUU7Ozs7OzZCQUsyQixBQUUxQjs7Ozs7Ozs7OERBRWdCIiwiZmlsZSI6Imp3dC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSnd0SGVscGVyU2VydmljZSB9IGZyb20gJy4vand0aGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgSldUX09QVElPTlMgfSBmcm9tICcuL2p3dG9wdGlvbnMudG9rZW4nO1xuaW1wb3J0IHsgbWVyZ2VNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAncnhqcyc7XG5sZXQgSnd0SW50ZXJjZXB0b3IgPSBjbGFzcyBKd3RJbnRlcmNlcHRvciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBqd3RIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5qd3RIZWxwZXIgPSBqd3RIZWxwZXI7XG4gICAgICAgIHRoaXMudG9rZW5HZXR0ZXIgPSBjb25maWcudG9rZW5HZXR0ZXI7XG4gICAgICAgIHRoaXMuaGVhZGVyTmFtZSA9IGNvbmZpZy5oZWFkZXJOYW1lIHx8ICdBdXRob3JpemF0aW9uJztcbiAgICAgICAgdGhpcy5hdXRoU2NoZW1lID1cbiAgICAgICAgICAgIGNvbmZpZy5hdXRoU2NoZW1lIHx8IGNvbmZpZy5hdXRoU2NoZW1lID09PSAnJ1xuICAgICAgICAgICAgICAgID8gY29uZmlnLmF1dGhTY2hlbWVcbiAgICAgICAgICAgICAgICA6ICdCZWFyZXIgJztcbiAgICAgICAgdGhpcy53aGl0ZWxpc3RlZERvbWFpbnMgPSBjb25maWcud2hpdGVsaXN0ZWREb21haW5zIHx8IFtdO1xuICAgICAgICB0aGlzLmJsYWNrbGlzdGVkUm91dGVzID0gY29uZmlnLmJsYWNrbGlzdGVkUm91dGVzIHx8IFtdO1xuICAgICAgICB0aGlzLnRocm93Tm9Ub2tlbkVycm9yID0gY29uZmlnLnRocm93Tm9Ub2tlbkVycm9yIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnNraXBXaGVuRXhwaXJlZCA9IGNvbmZpZy5za2lwV2hlbkV4cGlyZWQ7XG4gICAgfVxuICAgIGlzV2hpdGVsaXN0ZWREb21haW4ocmVxdWVzdCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0VXJsID0gcGFyc2UocmVxdWVzdC51cmwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIChyZXF1ZXN0VXJsLmhvc3QgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMud2hpdGVsaXN0ZWREb21haW5zLmZpbmRJbmRleChkb21haW4gPT4gdHlwZW9mIGRvbWFpbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGRvbWFpbiA9PT0gcmVxdWVzdFVybC5ob3N0XG4gICAgICAgICAgICAgICAgOiBkb21haW4gaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgICAgICAgICAgICAgPyBkb21haW4udGVzdChyZXF1ZXN0VXJsLmhvc3QpXG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2UpID4gLTEpO1xuICAgIH1cbiAgICBpc0JsYWNrbGlzdGVkUm91dGUocmVxdWVzdCkge1xuICAgICAgICBjb25zdCB1cmwgPSByZXF1ZXN0LnVybDtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJsYWNrbGlzdGVkUm91dGVzLmZpbmRJbmRleChyb3V0ZSA9PiB0eXBlb2Ygcm91dGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHJvdXRlID09PSB1cmxcbiAgICAgICAgICAgIDogcm91dGUgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgICAgICAgICA/IHJvdXRlLnRlc3QodXJsKVxuICAgICAgICAgICAgICAgIDogZmFsc2UpID4gLTEpO1xuICAgIH1cbiAgICBoYW5kbGVJbnRlcmNlcHRpb24odG9rZW4sIHJlcXVlc3QsIG5leHQpIHtcbiAgICAgICAgbGV0IHRva2VuSXNFeHBpcmVkID0gZmFsc2U7XG4gICAgICAgIGlmICghdG9rZW4gJiYgdGhpcy50aHJvd05vVG9rZW5FcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IHRva2VuIGZyb20gdG9rZW5HZXR0ZXIgZnVuY3Rpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2tpcFdoZW5FeHBpcmVkKSB7XG4gICAgICAgICAgICB0b2tlbklzRXhwaXJlZCA9IHRva2VuID8gdGhpcy5qd3RIZWxwZXIuaXNUb2tlbkV4cGlyZWQodG9rZW4pIDogdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW5Jc0V4cGlyZWQgJiYgdGhpcy5za2lwV2hlbkV4cGlyZWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LmNsb25lKHtcbiAgICAgICAgICAgICAgICBzZXRIZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLmhlYWRlck5hbWVdOiBgJHt0aGlzLmF1dGhTY2hlbWV9JHt0b2tlbn1gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcXVlc3QpO1xuICAgIH1cbiAgICBpbnRlcmNlcHQocmVxdWVzdCwgbmV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNXaGl0ZWxpc3RlZERvbWFpbihyZXF1ZXN0KSB8fFxuICAgICAgICAgICAgdGhpcy5pc0JsYWNrbGlzdGVkUm91dGUocmVxdWVzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5HZXR0ZXIoKTtcbiAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb20odG9rZW4pLnBpcGUobWVyZ2VNYXAoKGFzeW5jVG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVJbnRlcmNlcHRpb24oYXN5bmNUb2tlbiwgcmVxdWVzdCwgbmV4dCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVJbnRlcmNlcHRpb24odG9rZW4sIHJlcXVlc3QsIG5leHQpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkp3dEludGVyY2VwdG9yLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtKV1RfT1BUSU9OUyxdIH1dIH0sXG4gICAgeyB0eXBlOiBKd3RIZWxwZXJTZXJ2aWNlIH1cbl07XG5Kd3RJbnRlcmNlcHRvciA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtKDAsIEluamVjdChKV1RfT1BUSU9OUykpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBKd3RIZWxwZXJTZXJ2aWNlXSlcbl0sIEp3dEludGVyY2VwdG9yKTtcbmV4cG9ydCB7IEp3dEludGVyY2VwdG9yIH07XG4iXX0=