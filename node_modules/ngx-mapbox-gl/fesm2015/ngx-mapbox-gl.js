import { CommonModule } from '@angular/common';
import { InjectionToken, NgZone, Injectable, Optional, Inject, Component, ChangeDetectionStrategy, Input, ViewChild, Directive, Host, EventEmitter, Output, forwardRef, ViewEncapsulation, ChangeDetectorRef, ContentChild, TemplateRef, NgModule } from '@angular/core';
import * as MapboxGl from 'mapbox-gl';
import { Marker, Popup, Map, AttributionControl, FullscreenControl, GeolocateControl, NavigationControl, ScaleControl } from 'mapbox-gl';
import { __awaiter } from 'tslib';
import { AsyncSubject, Subscription, fromEvent, Subject, merge } from 'rxjs';
import { first, switchMap, mapTo, filter, startWith, debounceTime, tap, takeUntil, take } from 'rxjs/operators';
import MapboxGeocoder from '@mapbox/mapbox-gl-geocoder';

const MAPBOX_API_KEY = new InjectionToken('MapboxApiKey');
class MapService {
    constructor(zone, MAPBOX_API_KEY) {
        this.zone = zone;
        this.MAPBOX_API_KEY = MAPBOX_API_KEY;
        this.mapCreated = new AsyncSubject();
        this.mapLoaded = new AsyncSubject();
        this.markersToRemove = [];
        this.popupsToRemove = [];
        this.imageIdsToRemove = [];
        this.subscription = new Subscription();
        this.mapCreated$ = this.mapCreated.asObservable();
        this.mapLoaded$ = this.mapLoaded.asObservable();
    }
    setup(options) {
        // Need onStable to wait for a potential @angular/route transition to end
        this.zone.onStable.pipe(first()).subscribe(() => {
            // Workaround rollup issue
            this.assign(MapboxGl, 'accessToken', options.accessToken || this.MAPBOX_API_KEY);
            if (options.customMapboxApiUrl) {
                this.assign(MapboxGl, 'config.API_URL', options.customMapboxApiUrl);
            }
            this.createMap(options.mapOptions);
            this.hookEvents(options.mapEvents);
            this.mapEvents = options.mapEvents;
            this.mapCreated.next(undefined);
            this.mapCreated.complete();
        });
    }
    destroyMap() {
        if (this.mapInstance) {
            this.subscription.unsubscribe();
            this.mapInstance.remove();
        }
    }
    updateMinZoom(minZoom) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.setMinZoom(minZoom);
        });
    }
    updateMaxZoom(maxZoom) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.setMaxZoom(maxZoom);
        });
    }
    updateMinPitch(minPitch) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.setMinPitch(minPitch);
        });
    }
    updateMaxPitch(maxPitch) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.setMaxPitch(maxPitch);
        });
    }
    updateRenderWorldCopies(status) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.setRenderWorldCopies(status);
        });
    }
    updateScrollZoom(status) {
        return this.zone.runOutsideAngular(() => {
            status
                ? this.mapInstance.scrollZoom.enable()
                : this.mapInstance.scrollZoom.disable();
        });
    }
    updateDragRotate(status) {
        return this.zone.runOutsideAngular(() => {
            status
                ? this.mapInstance.dragRotate.enable()
                : this.mapInstance.dragRotate.disable();
        });
    }
    updateTouchPitch(status) {
        return this.zone.runOutsideAngular(() => {
            status
                ? this.mapInstance.touchPitch.enable()
                : this.mapInstance.touchPitch.disable();
        });
    }
    updateTouchZoomRotate(status) {
        return this.zone.runOutsideAngular(() => {
            status
                ? this.mapInstance.touchZoomRotate.enable()
                : this.mapInstance.touchZoomRotate.disable();
        });
    }
    updateDoubleClickZoom(status) {
        return this.zone.runOutsideAngular(() => {
            status
                ? this.mapInstance.doubleClickZoom.enable()
                : this.mapInstance.doubleClickZoom.disable();
        });
    }
    updateKeyboard(status) {
        return this.zone.runOutsideAngular(() => {
            status
                ? this.mapInstance.keyboard.enable()
                : this.mapInstance.keyboard.disable();
        });
    }
    updateDragPan(status) {
        return this.zone.runOutsideAngular(() => {
            status
                ? this.mapInstance.dragPan.enable()
                : this.mapInstance.dragPan.disable();
        });
    }
    updateBoxZoom(status) {
        return this.zone.runOutsideAngular(() => {
            status
                ? this.mapInstance.boxZoom.enable()
                : this.mapInstance.boxZoom.disable();
        });
    }
    updateStyle(style) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.setStyle(style);
        });
    }
    updateMaxBounds(maxBounds) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.setMaxBounds(maxBounds);
        });
    }
    changeCanvasCursor(cursor) {
        const canvas = this.mapInstance.getCanvasContainer();
        canvas.style.cursor = cursor;
    }
    queryRenderedFeatures(pointOrBox, parameters) {
        return this.mapInstance.queryRenderedFeatures(pointOrBox, parameters);
    }
    panTo(center, options) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.panTo(center, options);
        });
    }
    move(movingMethod, movingOptions, zoom, center, bearing, pitch) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance[movingMethod](Object.assign(Object.assign({}, movingOptions), { zoom: zoom ? zoom : this.mapInstance.getZoom(), center: center ? center : this.mapInstance.getCenter(), bearing: bearing ? bearing : this.mapInstance.getBearing(), pitch: pitch ? pitch : this.mapInstance.getPitch() }));
        });
    }
    addLayer(layer, bindEvents, before) {
        this.zone.runOutsideAngular(() => {
            Object.keys(layer.layerOptions).forEach((key) => {
                const tkey = key;
                if (layer.layerOptions[tkey] === undefined) {
                    delete layer.layerOptions[tkey];
                }
            });
            this.mapInstance.addLayer(layer.layerOptions, before);
            if (bindEvents) {
                if (layer.layerEvents.layerClick.observers.length ||
                    layer.layerEvents.click.observers.length) {
                    this.mapInstance.on('click', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerClick.emit(evt);
                            layer.layerEvents.click.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerDblClick.observers.length ||
                    layer.layerEvents.dblClick.observers.length) {
                    this.mapInstance.on('dblclick', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerDblClick.emit(evt);
                            layer.layerEvents.dblClick.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerMouseDown.observers.length ||
                    layer.layerEvents.mouseDown.observers.length) {
                    this.mapInstance.on('mousedown', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerMouseDown.emit(evt);
                            layer.layerEvents.mouseDown.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerMouseUp.observers.length ||
                    layer.layerEvents.mouseUp.observers.length) {
                    this.mapInstance.on('mouseup', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerMouseUp.emit(evt);
                            layer.layerEvents.mouseUp.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerMouseEnter.observers.length ||
                    layer.layerEvents.mouseEnter.observers.length) {
                    this.mapInstance.on('mouseenter', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerMouseEnter.emit(evt);
                            layer.layerEvents.mouseEnter.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerMouseLeave.observers.length ||
                    layer.layerEvents.mouseLeave.observers.length) {
                    this.mapInstance.on('mouseleave', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerMouseLeave.emit(evt);
                            layer.layerEvents.mouseLeave.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerMouseMove.observers.length ||
                    layer.layerEvents.mouseMove.observers.length) {
                    this.mapInstance.on('mousemove', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerMouseMove.emit(evt);
                            layer.layerEvents.mouseMove.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerMouseOver.observers.length ||
                    layer.layerEvents.mouseOver.observers.length) {
                    this.mapInstance.on('mouseover', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerMouseOver.emit(evt);
                            layer.layerEvents.mouseOver.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerMouseOut.observers.length ||
                    layer.layerEvents.mouseOut.observers.length) {
                    this.mapInstance.on('mouseout', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerMouseOut.emit(evt);
                            layer.layerEvents.mouseOut.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerContextMenu.observers.length ||
                    layer.layerEvents.contextMenu.observers.length) {
                    this.mapInstance.on('contextmenu', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerContextMenu.emit(evt);
                            layer.layerEvents.contextMenu.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerTouchStart.observers.length ||
                    layer.layerEvents.touchStart.observers.length) {
                    this.mapInstance.on('touchstart', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerTouchStart.emit(evt);
                            layer.layerEvents.touchStart.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerTouchEnd.observers.length ||
                    layer.layerEvents.touchEnd.observers.length) {
                    this.mapInstance.on('touchend', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerTouchEnd.emit(evt);
                            layer.layerEvents.touchEnd.emit(evt);
                        });
                    });
                }
                if (layer.layerEvents.layerTouchCancel.observers.length ||
                    layer.layerEvents.touchCancel.observers.length) {
                    this.mapInstance.on('touchcancel', layer.layerOptions.id, (evt) => {
                        this.zone.run(() => {
                            layer.layerEvents.layerTouchCancel.emit(evt);
                            layer.layerEvents.touchCancel.emit(evt);
                        });
                    });
                }
            }
        });
    }
    removeLayer(layerId) {
        this.zone.runOutsideAngular(() => {
            if (this.mapInstance.getLayer(layerId) != null) {
                this.mapInstance.removeLayer(layerId);
            }
        });
    }
    addMarker(marker) {
        const options = {
            offset: marker.markersOptions.offset,
            anchor: marker.markersOptions.anchor,
            draggable: !!marker.markersOptions.draggable,
            rotationAlignment: marker.markersOptions.rotationAlignment,
            pitchAlignment: marker.markersOptions.pitchAlignment,
            clickTolerance: marker.markersOptions.clickTolerance,
        };
        if (marker.markersOptions.element.childNodes.length > 0) {
            options.element = marker.markersOptions.element;
        }
        const markerInstance = new Marker(options);
        if (marker.markersEvents.markerDragStart.observers.length ||
            marker.markersEvents.dragStart.observers.length) {
            markerInstance.on('dragstart', (event) => {
                if (event) {
                    const { target } = event;
                    this.zone.run(() => {
                        marker.markersEvents.markerDragStart.emit(target);
                        marker.markersEvents.dragStart.emit(target);
                    });
                }
            });
        }
        /*
    
         */
        if (marker.markersEvents.markerDrag.observers.length ||
            marker.markersEvents.drag.observers.length) {
            markerInstance.on('drag', (event) => {
                if (event) {
                    const { target } = event;
                    this.zone.run(() => {
                        marker.markersEvents.markerDrag.emit(target);
                        marker.markersEvents.drag.emit(target);
                    });
                }
            });
        }
        if (marker.markersEvents.markerDragEnd.observers.length ||
            marker.markersEvents.dragEnd.observers.length) {
            markerInstance.on('dragend', (event) => {
                if (event) {
                    const { target } = event;
                    this.zone.run(() => {
                        marker.markersEvents.markerDragEnd.emit(target);
                        marker.markersEvents.dragEnd.emit(target);
                    });
                }
            });
        }
        const lngLat = marker.markersOptions.feature
            ? marker.markersOptions.feature.geometry.coordinates
            : marker.markersOptions.lngLat;
        markerInstance.setLngLat(lngLat);
        return this.zone.runOutsideAngular(() => {
            markerInstance.addTo(this.mapInstance);
            return markerInstance;
        });
    }
    removeMarker(marker) {
        this.markersToRemove.push(marker);
    }
    createPopup(popup, element) {
        return this.zone.runOutsideAngular(() => {
            Object.keys(popup.popupOptions).forEach((key) => popup.popupOptions[key] === undefined &&
                delete popup.popupOptions[key]);
            const popupInstance = new Popup(popup.popupOptions);
            popupInstance.setDOMContent(element);
            if (popup.popupEvents.popupClose.observers.length ||
                popup.popupEvents.close.observers.length) {
                popupInstance.on('close', () => {
                    this.zone.run(() => {
                        popup.popupEvents.popupClose.emit();
                        popup.popupEvents.close.emit();
                    });
                });
            }
            if (popup.popupEvents.popupOpen.observers.length ||
                popup.popupEvents.open.observers.length) {
                popupInstance.on('open', () => {
                    this.zone.run(() => {
                        popup.popupEvents.popupOpen.emit();
                        popup.popupEvents.open.emit();
                    });
                });
            }
            return popupInstance;
        });
    }
    addPopupToMap(popup, lngLat, skipOpenEvent = false) {
        return this.zone.runOutsideAngular(() => {
            if (skipOpenEvent && popup._listeners) {
                delete popup._listeners['open'];
            }
            popup.setLngLat(lngLat);
            popup.addTo(this.mapInstance);
        });
    }
    addPopupToMarker(marker, popup) {
        return this.zone.runOutsideAngular(() => {
            marker.setPopup(popup);
        });
    }
    removePopupFromMap(popup, skipCloseEvent = false) {
        if (skipCloseEvent && popup._listeners) {
            delete popup._listeners['close'];
        }
        this.popupsToRemove.push(popup);
    }
    removePopupFromMarker(marker) {
        return this.zone.runOutsideAngular(() => {
            marker.setPopup(undefined);
        });
    }
    addControl(control, position) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.addControl(control, position);
        });
    }
    removeControl(control) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.removeControl(control);
        });
    }
    loadAndAddImage(imageId, url, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.zone.runOutsideAngular(() => {
                return new Promise((resolve, reject) => {
                    this.mapInstance.loadImage(url, (error, image) => {
                        if (error) {
                            reject(error);
                            return;
                        }
                        this.addImage(imageId, image, options);
                        resolve();
                    });
                });
            });
        });
    }
    addImage(imageId, data, options) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.addImage(imageId, data, options);
        });
    }
    removeImage(imageId) {
        this.imageIdsToRemove.push(imageId);
    }
    addSource(sourceId, source) {
        return this.zone.runOutsideAngular(() => {
            Object.keys(source).forEach((key) => source[key] === undefined && delete source[key]);
            this.mapInstance.addSource(sourceId, source);
        });
    }
    getSource(sourceId) {
        return this.mapInstance.getSource(sourceId);
    }
    removeSource(sourceId) {
        this.zone.runOutsideAngular(() => {
            this.findLayersBySourceId(sourceId).forEach((layer) => this.mapInstance.removeLayer(layer.id));
            this.mapInstance.removeSource(sourceId);
        });
    }
    setAllLayerPaintProperty(layerId, paint) {
        return this.zone.runOutsideAngular(() => {
            Object.keys(paint).forEach((key) => {
                // TODO Check for perf, setPaintProperty only on changed paint props maybe
                this.mapInstance.setPaintProperty(layerId, key, paint[key]);
            });
        });
    }
    setAllLayerLayoutProperty(layerId, layout) {
        return this.zone.runOutsideAngular(() => {
            Object.keys(layout).forEach((key) => {
                // TODO Check for perf, setPaintProperty only on changed paint props maybe
                this.mapInstance.setLayoutProperty(layerId, key, layout[key]);
            });
        });
    }
    setLayerFilter(layerId, filter) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.setFilter(layerId, filter);
        });
    }
    setLayerBefore(layerId, beforeId) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.moveLayer(layerId, beforeId);
        });
    }
    setLayerZoomRange(layerId, minZoom, maxZoom) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.setLayerZoomRange(layerId, minZoom ? minZoom : 0, maxZoom ? maxZoom : 20);
        });
    }
    fitBounds(bounds, options) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.fitBounds(bounds, options);
        });
    }
    fitScreenCoordinates(points, bearing, options) {
        return this.zone.runOutsideAngular(() => {
            this.mapInstance.fitScreenCoordinates(points[0], points[1], bearing, options);
        });
    }
    applyChanges() {
        this.zone.runOutsideAngular(() => {
            this.removeMarkers();
            this.removePopups();
            this.removeImages();
        });
    }
    createMap(options) {
        NgZone.assertNotInAngularZone();
        Object.keys(options).forEach((key) => {
            const tkey = key;
            if (options[tkey] === undefined) {
                delete options[tkey];
            }
        });
        this.mapInstance = new Map(options);
        const isIEorEdge = window && /msie\s|trident\/|edge\//i.test(window.navigator.userAgent);
        if (isIEorEdge) {
            this.mapInstance.setStyle(options.style);
        }
        this.subscription.add(this.zone.onMicrotaskEmpty.subscribe(() => this.applyChanges()));
    }
    removeMarkers() {
        for (const marker of this.markersToRemove) {
            marker.remove();
        }
        this.markersToRemove = [];
    }
    removePopups() {
        for (const popup of this.popupsToRemove) {
            popup.remove();
        }
        this.popupsToRemove = [];
    }
    removeImages() {
        for (const imageId of this.imageIdsToRemove) {
            this.mapInstance.removeImage(imageId);
        }
        this.imageIdsToRemove = [];
    }
    findLayersBySourceId(sourceId) {
        const layers = this.mapInstance.getStyle().layers;
        if (layers == null) {
            return [];
        }
        return layers.filter((l) => 'source' in l ? l.source === sourceId : false);
    }
    hookEvents(events) {
        this.mapInstance.on('load', (evt) => {
            this.mapLoaded.next(undefined);
            this.mapLoaded.complete();
            this.zone.run(() => {
                events.mapLoad.emit(evt.target);
                events.load.emit(evt.target);
            });
        });
        if (events.mapResize.observers.length || events.resize.observers.length) {
            this.mapInstance.on('resize', (evt) => this.zone.run(() => {
                events.mapResize.emit(evt);
                events.resize.emit(evt);
            }));
        }
        if (events.mapRemove.observers.length || events.remove.observers.length) {
            this.mapInstance.on('remove', (evt) => this.zone.run(() => {
                events.mapRemove.emit(evt);
                events.remove.emit(evt);
            }));
        }
        if (events.mapMouseDown.observers.length ||
            events.mouseDown.observers.length) {
            this.mapInstance.on('mousedown', (evt) => this.zone.run(() => {
                events.mapMouseDown.emit(evt);
                events.mouseDown.emit(evt);
            }));
        }
        if (events.mapMouseUp.observers.length || events.mouseUp.observers.length) {
            this.mapInstance.on('mouseup', (evt) => this.zone.run(() => {
                events.mapMouseUp.emit(evt);
                events.mouseUp.emit(evt);
            }));
        }
        if (events.mapMouseMove.observers.length ||
            events.mouseMove.observers.length) {
            this.mapInstance.on('mousemove', (evt) => this.zone.run(() => {
                events.mapMouseMove.emit(evt);
                events.mouseMove.emit(evt);
            }));
        }
        if (events.mapClick.observers.length || events.click.observers.length) {
            this.mapInstance.on('click', (evt) => this.zone.run(() => {
                events.mapClick.emit(evt);
                events.click.emit(evt);
            }));
        }
        if (events.mapDblClick.observers.length ||
            events.dblClick.observers.length) {
            this.mapInstance.on('dblclick', (evt) => this.zone.run(() => {
                events.mapDblClick.emit(evt);
                events.dblClick.emit(evt);
            }));
        }
        if (events.mapMouseOver.observers.length ||
            events.mouseOver.observers.length) {
            this.mapInstance.on('mouseover', (evt) => this.zone.run(() => {
                events.mapMouseOver.emit(evt);
                events.mouseOver.emit(evt);
            }));
        }
        if (events.mapMouseOut.observers.length ||
            events.mouseOut.observers.length) {
            this.mapInstance.on('mouseout', (evt) => this.zone.run(() => {
                events.mapMouseOut.emit(evt);
                events.mouseOut.emit(evt);
            }));
        }
        if (events.mapContextMenu.observers.length ||
            events.contextMenu.observers.length) {
            this.mapInstance.on('contextmenu', (evt) => this.zone.run(() => {
                events.mapContextMenu.emit(evt);
                events.contextMenu.emit(evt);
            }));
        }
        if (events.mapTouchStart.observers.length ||
            events.touchStart.observers.length) {
            this.mapInstance.on('touchstart', (evt) => this.zone.run(() => {
                events.mapTouchStart.emit(evt);
                events.touchStart.emit(evt);
            }));
        }
        if (events.mapTouchEnd.observers.length ||
            events.touchEnd.observers.length) {
            this.mapInstance.on('touchend', (evt) => this.zone.run(() => {
                events.mapTouchEnd.emit(evt);
                events.touchEnd.emit(evt);
            }));
        }
        if (events.mapTouchMove.observers.length ||
            events.touchMove.observers.length) {
            this.mapInstance.on('touchmove', (evt) => this.zone.run(() => {
                events.mapTouchMove.emit(evt);
                events.touchMove.emit(evt);
            }));
        }
        if (events.mapTouchCancel.observers.length ||
            events.touchCancel.observers.length) {
            this.mapInstance.on('touchcancel', (evt) => this.zone.run(() => {
                events.mapTouchCancel.emit(evt);
                events.touchCancel.emit(evt);
            }));
        }
        if (events.mapWheel.observers.length || events.wheel.observers.length) {
            this.mapInstance.on('wheel', (evt) => this.zone.run(() => {
                events.mapWheel.emit(evt);
                events.wheel.emit(evt);
            }));
        }
        if (events.moveStart.observers.length) {
            this.mapInstance.on('movestart', (evt) => this.zone.run(() => events.moveStart.emit(evt)));
        }
        if (events.move.observers.length) {
            this.mapInstance.on('move', (evt) => this.zone.run(() => events.move.emit(evt)));
        }
        if (events.moveEnd.observers.length) {
            this.mapInstance.on('moveend', (evt) => this.zone.run(() => events.moveEnd.emit(evt)));
        }
        if (events.mapDragStart.observers.length ||
            events.dragStart.observers.length) {
            this.mapInstance.on('dragstart', (evt) => this.zone.run(() => {
                events.mapDragStart.emit(evt);
                events.dragStart.emit(evt);
            }));
        }
        if (events.mapDrag.observers.length || events.drag.observers.length) {
            this.mapInstance.on('drag', (evt) => this.zone.run(() => {
                events.mapDrag.emit(evt);
                events.drag.emit(evt);
            }));
        }
        if (events.mapDragEnd.observers.length || events.dragEnd.observers.length) {
            this.mapInstance.on('dragend', (evt) => this.zone.run(() => {
                events.mapDragEnd.emit(evt);
                events.dragEnd.emit(evt);
            }));
        }
        if (events.zoomStart.observers.length) {
            this.mapInstance.on('zoomstart', (evt) => this.zone.run(() => events.zoomStart.emit(evt)));
        }
        if (events.zoomEvt.observers.length) {
            this.mapInstance.on('zoom', (evt) => this.zone.run(() => events.zoomEvt.emit(evt)));
        }
        if (events.zoomEnd.observers.length) {
            this.mapInstance.on('zoomend', (evt) => this.zone.run(() => events.zoomEnd.emit(evt)));
        }
        if (events.rotateStart.observers.length) {
            this.mapInstance.on('rotatestart', (evt) => this.zone.run(() => events.rotateStart.emit(evt)));
        }
        if (events.rotate.observers.length) {
            this.mapInstance.on('rotate', (evt) => this.zone.run(() => events.rotate.emit(evt)));
        }
        if (events.rotateEnd.observers.length) {
            this.mapInstance.on('rotateend', (evt) => this.zone.run(() => events.rotateEnd.emit(evt)));
        }
        if (events.pitchStart.observers.length) {
            this.mapInstance.on('pitchstart', (evt) => this.zone.run(() => events.pitchStart.emit(evt)));
        }
        if (events.pitchEvt.observers.length) {
            this.mapInstance.on('pitch', (evt) => this.zone.run(() => events.pitchEvt.emit(evt)));
        }
        if (events.pitchEnd.observers.length) {
            this.mapInstance.on('pitchend', (evt) => this.zone.run(() => events.pitchEnd.emit(evt)));
        }
        if (events.boxZoomStart.observers.length) {
            this.mapInstance.on('boxzoomstart', (evt) => this.zone.run(() => events.boxZoomStart.emit(evt)));
        }
        if (events.boxZoomEnd.observers.length) {
            this.mapInstance.on('boxzoomend', (evt) => this.zone.run(() => events.boxZoomEnd.emit(evt)));
        }
        if (events.boxZoomCancel.observers.length) {
            this.mapInstance.on('boxzoomcancel', (evt) => this.zone.run(() => events.boxZoomCancel.emit(evt)));
        }
        if (events.webGlContextLost.observers.length) {
            this.mapInstance.on('webglcontextlost', (evt) => this.zone.run(() => events.webGlContextLost.emit(evt)));
        }
        if (events.webGlContextRestored.observers.length) {
            this.mapInstance.on('webglcontextrestored', (evt) => this.zone.run(() => events.webGlContextRestored.emit(evt)));
        }
        if (events.render.observers.length) {
            this.mapInstance.on('render', (evt) => this.zone.run(() => events.render.emit(evt)));
        }
        if (events.mapError.observers.length || events.error.observers.length) {
            this.mapInstance.on('error', (evt) => this.zone.run(() => {
                events.mapError.emit(evt);
                events.error.emit(evt);
            }));
        }
        if (events.data.observers.length) {
            this.mapInstance.on('data', (evt) => this.zone.run(() => events.data.emit(evt)));
        }
        if (events.styleData.observers.length) {
            this.mapInstance.on('styledata', (evt) => this.zone.run(() => events.styleData.emit(evt)));
        }
        if (events.sourceData.observers.length) {
            this.mapInstance.on('sourcedata', (evt) => this.zone.run(() => events.sourceData.emit(evt)));
        }
        if (events.dataLoading.observers.length) {
            this.mapInstance.on('dataloading', (evt) => this.zone.run(() => events.dataLoading.emit(evt)));
        }
        if (events.styleDataLoading.observers.length) {
            this.mapInstance.on('styledataloading', (evt) => this.zone.run(() => events.styleDataLoading.emit(evt)));
        }
        if (events.sourceDataLoading.observers.length) {
            this.mapInstance.on('sourcedataloading', (evt) => this.zone.run(() => events.sourceDataLoading.emit(evt)));
        }
        if (events.styleImageMissing.observers.length) {
            this.mapInstance.on('styleimagemissing', (evt) => this.zone.run(() => events.styleImageMissing.emit(evt)));
        }
        if (events.idle.observers.length) {
            this.mapInstance.on('idle', (evt) => this.zone.run(() => events.idle.emit(evt)));
        }
    }
    // TODO move this elsewhere
    assign(obj, prop, value) {
        if (typeof prop === 'string') {
            // tslint:disable-next-line:no-parameter-reassignment
            prop = prop.split('.');
        }
        if (prop.length > 1) {
            const e = prop.shift();
            this.assign((obj[e] =
                Object.prototype.toString.call(obj[e]) === '[object Object]'
                    ? obj[e]
                    : {}), prop, value);
        }
        else {
            obj[prop[0]] = value;
        }
    }
}
MapService.decorators = [
    { type: Injectable }
];
MapService.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MAPBOX_API_KEY,] }] }
];

class CustomControl {
    constructor(container) {
        this.container = container;
    }
    onAdd() {
        return this.container;
    }
    onRemove() {
        return this.container.parentNode.removeChild(this.container);
    }
    getDefaultPosition() {
        return 'top-right';
    }
}
class ControlComponent {
    constructor(MapService) {
        this.MapService = MapService;
        this.controlAdded = false;
    }
    ngAfterContentInit() {
        if (this.content.nativeElement.childNodes.length) {
            this.control = new CustomControl(this.content.nativeElement);
            this.MapService.mapCreated$.subscribe(() => {
                this.MapService.addControl(this.control, this.position);
                this.controlAdded = true;
            });
        }
    }
    ngOnDestroy() {
        if (this.controlAdded) {
            this.MapService.removeControl(this.control);
        }
    }
}
ControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-control',
                template: '<div class="mapboxgl-ctrl" #content><ng-content></ng-content></div>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ControlComponent.ctorParameters = () => [
    { type: MapService }
];
ControlComponent.propDecorators = {
    position: [{ type: Input }],
    content: [{ type: ViewChild, args: ['content', { static: true },] }]
};

class AttributionControlDirective {
    constructor(MapService, ControlComponent) {
        this.MapService = MapService;
        this.ControlComponent = ControlComponent;
    }
    ngAfterContentInit() {
        this.MapService.mapCreated$.subscribe(() => {
            if (this.ControlComponent.control) {
                throw new Error('Another control is already set for this control');
            }
            const options = {};
            if (this.compact !== undefined) {
                options.compact = this.compact;
            }
            if (this.customAttribution !== undefined) {
                options.customAttribution = this.customAttribution;
            }
            this.ControlComponent.control = new AttributionControl(options);
            this.MapService.addControl(this.ControlComponent.control, this.ControlComponent.position);
        });
    }
}
AttributionControlDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mglAttribution]',
            },] }
];
AttributionControlDirective.ctorParameters = () => [
    { type: MapService },
    { type: ControlComponent, decorators: [{ type: Host }] }
];
AttributionControlDirective.propDecorators = {
    compact: [{ type: Input }],
    customAttribution: [{ type: Input }]
};

class FullscreenControlDirective {
    constructor(MapService, ControlComponent) {
        this.MapService = MapService;
        this.ControlComponent = ControlComponent;
    }
    ngAfterContentInit() {
        this.MapService.mapCreated$.subscribe(() => {
            if (this.ControlComponent.control) {
                throw new Error('Another control is already set for this control');
            }
            this.ControlComponent.control = new FullscreenControl({
                container: this.container,
            });
            this.MapService.addControl(this.ControlComponent.control, this.ControlComponent.position);
        });
    }
}
FullscreenControlDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mglFullscreen]',
            },] }
];
FullscreenControlDirective.ctorParameters = () => [
    { type: MapService },
    { type: ControlComponent, decorators: [{ type: Host }] }
];
FullscreenControlDirective.propDecorators = {
    container: [{ type: Input }]
};

function deprecationWarning(context, oldApi, newApi) {
    console.warn(`[ngx-mapbox-gl]: ${context}: ${oldApi} is deprecated, please use ${newApi} instead.`);
}

const MAPBOX_GEOCODER_API_KEY = new InjectionToken('MapboxApiKey');
class GeocoderControlDirective {
    constructor(MapService, zone, ControlComponent, MAPBOX_GEOCODER_API_KEY) {
        this.MapService = MapService;
        this.zone = zone;
        this.ControlComponent = ControlComponent;
        this.MAPBOX_GEOCODER_API_KEY = MAPBOX_GEOCODER_API_KEY;
        this.marker = false;
        this.clear = new EventEmitter();
        this.loading = new EventEmitter();
        this.geocoderResults = new EventEmitter();
        this.geocoderResult = new EventEmitter();
        this.geocoderError = new EventEmitter();
        /**
         * @deprecated Use geocoderResults instead
         */
        this.results = new EventEmitter();
        /**
         * @deprecated Use geocoderResult instead
         */
        this.result = new EventEmitter();
        /**
         * @deprecated Use geocoderError instead
         */
        this.error = new EventEmitter();
    }
    ngAfterContentInit() {
        this.MapService.mapCreated$.subscribe(() => {
            if (this.ControlComponent.control) {
                throw new Error('Another control is already set for this control');
            }
            const options = {
                proximity: this.proximity,
                countries: this.countries,
                placeholder: this.placeholder,
                zoom: this.zoom,
                bbox: this.bbox,
                types: this.types,
                flyTo: this.flyTo,
                minLength: this.minLength,
                limit: this.limit,
                language: this.language,
                filter: this.filter,
                localGeocoder: this.localGeocoder,
                accessToken: this.accessToken || this.MAPBOX_GEOCODER_API_KEY,
                mapboxgl: this.mapboxgl,
                marker: this.marker,
            };
            Object.keys(options).forEach((key) => {
                const tkey = key;
                if (options[tkey] === undefined) {
                    delete options[tkey];
                }
            });
            this.geocoder = new MapboxGeocoder(options);
            this.hookEvents(this);
            this.addControl();
        });
        if (this.searchInput) {
            this.MapService.mapLoaded$.subscribe(() => {
                this.geocoder.query(this.searchInput);
            });
        }
    }
    ngOnChanges(changes) {
        if (!this.geocoder) {
            return;
        }
        if (changes.proximity && !changes.proximity.isFirstChange()) {
            this.geocoder.setProximity(changes.proximity.currentValue);
        }
        if (changes.searchInput) {
            this.geocoder.query(this.searchInput);
        }
    }
    addControl() {
        this.ControlComponent.control = this.geocoder;
        this.MapService.addControl(this.ControlComponent.control, this.ControlComponent.position);
    }
    hookEvents(events) {
        this.warnDeprecatedOutputs(events);
        if (events.results.observers.length ||
            events.geocoderResults.observers.length) {
            this.geocoder.on('results', (evt) => this.zone.run(() => {
                events.geocoderResults.emit(evt);
                events.results.emit(evt);
            }));
        }
        if (events.geocoderResult.observers.length ||
            events.result.observers.length) {
            this.geocoder.on('result', (evt) => {
                // Workaroud issue https://github.com/mapbox/mapbox-gl-geocoder/issues/99
                if (this.lastResultId !== evt.result.id) {
                    this.lastResultId = evt.result.id;
                    this.zone.run(() => {
                        events.geocoderResult.emit(evt);
                        events.result.emit(evt);
                    });
                }
            });
        }
        if (events.error.observers.length ||
            events.geocoderError.observers.length) {
            this.geocoder.on('error', (evt) => this.zone.run(() => {
                events.geocoderError.emit(evt);
                events.error.emit(evt);
            }));
        }
        if (events.loading.observers.length) {
            this.geocoder.on('loading', (evt) => this.zone.run(() => events.loading.emit(evt)));
        }
        if (events.clear.observers.length) {
            this.geocoder.on('clear', () => this.zone.run(() => events.clear.emit()));
        }
    }
    warnDeprecatedOutputs(events) {
        const dw = deprecationWarning.bind(undefined, GeocoderControlDirective.name);
        if (events.results.observers.length) {
            dw('results', 'geocoderResults');
        }
        if (events.result.observers.length) {
            dw('result', 'geocoderResult');
        }
        if (events.error.observers.length) {
            dw('error', 'geocoderError');
        }
    }
}
GeocoderControlDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mglGeocoder]',
            },] }
];
GeocoderControlDirective.ctorParameters = () => [
    { type: MapService },
    { type: NgZone },
    { type: ControlComponent, decorators: [{ type: Host }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MAPBOX_GEOCODER_API_KEY,] }] }
];
GeocoderControlDirective.propDecorators = {
    countries: [{ type: Input }],
    placeholder: [{ type: Input }],
    zoom: [{ type: Input }],
    bbox: [{ type: Input }],
    types: [{ type: Input }],
    flyTo: [{ type: Input }],
    minLength: [{ type: Input }],
    limit: [{ type: Input }],
    language: [{ type: Input }],
    accessToken: [{ type: Input }],
    filter: [{ type: Input }],
    localGeocoder: [{ type: Input }],
    mapboxgl: [{ type: Input }],
    marker: [{ type: Input }],
    proximity: [{ type: Input }],
    searchInput: [{ type: Input }],
    clear: [{ type: Output }],
    loading: [{ type: Output }],
    geocoderResults: [{ type: Output }],
    geocoderResult: [{ type: Output }],
    geocoderError: [{ type: Output }],
    results: [{ type: Output }],
    result: [{ type: Output }],
    error: [{ type: Output }]
};

class GeolocateControlDirective {
    constructor(MapService, ControlComponent) {
        this.MapService = MapService;
        this.ControlComponent = ControlComponent;
        this.geolocate = new EventEmitter();
    }
    ngAfterContentInit() {
        this.MapService.mapCreated$.subscribe(() => {
            if (this.ControlComponent.control) {
                throw new Error('Another control is already set for this control');
            }
            const options = {
                positionOptions: this.positionOptions,
                fitBoundsOptions: this.fitBoundsOptions,
                trackUserLocation: this.trackUserLocation,
                showUserLocation: this.showUserLocation,
            };
            Object.keys(options).forEach((key) => {
                const tkey = key;
                if (options[tkey] === undefined) {
                    delete options[tkey];
                }
            });
            this.ControlComponent.control = new GeolocateControl(options);
            this.ControlComponent.control.on('geolocate', (data) => {
                this.geolocate.emit(data);
            });
            this.MapService.addControl(this.ControlComponent.control, this.ControlComponent.position);
        });
    }
}
GeolocateControlDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mglGeolocate]',
            },] }
];
GeolocateControlDirective.ctorParameters = () => [
    { type: MapService },
    { type: ControlComponent, decorators: [{ type: Host }] }
];
GeolocateControlDirective.propDecorators = {
    positionOptions: [{ type: Input }],
    fitBoundsOptions: [{ type: Input }],
    trackUserLocation: [{ type: Input }],
    showUserLocation: [{ type: Input }],
    geolocate: [{ type: Output }]
};

class NavigationControlDirective {
    constructor(MapService, ControlComponent) {
        this.MapService = MapService;
        this.ControlComponent = ControlComponent;
    }
    ngAfterContentInit() {
        this.MapService.mapCreated$.subscribe(() => {
            if (this.ControlComponent.control) {
                throw new Error('Another control is already set for this control');
            }
            const options = {};
            if (this.showCompass !== undefined) {
                options.showCompass = this.showCompass;
            }
            if (this.showZoom !== undefined) {
                options.showZoom = this.showZoom;
            }
            this.ControlComponent.control = new NavigationControl(options);
            this.MapService.addControl(this.ControlComponent.control, this.ControlComponent.position);
        });
    }
}
NavigationControlDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mglNavigation]',
            },] }
];
NavigationControlDirective.ctorParameters = () => [
    { type: MapService },
    { type: ControlComponent, decorators: [{ type: Host }] }
];
NavigationControlDirective.propDecorators = {
    showCompass: [{ type: Input }],
    showZoom: [{ type: Input }]
};

class ScaleControlDirective {
    constructor(MapService, ControlComponent) {
        this.MapService = MapService;
        this.ControlComponent = ControlComponent;
    }
    ngOnChanges(changes) {
        if (changes.unit && !changes.unit.isFirstChange()) {
            this.ControlComponent.control.setUnit(changes.unit.currentValue);
        }
    }
    ngAfterContentInit() {
        this.MapService.mapCreated$.subscribe(() => {
            if (this.ControlComponent.control) {
                throw new Error('Another control is already set for this control');
            }
            const options = {};
            if (this.maxWidth !== undefined) {
                options.maxWidth = this.maxWidth;
            }
            if (this.unit !== undefined) {
                options.unit = this.unit;
            }
            this.ControlComponent.control = new ScaleControl(options);
            this.MapService.addControl(this.ControlComponent.control, this.ControlComponent.position);
        });
    }
}
ScaleControlDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mglScale]',
            },] }
];
ScaleControlDirective.ctorParameters = () => [
    { type: MapService },
    { type: ControlComponent, decorators: [{ type: Host }] }
];
ScaleControlDirective.propDecorators = {
    maxWidth: [{ type: Input }],
    unit: [{ type: Input }]
};

class LayerComponent {
    constructor(MapService) {
        this.MapService = MapService;
        this.layerClick = new EventEmitter();
        this.layerDblClick = new EventEmitter();
        this.layerMouseDown = new EventEmitter();
        this.layerMouseUp = new EventEmitter();
        this.layerMouseEnter = new EventEmitter();
        this.layerMouseLeave = new EventEmitter();
        this.layerMouseMove = new EventEmitter();
        this.layerMouseOver = new EventEmitter();
        this.layerMouseOut = new EventEmitter();
        this.layerContextMenu = new EventEmitter();
        this.layerTouchStart = new EventEmitter();
        this.layerTouchEnd = new EventEmitter();
        this.layerTouchCancel = new EventEmitter();
        /**
         * @deprecated Use layerClick instead
         */
        this.click = new EventEmitter();
        /**
         * @deprecated Use layerDblClick instead
         */
        this.dblClick = new EventEmitter();
        /**
         * @deprecated Use layerMouseDown instead
         */
        this.mouseDown = new EventEmitter();
        /**
         * @deprecated Use layerMouseUp instead
         */
        this.mouseUp = new EventEmitter();
        /**
         * @deprecated Use layerMouseEnter instead
         */
        this.mouseEnter = new EventEmitter();
        /**
         * @deprecated Use layerMouseLeave instead
         */
        this.mouseLeave = new EventEmitter();
        /**
         * @deprecated Use layerMouseMove instead
         */
        this.mouseMove = new EventEmitter();
        /**
         * @deprecated Use layerMouseOver instead
         */
        this.mouseOver = new EventEmitter();
        /**
         * @deprecated Use layerMouseOut instead
         */
        this.mouseOut = new EventEmitter();
        /**
         * @deprecated Use layerContextMenu instead
         */
        this.contextMenu = new EventEmitter();
        /**
         * @deprecated Use layerTouchStart instead
         */
        this.touchStart = new EventEmitter();
        /**
         * @deprecated Use layerTouchEnd instead
         */
        this.touchEnd = new EventEmitter();
        /**
         * @deprecated Use layerTouchCancel instead
         */
        this.touchCancel = new EventEmitter();
        this.layerAdded = false;
    }
    ngOnInit() {
        this.warnDeprecatedOutputs();
        this.sub = this.MapService.mapLoaded$
            .pipe(switchMap(() => fromEvent(this.MapService.mapInstance, 'styledata').pipe(mapTo(false), filter(() => !this.MapService.mapInstance.getLayer(this.id)), startWith(true))))
            .subscribe((bindEvents) => this.init(bindEvents));
    }
    ngOnChanges(changes) {
        if (!this.layerAdded) {
            return;
        }
        if (changes.paint && !changes.paint.isFirstChange()) {
            this.MapService.setAllLayerPaintProperty(this.id, changes.paint.currentValue);
        }
        if (changes.layout && !changes.layout.isFirstChange()) {
            this.MapService.setAllLayerLayoutProperty(this.id, changes.layout.currentValue);
        }
        if (changes.filter && !changes.filter.isFirstChange()) {
            this.MapService.setLayerFilter(this.id, changes.filter.currentValue);
        }
        if (changes.before && !changes.before.isFirstChange()) {
            this.MapService.setLayerBefore(this.id, changes.before.currentValue);
        }
        if ((changes.minzoom && !changes.minzoom.isFirstChange()) ||
            (changes.maxzoom && !changes.maxzoom.isFirstChange())) {
            this.MapService.setLayerZoomRange(this.id, this.minzoom, this.maxzoom);
        }
    }
    ngOnDestroy() {
        if (this.layerAdded) {
            this.MapService.removeLayer(this.id);
        }
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
    init(bindEvents) {
        const layer = {
            layerOptions: {
                id: this.id,
                type: this.type,
                source: this.source,
                metadata: this.metadata,
                'source-layer': this.sourceLayer,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                filter: this.filter,
                layout: this.layout,
                paint: this.paint,
            },
            layerEvents: {
                layerClick: this.layerClick,
                layerDblClick: this.layerDblClick,
                layerMouseDown: this.layerMouseDown,
                layerMouseUp: this.layerMouseUp,
                layerMouseEnter: this.layerMouseEnter,
                layerMouseLeave: this.layerMouseLeave,
                layerMouseMove: this.layerMouseMove,
                layerMouseOver: this.layerMouseOver,
                layerMouseOut: this.layerMouseOut,
                layerContextMenu: this.layerContextMenu,
                layerTouchStart: this.layerTouchStart,
                layerTouchEnd: this.layerTouchEnd,
                layerTouchCancel: this.layerTouchCancel,
                click: this.click,
                dblClick: this.dblClick,
                mouseDown: this.mouseDown,
                mouseUp: this.mouseUp,
                mouseEnter: this.mouseEnter,
                mouseLeave: this.mouseLeave,
                mouseMove: this.mouseMove,
                mouseOver: this.mouseOver,
                mouseOut: this.mouseOut,
                contextMenu: this.contextMenu,
                touchStart: this.touchStart,
                touchEnd: this.touchEnd,
                touchCancel: this.touchCancel,
            },
        };
        this.MapService.addLayer(layer, bindEvents, this.before);
        this.layerAdded = true;
    }
    warnDeprecatedOutputs() {
        const dw = deprecationWarning.bind(undefined, LayerComponent.name);
        if (this.click.observers.length) {
            dw('click', 'layerClick');
        }
        if (this.dblClick.observers.length) {
            dw('dblClick', 'layerDblClick');
        }
        if (this.mouseDown.observers.length) {
            dw('mouseDown', 'layerMouseDown');
        }
        if (this.mouseUp.observers.length) {
            dw('mouseUp', 'layerMouseUp');
        }
        if (this.mouseEnter.observers.length) {
            dw('mouseEnter', 'layerMouseEnter');
        }
        if (this.mouseLeave.observers.length) {
            dw('mouseLeave', 'layerMouseLeave');
        }
        if (this.mouseMove.observers.length) {
            dw('mouseMove', 'layerMouseMove');
        }
        if (this.mouseOver.observers.length) {
            dw('mouseOver', 'layerMouseOver');
        }
        if (this.mouseOut.observers.length) {
            dw('mouseOut', 'layerMouseOut');
        }
        if (this.contextMenu.observers.length) {
            dw('contextMenu', 'layerContextMenu');
        }
        if (this.touchStart.observers.length) {
            dw('touchStart', 'layerTouchStart');
        }
        if (this.touchEnd.observers.length) {
            dw('touchEnd', 'layerTouchEnd');
        }
        if (this.touchCancel.observers.length) {
            dw('touchCancel', 'layerTouchCancel');
        }
    }
}
LayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-layer',
                template: ''
            },] }
];
LayerComponent.ctorParameters = () => [
    { type: MapService }
];
LayerComponent.propDecorators = {
    id: [{ type: Input }],
    source: [{ type: Input }],
    type: [{ type: Input }],
    metadata: [{ type: Input }],
    sourceLayer: [{ type: Input }],
    filter: [{ type: Input }],
    layout: [{ type: Input }],
    paint: [{ type: Input }],
    before: [{ type: Input }],
    minzoom: [{ type: Input }],
    maxzoom: [{ type: Input }],
    layerClick: [{ type: Output }],
    layerDblClick: [{ type: Output }],
    layerMouseDown: [{ type: Output }],
    layerMouseUp: [{ type: Output }],
    layerMouseEnter: [{ type: Output }],
    layerMouseLeave: [{ type: Output }],
    layerMouseMove: [{ type: Output }],
    layerMouseOver: [{ type: Output }],
    layerMouseOut: [{ type: Output }],
    layerContextMenu: [{ type: Output }],
    layerTouchStart: [{ type: Output }],
    layerTouchEnd: [{ type: Output }],
    layerTouchCancel: [{ type: Output }],
    click: [{ type: Output }],
    dblClick: [{ type: Output }],
    mouseDown: [{ type: Output }],
    mouseUp: [{ type: Output }],
    mouseEnter: [{ type: Output }],
    mouseLeave: [{ type: Output }],
    mouseMove: [{ type: Output }],
    mouseOver: [{ type: Output }],
    mouseOut: [{ type: Output }],
    contextMenu: [{ type: Output }],
    touchStart: [{ type: Output }],
    touchEnd: [{ type: Output }],
    touchCancel: [{ type: Output }]
};

class GeoJSONSourceComponent {
    constructor(MapService, zone) {
        this.MapService = MapService;
        this.zone = zone;
        this.updateFeatureData = new Subject();
        this.sub = new Subscription();
        this.sourceAdded = false;
        this.featureIdCounter = 0;
    }
    ngOnInit() {
        if (!this.data) {
            this.data = {
                type: 'FeatureCollection',
                features: [],
            };
        }
        const sub1 = this.MapService.mapLoaded$.subscribe(() => {
            this.init();
            const sub = fromEvent(this.MapService.mapInstance, 'styledata')
                .pipe(filter(() => !this.MapService.mapInstance.getSource(this.id)))
                .subscribe(() => {
                this.init();
            });
            this.sub.add(sub);
        });
        this.sub.add(sub1);
    }
    ngOnChanges(changes) {
        if (!this.sourceAdded) {
            return;
        }
        if ((changes.maxzoom && !changes.maxzoom.isFirstChange()) ||
            (changes.attribution && !changes.attribution.isFirstChange()) ||
            (changes.buffer && !changes.buffer.isFirstChange()) ||
            (changes.tolerance && !changes.tolerance.isFirstChange()) ||
            (changes.cluster && !changes.cluster.isFirstChange()) ||
            (changes.clusterRadius && !changes.clusterRadius.isFirstChange()) ||
            (changes.clusterMaxZoom && !changes.clusterMaxZoom.isFirstChange()) ||
            (changes.clusterMinPoints && !changes.clusterMinPoints.isFirstChange()) ||
            (changes.clusterProperties &&
                !changes.clusterProperties.isFirstChange()) ||
            (changes.lineMetrics && !changes.lineMetrics.isFirstChange()) ||
            (changes.generateId && !changes.generateId.isFirstChange()) ||
            (changes.promoteId && !changes.promoteId.isFirstChange()) ||
            (changes.filter && !changes.filter.isFirstChange())) {
            this.ngOnDestroy();
            this.ngOnInit();
        }
        if (changes.data && !changes.data.isFirstChange()) {
            const source = this.MapService.getSource(this.id);
            source.setData(this.data);
        }
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
        if (this.sourceAdded) {
            this.MapService.removeSource(this.id);
            this.sourceAdded = false;
        }
    }
    /**
     * For clustered sources, fetches the zoom at which the given cluster expands.
     * @param clusterId The value of the cluster's cluster_id property.
     */
    getClusterExpansionZoom(clusterId) {
        return __awaiter(this, void 0, void 0, function* () {
            const source = this.MapService.getSource(this.id);
            return this.zone.run(() => __awaiter(this, void 0, void 0, function* () {
                return new Promise((resolve, reject) => {
                    source.getClusterExpansionZoom(clusterId, (error, zoom) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve(zoom);
                        }
                    });
                });
            }));
        });
    }
    /**
     * For clustered sources, fetches the children of the given cluster on the next zoom level (as an array of GeoJSON features).
     * @param clusterId The value of the cluster's cluster_id property.
     */
    getClusterChildren(clusterId) {
        return __awaiter(this, void 0, void 0, function* () {
            const source = this.MapService.getSource(this.id);
            return this.zone.run(() => __awaiter(this, void 0, void 0, function* () {
                return new Promise((resolve, reject) => {
                    source.getClusterChildren(clusterId, (error, features) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve(features);
                        }
                    });
                });
            }));
        });
    }
    /**
     * For clustered sources, fetches the original points that belong to the cluster (as an array of GeoJSON features).
     * @param clusterId The value of the cluster's cluster_id property.
     * @param limit The maximum number of features to return.
     * @param offset The number of features to skip (e.g. for pagination).
     */
    getClusterLeaves(clusterId, limit, offset) {
        return __awaiter(this, void 0, void 0, function* () {
            const source = this.MapService.getSource(this.id);
            return this.zone.run(() => __awaiter(this, void 0, void 0, function* () {
                return new Promise((resolve, reject) => {
                    source.getClusterLeaves(clusterId, limit, offset, (error, features) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve(features);
                        }
                    });
                });
            }));
        });
    }
    _addFeature(feature) {
        const collection = (this.data);
        collection.features.push(feature);
        this.updateFeatureData.next();
    }
    _removeFeature(feature) {
        const collection = (this.data);
        const index = collection.features.indexOf(feature);
        if (index > -1) {
            collection.features.splice(index, 1);
        }
        this.updateFeatureData.next();
    }
    _getNewFeatureId() {
        return ++this.featureIdCounter;
    }
    init() {
        const source = {
            type: 'geojson',
            data: this.data,
            maxzoom: this.maxzoom,
            attribution: this.attribution,
            buffer: this.buffer,
            tolerance: this.tolerance,
            cluster: this.cluster,
            clusterRadius: this.clusterRadius,
            clusterMaxZoom: this.clusterMaxZoom,
            clusterMinPoints: this.clusterMinPoints,
            clusterProperties: this.clusterProperties,
            lineMetrics: this.lineMetrics,
            generateId: this.generateId,
            promoteId: this.promoteId,
            filter: this.filter,
        };
        this.MapService.addSource(this.id, source);
        const sub = this.updateFeatureData.pipe(debounceTime(0)).subscribe(() => {
            const source = this.MapService.getSource(this.id);
            source.setData(this.data);
        });
        this.sub.add(sub);
        this.sourceAdded = true;
    }
}
GeoJSONSourceComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-geojson-source',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
GeoJSONSourceComponent.ctorParameters = () => [
    { type: MapService },
    { type: NgZone }
];
GeoJSONSourceComponent.propDecorators = {
    id: [{ type: Input }],
    data: [{ type: Input }],
    maxzoom: [{ type: Input }],
    attribution: [{ type: Input }],
    buffer: [{ type: Input }],
    tolerance: [{ type: Input }],
    cluster: [{ type: Input }],
    clusterRadius: [{ type: Input }],
    clusterMaxZoom: [{ type: Input }],
    clusterMinPoints: [{ type: Input }],
    clusterProperties: [{ type: Input }],
    lineMetrics: [{ type: Input }],
    generateId: [{ type: Input }],
    promoteId: [{ type: Input }],
    filter: [{ type: Input }]
};

class FeatureComponent {
    constructor(GeoJSONSourceComponent) {
        this.GeoJSONSourceComponent = GeoJSONSourceComponent;
        this.type = 'Feature';
    }
    ngOnInit() {
        if (!this.id) {
            this.id = this.GeoJSONSourceComponent._getNewFeatureId();
        }
        this.feature = {
            type: this.type,
            geometry: this.geometry,
            properties: this.properties ? this.properties : {},
        };
        this.feature.id = this.id;
        this.GeoJSONSourceComponent._addFeature(this.feature);
    }
    ngOnDestroy() {
        this.GeoJSONSourceComponent._removeFeature(this.feature);
    }
    updateCoordinates(coordinates) {
        this.feature.geometry.coordinates = coordinates;
        this.GeoJSONSourceComponent.updateFeatureData.next();
    }
}
FeatureComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-feature',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
FeatureComponent.ctorParameters = () => [
    { type: GeoJSONSourceComponent, decorators: [{ type: Inject, args: [forwardRef(() => GeoJSONSourceComponent),] }] }
];
FeatureComponent.propDecorators = {
    id: [{ type: Input }],
    geometry: [{ type: Input }],
    properties: [{ type: Input }]
};

class DraggableDirective {
    constructor(MapService, NgZone, FeatureComponent) {
        this.MapService = MapService;
        this.NgZone = NgZone;
        this.FeatureComponent = FeatureComponent;
        this.featureDragStart = new EventEmitter();
        this.featureDragEnd = new EventEmitter();
        this.featureDrag = new EventEmitter();
        /**
         * @deprecated Use featureDragStart instead
         */
        this.dragStart = new EventEmitter();
        /**
         * @deprecated Use featureDragEnd instead
         */
        this.dragEnd = new EventEmitter();
        /**
         * @deprecated Use featureDrag instead
         */
        this.drag = new EventEmitter();
        this.sub = new Subscription();
    }
    ngOnInit() {
        this.warnDeprecatedOutputs();
        let enter$;
        let leave$;
        let updateCoords;
        if (this.FeatureComponent && this.layer) {
            enter$ = this.layer.layerMouseEnter;
            leave$ = this.layer.layerMouseLeave;
            updateCoords = this.FeatureComponent.updateCoordinates.bind(this.FeatureComponent);
            if (this.FeatureComponent.geometry.type !== 'Point') {
                throw new Error('mglDraggable only support point feature');
            }
        }
        else {
            throw new Error('mglDraggable can only be used on Feature (with a layer as input) or Marker');
        }
        this.handleDraggable(enter$, leave$, updateCoords);
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    handleDraggable(enter$, leave$, updateCoords) {
        let moving = false;
        let inside = false;
        this.MapService.mapCreated$.subscribe(() => {
            const mouseUp$ = fromEvent(this.MapService.mapInstance, 'mouseup');
            const dragStart$ = enter$.pipe(filter(() => !moving), filter((evt) => this.filterFeature(evt)), tap(() => {
                inside = true;
                this.MapService.changeCanvasCursor('move');
                this.MapService.updateDragPan(false);
            }), switchMap(() => fromEvent(this.MapService.mapInstance, 'mousedown').pipe(takeUntil(leave$))));
            const dragging$ = dragStart$.pipe(switchMap(() => fromEvent(this.MapService.mapInstance, 'mousemove').pipe(takeUntil(mouseUp$))));
            const dragEnd$ = dragStart$.pipe(switchMap(() => mouseUp$.pipe(take(1))));
            this.sub.add(dragStart$.subscribe((evt) => {
                moving = true;
                if (this.featureDragStart.observers.length ||
                    this.dragStart.observers.length) {
                    this.NgZone.run(() => {
                        this.featureDragStart.emit(evt);
                        this.dragStart.emit(evt);
                    });
                }
            }));
            this.sub.add(dragging$.subscribe((evt) => {
                updateCoords([evt.lngLat.lng, evt.lngLat.lat]);
                if (this.featureDrag.observers.length || this.drag.observers.length) {
                    this.NgZone.run(() => {
                        this.featureDrag.emit(evt);
                        this.drag.emit(evt);
                    });
                }
            }));
            this.sub.add(dragEnd$.subscribe((evt) => {
                moving = false;
                if (this.featureDragEnd.observers.length ||
                    this.dragEnd.observers.length) {
                    this.NgZone.run(() => {
                        this.featureDragEnd.emit(evt);
                        this.dragEnd.emit(evt);
                    });
                }
                if (!inside) {
                    // It's possible to dragEnd outside the target (small input lag)
                    this.MapService.changeCanvasCursor('');
                    this.MapService.updateDragPan(true);
                }
            }));
            this.sub.add(leave$
                .pipe(tap(() => (inside = false)), filter(() => !moving))
                .subscribe(() => {
                this.MapService.changeCanvasCursor('');
                this.MapService.updateDragPan(true);
            }));
        });
    }
    filterFeature(evt) {
        if (this.FeatureComponent && this.layer) {
            const feature = this.MapService.queryRenderedFeatures(evt.point, {
                layers: [this.layer.id],
                filter: [
                    'all',
                    ['==', '$type', 'Point'],
                    ['==', '$id', this.FeatureComponent.id],
                ],
            })[0];
            if (!feature) {
                return false;
            }
        }
        return true;
    }
    warnDeprecatedOutputs() {
        const dw = deprecationWarning.bind(undefined, DraggableDirective.name);
        if (this.dragStart.observers.length) {
            dw('dragStart', 'featureDragStart');
        }
        if (this.dragEnd.observers.length) {
            dw('dragEnd', 'featureDragEnd');
        }
        if (this.drag.observers.length) {
            dw('drag', 'featureDrag');
        }
    }
}
DraggableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mglDraggable]',
            },] }
];
DraggableDirective.ctorParameters = () => [
    { type: MapService },
    { type: NgZone },
    { type: FeatureComponent, decorators: [{ type: Optional }, { type: Host }] }
];
DraggableDirective.propDecorators = {
    layer: [{ type: Input, args: ['mglDraggable',] }],
    featureDragStart: [{ type: Output }],
    featureDragEnd: [{ type: Output }],
    featureDrag: [{ type: Output }],
    dragStart: [{ type: Output }],
    dragEnd: [{ type: Output }],
    drag: [{ type: Output }]
};

class ImageComponent {
    constructor(MapService, zone) {
        this.MapService = MapService;
        this.zone = zone;
        this.imageError = new EventEmitter();
        this.imageLoaded = new EventEmitter();
        /**
         * @deprecated Use imageError instead
         */
        this.error = new EventEmitter();
        /**
         * @deprecated Use imageLoaded instead
         */
        this.loaded = new EventEmitter();
        this.isAdded = false;
        this.isAdding = false;
    }
    ngOnInit() {
        this.warnDeprecatedOutputs();
        this.sub = this.MapService.mapLoaded$
            .pipe(switchMap(() => fromEvent(this.MapService.mapInstance, 'styledata').pipe(startWith(undefined), filter(() => !this.isAdding && !this.MapService.mapInstance.hasImage(this.id)))))
            .subscribe(() => this.init());
    }
    ngOnChanges(changes) {
        if ((changes.data && !changes.data.isFirstChange()) ||
            (changes.options && !changes.options.isFirstChange()) ||
            (changes.url && !changes.url.isFirstChange())) {
            this.ngOnDestroy();
            this.ngOnInit();
        }
    }
    ngOnDestroy() {
        if (this.isAdded) {
            this.MapService.removeImage(this.id);
        }
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isAdding = true;
            if (this.data) {
                this.MapService.addImage(this.id, this.data, this.options);
                this.isAdded = true;
                this.isAdding = false;
            }
            else if (this.url) {
                try {
                    yield this.MapService.loadAndAddImage(this.id, this.url, this.options);
                    this.isAdded = true;
                    this.isAdding = false;
                    this.zone.run(() => {
                        this.imageLoaded.emit();
                        this.loaded.emit();
                    });
                }
                catch (error) {
                    this.zone.run(() => {
                        this.imageError.emit(error);
                        this.error.emit(error);
                    });
                }
            }
        });
    }
    warnDeprecatedOutputs() {
        const dw = deprecationWarning.bind(undefined, ImageComponent.name);
        if (this.error.observers.length) {
            dw('error', 'imageError');
        }
        if (this.loaded.observers.length) {
            dw('loaded', 'imageLoaded');
        }
    }
}
ImageComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-image',
                template: ''
            },] }
];
ImageComponent.ctorParameters = () => [
    { type: MapService },
    { type: NgZone }
];
ImageComponent.propDecorators = {
    id: [{ type: Input }],
    data: [{ type: Input }],
    options: [{ type: Input }],
    url: [{ type: Input }],
    imageError: [{ type: Output }],
    imageLoaded: [{ type: Output }],
    error: [{ type: Output }],
    loaded: [{ type: Output }]
};

class MapComponent {
    constructor(MapService) {
        this.MapService = MapService;
        /* Added by ngx-mapbox-gl */
        this.movingMethod = 'flyTo';
        this.mapResize = new EventEmitter();
        this.mapRemove = new EventEmitter();
        this.mapMouseDown = new EventEmitter();
        this.mapMouseUp = new EventEmitter();
        this.mapMouseMove = new EventEmitter();
        this.mapClick = new EventEmitter();
        this.mapDblClick = new EventEmitter();
        this.mapMouseOver = new EventEmitter();
        this.mapMouseOut = new EventEmitter();
        this.mapContextMenu = new EventEmitter();
        this.mapTouchStart = new EventEmitter();
        this.mapTouchEnd = new EventEmitter();
        this.mapTouchMove = new EventEmitter();
        this.mapTouchCancel = new EventEmitter();
        this.mapWheel = new EventEmitter();
        this.moveStart = new EventEmitter();
        this.move = new EventEmitter();
        this.moveEnd = new EventEmitter();
        this.mapDragStart = new EventEmitter();
        this.mapDrag = new EventEmitter();
        this.mapDragEnd = new EventEmitter();
        this.zoomStart = new EventEmitter();
        this.zoomEvt = new EventEmitter();
        this.zoomEnd = new EventEmitter();
        this.rotateStart = new EventEmitter();
        this.rotate = new EventEmitter();
        this.rotateEnd = new EventEmitter();
        this.pitchStart = new EventEmitter();
        this.pitchEvt = new EventEmitter();
        this.pitchEnd = new EventEmitter();
        this.boxZoomStart = new EventEmitter();
        this.boxZoomEnd = new EventEmitter();
        this.boxZoomCancel = new EventEmitter();
        this.webGlContextLost = new EventEmitter();
        this.webGlContextRestored = new EventEmitter();
        this.mapLoad = new EventEmitter();
        this.idle = new EventEmitter();
        this.render = new EventEmitter();
        this.mapError = new EventEmitter();
        this.data = new EventEmitter();
        this.styleData = new EventEmitter();
        this.sourceData = new EventEmitter();
        this.dataLoading = new EventEmitter();
        this.styleDataLoading = new EventEmitter();
        this.sourceDataLoading = new EventEmitter();
        this.styleImageMissing = new EventEmitter();
        /**
         * @deprecated Use mapResize instead
         */
        this.resize = new EventEmitter();
        /**
         * @deprecated Use mapRemove instead
         */
        this.remove = new EventEmitter();
        /**
         * @deprecated Use mapMouseDown instead
         */
        this.mouseDown = new EventEmitter();
        /**
         * @deprecated Use mapMouseUp instead
         */
        this.mouseUp = new EventEmitter();
        /**
         * @deprecated Use mapMouseMove instead
         */
        this.mouseMove = new EventEmitter();
        /**
         * @deprecated Use mapClick instead
         */
        this.click = new EventEmitter();
        /**
         * @deprecated Use mapDblClick instead
         */
        this.dblClick = new EventEmitter();
        /**
         * @deprecated Use mapMouseOver instead
         */
        this.mouseOver = new EventEmitter();
        /**
         * @deprecated Use mapMouseOut instead
         */
        this.mouseOut = new EventEmitter();
        /**
         * @deprecated Use mapContextMenu instead
         */
        this.contextMenu = new EventEmitter();
        /**
         * @deprecated Use mapTouchStart instead
         */
        this.touchStart = new EventEmitter();
        /**
         * @deprecated Use mapTouchEnd instead
         */
        this.touchEnd = new EventEmitter();
        /**
         * @deprecated Use mapTouchMove instead
         */
        this.touchMove = new EventEmitter();
        /**
         * @deprecated Use mapTouchCancel instead
         */
        this.touchCancel = new EventEmitter();
        /**
         * @deprecated Use mapWheel instead
         */
        this.wheel = new EventEmitter();
        /**
         * @deprecated Use mapDragStart instead
         */
        this.dragStart = new EventEmitter();
        /**
         * @deprecated Use mapDrag instead
         */
        this.drag = new EventEmitter();
        /**
         * @deprecated Use mapDragEnd instead
         */
        this.dragEnd = new EventEmitter();
        /**
         * @deprecated Use mapLoad instead
         */
        this.load = new EventEmitter();
        /**
         * @deprecated Use mapError instead
         */
        this.error = new EventEmitter();
    }
    get mapInstance() {
        return this.MapService.mapInstance;
    }
    ngAfterViewInit() {
        this.warnDeprecatedOutputs();
        this.MapService.setup({
            accessToken: this.accessToken,
            customMapboxApiUrl: this.customMapboxApiUrl,
            mapOptions: {
                collectResourceTiming: this.collectResourceTiming,
                container: this.mapContainer.nativeElement,
                crossSourceCollisions: this.crossSourceCollisions,
                fadeDuration: this.fadeDuration,
                minZoom: this.minZoom,
                maxZoom: this.maxZoom,
                minPitch: this.minPitch,
                maxPitch: this.maxPitch,
                style: this.style,
                hash: this.hash,
                interactive: this.interactive,
                bearingSnap: this.bearingSnap,
                pitchWithRotate: this.pitchWithRotate,
                clickTolerance: this.clickTolerance,
                attributionControl: this.attributionControl,
                logoPosition: this.logoPosition,
                failIfMajorPerformanceCaveat: this.failIfMajorPerformanceCaveat,
                preserveDrawingBuffer: this.preserveDrawingBuffer,
                refreshExpiredTiles: this.refreshExpiredTiles,
                maxBounds: this.maxBounds,
                scrollZoom: this.scrollZoom,
                boxZoom: this.boxZoom,
                dragRotate: this.dragRotate,
                dragPan: this.dragPan,
                keyboard: this.keyboard,
                doubleClickZoom: this.doubleClickZoom,
                touchPitch: this.touchPitch,
                touchZoomRotate: this.touchZoomRotate,
                trackResize: this.trackResize,
                center: this.center,
                zoom: this.zoom,
                bearing: this.bearing,
                pitch: this.pitch,
                renderWorldCopies: this.renderWorldCopies,
                maxTileCacheSize: this.maxTileCacheSize,
                localIdeographFontFamily: this.localIdeographFontFamily,
                transformRequest: this.transformRequest,
                bounds: this.bounds ? this.bounds : this.fitBounds,
                fitBoundsOptions: this.fitBoundsOptions,
                antialias: this.antialias,
                locale: this.locale,
            },
            mapEvents: this,
        });
        if (this.cursorStyle) {
            this.MapService.changeCanvasCursor(this.cursorStyle);
        }
    }
    ngOnDestroy() {
        this.MapService.destroyMap();
    }
    ngOnChanges(changes) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.MapService.mapCreated$.toPromise();
            if (changes.cursorStyle && !changes.cursorStyle.isFirstChange()) {
                this.MapService.changeCanvasCursor(changes.cursorStyle.currentValue);
            }
            if (changes.minZoom && !changes.minZoom.isFirstChange()) {
                this.MapService.updateMinZoom(changes.minZoom.currentValue);
            }
            if (changes.maxZoom && !changes.maxZoom.isFirstChange()) {
                this.MapService.updateMaxZoom(changes.maxZoom.currentValue);
            }
            if (changes.minPitch && !changes.minPitch.isFirstChange()) {
                this.MapService.updateMinPitch(changes.minPitch.currentValue);
            }
            if (changes.maxPitch && !changes.maxPitch.isFirstChange()) {
                this.MapService.updateMaxPitch(changes.maxPitch.currentValue);
            }
            if (changes.renderWorldCopies &&
                !changes.renderWorldCopies.isFirstChange()) {
                this.MapService.updateRenderWorldCopies(changes.renderWorldCopies.currentValue);
            }
            if (changes.scrollZoom && !changes.scrollZoom.isFirstChange()) {
                this.MapService.updateScrollZoom(changes.scrollZoom.currentValue);
            }
            if (changes.dragRotate && !changes.dragRotate.isFirstChange()) {
                this.MapService.updateDragRotate(changes.dragRotate.currentValue);
            }
            if (changes.touchPitch && !changes.touchPitch.isFirstChange()) {
                this.MapService.updateTouchPitch(changes.touchPitch.currentValue);
            }
            if (changes.touchZoomRotate && !changes.touchZoomRotate.isFirstChange()) {
                this.MapService.updateTouchZoomRotate(changes.touchZoomRotate.currentValue);
            }
            if (changes.doubleClickZoom && !changes.doubleClickZoom.isFirstChange()) {
                this.MapService.updateDoubleClickZoom(changes.doubleClickZoom.currentValue);
            }
            if (changes.keyboard && !changes.keyboard.isFirstChange()) {
                this.MapService.updateKeyboard(changes.keyboard.currentValue);
            }
            if (changes.dragPan && !changes.dragPan.isFirstChange()) {
                this.MapService.updateDragPan(changes.dragPan.currentValue);
            }
            if (changes.boxZoom && !changes.boxZoom.isFirstChange()) {
                this.MapService.updateBoxZoom(changes.boxZoom.currentValue);
            }
            if (changes.style && !changes.style.isFirstChange()) {
                this.MapService.updateStyle(changes.style.currentValue);
            }
            if (changes.maxBounds && !changes.maxBounds.isFirstChange()) {
                this.MapService.updateMaxBounds(changes.maxBounds.currentValue);
            }
            if (changes.fitBounds &&
                changes.fitBounds.currentValue &&
                !changes.fitBounds.isFirstChange()) {
                this.MapService.fitBounds(changes.fitBounds.currentValue, this.fitBoundsOptions);
            }
            if (changes.fitScreenCoordinates &&
                changes.fitScreenCoordinates.currentValue) {
                if ((this.center || this.zoom || this.pitch || this.fitBounds) &&
                    changes.fitScreenCoordinates.isFirstChange()) {
                    console.warn('[ngx-mapbox-gl] center / zoom / pitch / fitBounds inputs are being overridden by fitScreenCoordinates input');
                }
                this.MapService.fitScreenCoordinates(changes.fitScreenCoordinates.currentValue, this.bearing ? this.bearing[0] : 0, this.movingOptions);
            }
            if (this.centerWithPanTo &&
                changes.center &&
                !changes.center.isFirstChange() &&
                !changes.zoom &&
                !changes.bearing &&
                !changes.pitch) {
                this.MapService.panTo(this.center, this.panToOptions);
            }
            else if ((changes.center && !changes.center.isFirstChange()) ||
                (changes.zoom && !changes.zoom.isFirstChange()) ||
                (changes.bearing &&
                    !changes.bearing.isFirstChange() &&
                    !changes.fitScreenCoordinates) ||
                (changes.pitch && !changes.pitch.isFirstChange())) {
                this.MapService.move(this.movingMethod, this.movingOptions, changes.zoom && this.zoom ? this.zoom[0] : undefined, changes.center ? this.center : undefined, changes.bearing && this.bearing ? this.bearing[0] : undefined, changes.pitch && this.pitch ? this.pitch[0] : undefined);
            }
        });
    }
    warnDeprecatedOutputs() {
        const dw = deprecationWarning.bind(undefined, MapComponent.name);
        if (this.resize.observers.length) {
            dw('resize', 'mapResize');
        }
        if (this.remove.observers.length) {
            dw('remove', 'mapRemove');
        }
        if (this.mouseDown.observers.length) {
            dw('mouseDown', 'mapMouseDown');
        }
        if (this.mouseUp.observers.length) {
            dw('mouseUp', 'mapMouseUp');
        }
        if (this.mouseMove.observers.length) {
            dw('mouseMove', 'mapMouseMove');
        }
        if (this.click.observers.length) {
            dw('click', 'mapClick');
        }
        if (this.dblClick.observers.length) {
            dw('dblClick', 'mapDblClick');
        }
        if (this.mouseOver.observers.length) {
            dw('mouseOver', 'mapMouseOver');
        }
        if (this.mouseOut.observers.length) {
            dw('mouseOut', 'mapMouseOut');
        }
        if (this.contextMenu.observers.length) {
            dw('contextMenu', 'mapContextMenu');
        }
        if (this.touchStart.observers.length) {
            dw('touchStart', 'mapTouchStart');
        }
        if (this.touchEnd.observers.length) {
            dw('touchEnd', 'mapTouchEnd');
        }
        if (this.touchMove.observers.length) {
            dw('touchMove', 'mapTouchMove');
        }
        if (this.touchCancel.observers.length) {
            dw('touchCancel', 'mapTouchCancel');
        }
        if (this.wheel.observers.length) {
            dw('wheel', 'mapWheel');
        }
        if (this.dragStart.observers.length) {
            dw('dragStart', 'mapDragStart');
        }
        if (this.drag.observers.length) {
            dw('drag', 'mapDrag');
        }
        if (this.dragEnd.observers.length) {
            dw('dragEnd', 'mapDragEnd');
        }
        if (this.load.observers.length) {
            dw('load', 'mapLoad');
        }
        if (this.error.observers.length) {
            dw('error', 'mapError');
        }
    }
}
MapComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-map',
                template: '<div #container></div>',
                providers: [MapService],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
      :host {
        display: block;
      }
      div {
        height: 100%;
        width: 100%;
      }
    `]
            },] }
];
MapComponent.ctorParameters = () => [
    { type: MapService }
];
MapComponent.propDecorators = {
    accessToken: [{ type: Input }],
    collectResourceTiming: [{ type: Input }],
    crossSourceCollisions: [{ type: Input }],
    customMapboxApiUrl: [{ type: Input }],
    fadeDuration: [{ type: Input }],
    hash: [{ type: Input }],
    refreshExpiredTiles: [{ type: Input }],
    failIfMajorPerformanceCaveat: [{ type: Input }],
    bearingSnap: [{ type: Input }],
    interactive: [{ type: Input }],
    pitchWithRotate: [{ type: Input }],
    clickTolerance: [{ type: Input }],
    attributionControl: [{ type: Input }],
    logoPosition: [{ type: Input }],
    maxTileCacheSize: [{ type: Input }],
    localIdeographFontFamily: [{ type: Input }],
    preserveDrawingBuffer: [{ type: Input }],
    trackResize: [{ type: Input }],
    transformRequest: [{ type: Input }],
    bounds: [{ type: Input }],
    antialias: [{ type: Input }],
    locale: [{ type: Input }],
    minZoom: [{ type: Input }],
    maxZoom: [{ type: Input }],
    minPitch: [{ type: Input }],
    maxPitch: [{ type: Input }],
    scrollZoom: [{ type: Input }],
    dragRotate: [{ type: Input }],
    touchPitch: [{ type: Input }],
    touchZoomRotate: [{ type: Input }],
    doubleClickZoom: [{ type: Input }],
    keyboard: [{ type: Input }],
    dragPan: [{ type: Input }],
    boxZoom: [{ type: Input }],
    style: [{ type: Input }],
    center: [{ type: Input }],
    maxBounds: [{ type: Input }],
    zoom: [{ type: Input }],
    bearing: [{ type: Input }],
    pitch: [{ type: Input }],
    fitBoundsOptions: [{ type: Input }],
    renderWorldCopies: [{ type: Input }],
    movingMethod: [{ type: Input }],
    movingOptions: [{ type: Input }],
    fitBounds: [{ type: Input }],
    fitScreenCoordinates: [{ type: Input }],
    centerWithPanTo: [{ type: Input }],
    panToOptions: [{ type: Input }],
    cursorStyle: [{ type: Input }],
    mapResize: [{ type: Output }],
    mapRemove: [{ type: Output }],
    mapMouseDown: [{ type: Output }],
    mapMouseUp: [{ type: Output }],
    mapMouseMove: [{ type: Output }],
    mapClick: [{ type: Output }],
    mapDblClick: [{ type: Output }],
    mapMouseOver: [{ type: Output }],
    mapMouseOut: [{ type: Output }],
    mapContextMenu: [{ type: Output }],
    mapTouchStart: [{ type: Output }],
    mapTouchEnd: [{ type: Output }],
    mapTouchMove: [{ type: Output }],
    mapTouchCancel: [{ type: Output }],
    mapWheel: [{ type: Output }],
    moveStart: [{ type: Output }],
    move: [{ type: Output }],
    moveEnd: [{ type: Output }],
    mapDragStart: [{ type: Output }],
    mapDrag: [{ type: Output }],
    mapDragEnd: [{ type: Output }],
    zoomStart: [{ type: Output }],
    zoomEvt: [{ type: Output }],
    zoomEnd: [{ type: Output }],
    rotateStart: [{ type: Output }],
    rotate: [{ type: Output }],
    rotateEnd: [{ type: Output }],
    pitchStart: [{ type: Output }],
    pitchEvt: [{ type: Output }],
    pitchEnd: [{ type: Output }],
    boxZoomStart: [{ type: Output }],
    boxZoomEnd: [{ type: Output }],
    boxZoomCancel: [{ type: Output }],
    webGlContextLost: [{ type: Output }],
    webGlContextRestored: [{ type: Output }],
    mapLoad: [{ type: Output }],
    idle: [{ type: Output }],
    render: [{ type: Output }],
    mapError: [{ type: Output }],
    data: [{ type: Output }],
    styleData: [{ type: Output }],
    sourceData: [{ type: Output }],
    dataLoading: [{ type: Output }],
    styleDataLoading: [{ type: Output }],
    sourceDataLoading: [{ type: Output }],
    styleImageMissing: [{ type: Output }],
    resize: [{ type: Output }],
    remove: [{ type: Output }],
    mouseDown: [{ type: Output }],
    mouseUp: [{ type: Output }],
    mouseMove: [{ type: Output }],
    click: [{ type: Output }],
    dblClick: [{ type: Output }],
    mouseOver: [{ type: Output }],
    mouseOut: [{ type: Output }],
    contextMenu: [{ type: Output }],
    touchStart: [{ type: Output }],
    touchEnd: [{ type: Output }],
    touchMove: [{ type: Output }],
    touchCancel: [{ type: Output }],
    wheel: [{ type: Output }],
    dragStart: [{ type: Output }],
    drag: [{ type: Output }],
    dragEnd: [{ type: Output }],
    load: [{ type: Output }],
    error: [{ type: Output }],
    mapContainer: [{ type: ViewChild, args: ['container', { static: true },] }]
};

class MarkerComponent {
    constructor(MapService) {
        this.MapService = MapService;
        this.markerDragStart = new EventEmitter();
        this.markerDragEnd = new EventEmitter();
        this.markerDrag = new EventEmitter();
        /**
         * @deprecated Use markerDragStart instead
         */
        this.dragStart = new EventEmitter();
        /**
         * @deprecated Use markerDragEnd instead
         */
        this.dragEnd = new EventEmitter();
        /**
         * @deprecated Use markerDrag instead
         */
        this.drag = new EventEmitter();
    }
    ngOnInit() {
        this.warnDeprecatedOutputs();
        if (this.feature && this.lngLat) {
            throw new Error('feature and lngLat input are mutually exclusive');
        }
    }
    ngOnChanges(changes) {
        if (changes.lngLat && !changes.lngLat.isFirstChange()) {
            this.markerInstance.setLngLat(this.lngLat);
        }
        if (changes.feature && !changes.feature.isFirstChange()) {
            this.markerInstance.setLngLat(this.feature.geometry.coordinates);
        }
        if (changes.draggable && !changes.draggable.isFirstChange()) {
            this.markerInstance.setDraggable(!!this.draggable);
        }
        if (changes.popupShown && !changes.popupShown.isFirstChange()) {
            changes.popupShown.currentValue
                ? this.markerInstance.getPopup().addTo(this.MapService.mapInstance)
                : this.markerInstance.getPopup().remove();
        }
        if (changes.pitchAlignment && !changes.pitchAlignment.isFirstChange()) {
            this.markerInstance.setPitchAlignment(changes.pitchAlignment.currentValue);
        }
        if (changes.rotationAlignment &&
            !changes.rotationAlignment.isFirstChange()) {
            this.markerInstance.setRotationAlignment(changes.rotationAlignment.currentValue);
        }
    }
    ngAfterViewInit() {
        this.MapService.mapCreated$.subscribe(() => {
            this.markerInstance = this.MapService.addMarker({
                markersOptions: {
                    offset: this.offset,
                    anchor: this.anchor,
                    pitchAlignment: this.pitchAlignment,
                    rotationAlignment: this.rotationAlignment,
                    draggable: !!this.draggable,
                    element: this.content.nativeElement,
                    feature: this.feature,
                    lngLat: this.lngLat,
                    clickTolerance: this.clickTolerance,
                },
                markersEvents: {
                    markerDragStart: this.markerDragStart,
                    markerDrag: this.markerDrag,
                    markerDragEnd: this.markerDragEnd,
                    dragStart: this.dragStart,
                    drag: this.drag,
                    dragEnd: this.dragEnd,
                },
            });
        });
    }
    ngOnDestroy() {
        this.MapService.removeMarker(this.markerInstance);
        this.markerInstance = undefined;
    }
    togglePopup() {
        this.markerInstance.togglePopup();
    }
    updateCoordinates(coordinates) {
        this.markerInstance.setLngLat(coordinates);
    }
    warnDeprecatedOutputs() {
        const dw = deprecationWarning.bind(undefined, MarkerComponent.name);
        if (this.dragStart.observers.length) {
            dw('dragStart', 'markerDragStart');
        }
        if (this.dragEnd.observers.length) {
            dw('dragEnd', 'markerDragEnd');
        }
        if (this.drag.observers.length) {
            dw('drag', 'markerDrag');
        }
    }
}
MarkerComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-marker',
                template: '<div [class]="className" #content><ng-content></ng-content></div>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
MarkerComponent.ctorParameters = () => [
    { type: MapService }
];
MarkerComponent.propDecorators = {
    offset: [{ type: Input }],
    anchor: [{ type: Input }],
    clickTolerance: [{ type: Input }],
    feature: [{ type: Input }],
    lngLat: [{ type: Input }],
    draggable: [{ type: Input }],
    popupShown: [{ type: Input }],
    className: [{ type: Input }],
    pitchAlignment: [{ type: Input }],
    rotationAlignment: [{ type: Input }],
    markerDragStart: [{ type: Output }],
    markerDragEnd: [{ type: Output }],
    markerDrag: [{ type: Output }],
    dragStart: [{ type: Output }],
    dragEnd: [{ type: Output }],
    drag: [{ type: Output }],
    content: [{ type: ViewChild, args: ['content', { static: true },] }]
};

class PointDirective {
}
PointDirective.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[mglPoint]' },] }
];
class ClusterPointDirective {
}
ClusterPointDirective.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[mglClusterPoint]' },] }
];
let uniqId = 0;
class MarkersForClustersComponent {
    constructor(MapService, ChangeDetectorRef, zone) {
        this.MapService = MapService;
        this.ChangeDetectorRef = ChangeDetectorRef;
        this.zone = zone;
        this.layerId = `mgl-markers-for-clusters-${uniqId++}`;
        this.sub = new Subscription();
    }
    ngAfterContentInit() {
        const clusterDataUpdate = () => fromEvent(this.MapService.mapInstance, 'data').pipe(filter((e) => e.sourceId === this.source &&
            e.sourceDataType !== 'metadata' &&
            this.MapService.mapInstance.isSourceLoaded(this.source)));
        const sub = this.MapService.mapCreated$
            .pipe(switchMap(clusterDataUpdate), switchMap(() => merge(fromEvent(this.MapService.mapInstance, 'move'), fromEvent(this.MapService.mapInstance, 'moveend')).pipe(startWith(undefined))))
            .subscribe(() => {
            this.zone.run(() => {
                this.updateCluster();
            });
        });
        this.sub.add(sub);
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    trackByClusterPoint(_index, clusterPoint) {
        return clusterPoint.id;
    }
    updateCluster() {
        // Invalid queryRenderedFeatures typing
        const params = { layers: [this.layerId] };
        if (!this.pointTpl) {
            params.filter = ['==', 'cluster', true];
        }
        this.clusterPoints = this.MapService.mapInstance.queryRenderedFeatures(params);
        this.ChangeDetectorRef.markForCheck();
    }
}
MarkersForClustersComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-markers-for-clusters',
                template: `
    <mgl-layer
      [id]="layerId"
      [source]="source"
      type="circle"
      [paint]="{ 'circle-radius': 0 }"
    ></mgl-layer>
    <ng-container
      *ngFor="let feature of clusterPoints; trackBy: trackByClusterPoint"
    >
      <ng-container *ngIf="feature.properties.cluster">
        <mgl-marker [feature]="feature">
          <ng-container
            *ngTemplateOutlet="clusterPointTpl; context: { $implicit: feature }"
          ></ng-container>
        </mgl-marker>
      </ng-container>
      <ng-container *ngIf="!feature.properties.cluster">
        <mgl-marker [feature]="feature">
          <ng-container
            *ngTemplateOutlet="pointTpl; context: { $implicit: feature }"
          ></ng-container>
        </mgl-marker>
      </ng-container>
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            },] }
];
MarkersForClustersComponent.ctorParameters = () => [
    { type: MapService },
    { type: ChangeDetectorRef },
    { type: NgZone }
];
MarkersForClustersComponent.propDecorators = {
    source: [{ type: Input }],
    pointTpl: [{ type: ContentChild, args: [PointDirective, { read: TemplateRef, static: false },] }],
    clusterPointTpl: [{ type: ContentChild, args: [ClusterPointDirective, { read: TemplateRef, static: false },] }]
};

class PopupComponent {
    constructor(MapService) {
        this.MapService = MapService;
        this.popupClose = new EventEmitter();
        this.popupOpen = new EventEmitter();
        /**
         * @deprecated Use popupClose instead
         */
        this.close = new EventEmitter();
        /**
         * @deprecated Use popupOpen instead
         */
        this.open = new EventEmitter();
    }
    ngOnInit() {
        this.warnDeprecatedOutputs();
        if ((this.lngLat && this.marker) ||
            (this.feature && this.lngLat) ||
            (this.feature && this.marker)) {
            throw new Error('marker, lngLat, feature input are mutually exclusive');
        }
    }
    ngOnChanges(changes) {
        if ((changes.lngLat && !changes.lngLat.isFirstChange()) ||
            (changes.feature && !changes.feature.isFirstChange())) {
            const newlngLat = changes.lngLat
                ? this.lngLat
                : this.feature.geometry.coordinates;
            this.MapService.removePopupFromMap(this.popupInstance, true);
            const popupInstanceTmp = this.createPopup();
            this.MapService.addPopupToMap(popupInstanceTmp, newlngLat, this.popupInstance.isOpen());
            this.popupInstance = popupInstanceTmp;
        }
        if (changes.marker && !changes.marker.isFirstChange()) {
            const previousMarker = changes.marker.previousValue;
            if (previousMarker.markerInstance) {
                this.MapService.removePopupFromMarker(previousMarker.markerInstance);
            }
            if (this.marker && this.marker.markerInstance && this.popupInstance) {
                this.MapService.addPopupToMarker(this.marker.markerInstance, this.popupInstance);
            }
        }
        if (changes.offset &&
            !changes.offset.isFirstChange() &&
            this.popupInstance) {
            this.popupInstance.setOffset(this.offset);
        }
    }
    ngAfterViewInit() {
        this.popupInstance = this.createPopup();
        this.addPopup(this.popupInstance);
    }
    ngOnDestroy() {
        if (this.popupInstance) {
            if (this.lngLat || this.feature) {
                this.MapService.removePopupFromMap(this.popupInstance);
            }
            else if (this.marker && this.marker.markerInstance) {
                this.MapService.removePopupFromMarker(this.marker.markerInstance);
            }
        }
        this.popupInstance = undefined;
    }
    createPopup() {
        return this.MapService.createPopup({
            popupOptions: {
                closeButton: this.closeButton,
                closeOnClick: this.closeOnClick,
                anchor: this.anchor,
                offset: this.offset,
                className: this.className,
                maxWidth: this.maxWidth,
            },
            popupEvents: {
                open: this.open,
                close: this.close,
                popupOpen: this.popupOpen,
                popupClose: this.popupClose,
            },
        }, this.content.nativeElement);
    }
    addPopup(popup) {
        this.MapService.mapCreated$.subscribe(() => {
            if (this.lngLat || this.feature) {
                this.MapService.addPopupToMap(popup, this.lngLat
                    ? this.lngLat
                    : this.feature.geometry.coordinates);
            }
            else if (this.marker && this.marker.markerInstance) {
                this.MapService.addPopupToMarker(this.marker.markerInstance, popup);
            }
            else {
                throw new Error('mgl-popup need either lngLat/marker/feature to be set');
            }
        });
    }
    warnDeprecatedOutputs() {
        const dw = deprecationWarning.bind(undefined, PopupComponent.name);
        if (this.close.observers.length) {
            dw('close', 'popupClose');
        }
        if (this.open.observers.length) {
            dw('open', 'popupOpen');
        }
    }
}
PopupComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-popup',
                template: '<div #content><ng-content></ng-content></div>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
PopupComponent.ctorParameters = () => [
    { type: MapService }
];
PopupComponent.propDecorators = {
    closeButton: [{ type: Input }],
    closeOnClick: [{ type: Input }],
    anchor: [{ type: Input }],
    className: [{ type: Input }],
    maxWidth: [{ type: Input }],
    feature: [{ type: Input }],
    lngLat: [{ type: Input }],
    marker: [{ type: Input }],
    offset: [{ type: Input }],
    popupClose: [{ type: Output }],
    popupOpen: [{ type: Output }],
    close: [{ type: Output }],
    open: [{ type: Output }],
    content: [{ type: ViewChild, args: ['content', { static: true },] }]
};

class CanvasSourceComponent {
    constructor(MapService) {
        this.MapService = MapService;
        this.sourceAdded = false;
        this.sub = new Subscription();
    }
    ngOnInit() {
        const sub1 = this.MapService.mapLoaded$.subscribe(() => {
            this.init();
            const sub = fromEvent(this.MapService.mapInstance, 'styledata')
                .pipe(filter(() => !this.MapService.mapInstance.getSource(this.id)))
                .subscribe(() => {
                this.init();
            });
            this.sub.add(sub);
        });
        this.sub.add(sub1);
    }
    ngOnChanges(changes) {
        if (!this.sourceAdded) {
            return;
        }
        if ((changes.canvas && !changes.canvas.isFirstChange()) ||
            (changes.animate && !changes.animate.isFirstChange())) {
            this.ngOnDestroy();
            this.ngOnInit();
        }
        else if (changes.coordinates && !changes.coordinates.isFirstChange()) {
            const source = this.MapService.getSource(this.id);
            source.setCoordinates(this.coordinates);
        }
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
        if (this.sourceAdded) {
            this.MapService.removeSource(this.id);
            this.sourceAdded = false;
        }
    }
    init() {
        const source = {
            type: 'canvas',
            coordinates: this.coordinates,
            canvas: this.canvas,
            animate: this.animate,
        };
        this.MapService.addSource(this.id, source);
        this.sourceAdded = true;
    }
}
CanvasSourceComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-canvas-source',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
CanvasSourceComponent.ctorParameters = () => [
    { type: MapService }
];
CanvasSourceComponent.propDecorators = {
    id: [{ type: Input }],
    coordinates: [{ type: Input }],
    canvas: [{ type: Input }],
    animate: [{ type: Input }]
};

class ImageSourceComponent {
    constructor(MapService) {
        this.MapService = MapService;
    }
    ngOnInit() {
        this.sub = this.MapService.mapLoaded$.subscribe(() => this.init());
    }
    ngOnChanges(changes) {
        if (this.sourceId === undefined) {
            return;
        }
        const source = this.MapService.getSource(this.sourceId);
        source.updateImage({
            url: changes.url === undefined ? undefined : this.url,
            coordinates: changes.coordinates === undefined ? undefined : this.coordinates,
        });
    }
    ngOnDestroy() {
        if (this.sub !== undefined) {
            this.sub.unsubscribe();
        }
        if (this.sourceId !== undefined) {
            this.MapService.removeSource(this.sourceId);
            this.sourceId = undefined;
        }
    }
    init() {
        const imageSource = {
            type: 'image',
            url: this.url,
            coordinates: this.coordinates,
        };
        this.MapService.addSource(this.id, imageSource);
        this.sourceId = this.id;
    }
}
ImageSourceComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-image-source',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ImageSourceComponent.ctorParameters = () => [
    { type: MapService }
];
ImageSourceComponent.propDecorators = {
    id: [{ type: Input }],
    url: [{ type: Input }],
    coordinates: [{ type: Input }]
};

class RasterDemSourceComponent {
    constructor(MapService) {
        this.MapService = MapService;
        this.type = 'raster-dem';
        this.sourceAdded = false;
        this.sub = new Subscription();
    }
    ngOnInit() {
        const sub1 = this.MapService.mapLoaded$.subscribe(() => {
            this.init();
            const sub = fromEvent(this.MapService.mapInstance, 'styledata')
                .pipe(filter(() => !this.MapService.mapInstance.getSource(this.id)))
                .subscribe(() => {
                this.init();
            });
            this.sub.add(sub);
        });
        this.sub.add(sub1);
    }
    ngOnChanges(changes) {
        if (!this.sourceAdded) {
            return;
        }
        if ((changes.url && !changes.url.isFirstChange()) ||
            (changes.tiles && !changes.tiles.isFirstChange()) ||
            (changes.bounds && !changes.bounds.isFirstChange()) ||
            (changes.minzoom && !changes.minzoom.isFirstChange()) ||
            (changes.maxzoom && !changes.maxzoom.isFirstChange()) ||
            (changes.tileSize && !changes.tileSize.isFirstChange()) ||
            (changes.attribution && !changes.attribution.isFirstChange()) ||
            (changes.encoding && !changes.encoding.isFirstChange())) {
            this.ngOnDestroy();
            this.ngOnInit();
        }
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
        if (this.sourceAdded) {
            this.MapService.removeSource(this.id);
            this.sourceAdded = false;
        }
    }
    init() {
        const source = {
            type: this.type,
            url: this.url,
            tiles: this.tiles,
            bounds: this.bounds,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            tileSize: this.tileSize,
            attribution: this.attribution,
            encoding: this.encoding,
        };
        this.MapService.addSource(this.id, source);
        this.sourceAdded = true;
    }
}
RasterDemSourceComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-raster-dem-source',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
RasterDemSourceComponent.ctorParameters = () => [
    { type: MapService }
];
RasterDemSourceComponent.propDecorators = {
    id: [{ type: Input }],
    url: [{ type: Input }],
    tiles: [{ type: Input }],
    bounds: [{ type: Input }],
    minzoom: [{ type: Input }],
    maxzoom: [{ type: Input }],
    tileSize: [{ type: Input }],
    attribution: [{ type: Input }],
    encoding: [{ type: Input }]
};

class RasterSourceComponent {
    constructor(MapService) {
        this.MapService = MapService;
        this.type = 'raster';
        this.sourceAdded = false;
        this.sub = new Subscription();
    }
    ngOnInit() {
        const sub1 = this.MapService.mapLoaded$.subscribe(() => {
            this.init();
            const sub = fromEvent(this.MapService.mapInstance, 'styledata')
                .pipe(filter(() => !this.MapService.mapInstance.getSource(this.id)))
                .subscribe(() => {
                this.init();
            });
            this.sub.add(sub);
        });
        this.sub.add(sub1);
    }
    ngOnChanges(changes) {
        if (!this.sourceAdded) {
            return;
        }
        if ((changes.url && !changes.url.isFirstChange()) ||
            (changes.tiles && !changes.tiles.isFirstChange()) ||
            (changes.bounds && !changes.bounds.isFirstChange()) ||
            (changes.minzoom && !changes.minzoom.isFirstChange()) ||
            (changes.maxzoom && !changes.maxzoom.isFirstChange()) ||
            (changes.tileSize && !changes.tileSize.isFirstChange()) ||
            (changes.scheme && !changes.scheme.isFirstChange()) ||
            (changes.attribution && !changes.attribution.isFirstChange())) {
            this.ngOnDestroy();
            this.ngOnInit();
        }
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
        if (this.sourceAdded) {
            this.MapService.removeSource(this.id);
            this.sourceAdded = false;
        }
    }
    init() {
        const source = {
            type: this.type,
            url: this.url,
            tiles: this.tiles,
            bounds: this.bounds,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            tileSize: this.tileSize,
            scheme: this.scheme,
            attribution: this.attribution,
        };
        this.MapService.addSource(this.id, source);
        this.sourceAdded = true;
    }
}
RasterSourceComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-raster-source',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
RasterSourceComponent.ctorParameters = () => [
    { type: MapService }
];
RasterSourceComponent.propDecorators = {
    id: [{ type: Input }],
    url: [{ type: Input }],
    tiles: [{ type: Input }],
    bounds: [{ type: Input }],
    minzoom: [{ type: Input }],
    maxzoom: [{ type: Input }],
    tileSize: [{ type: Input }],
    scheme: [{ type: Input }],
    attribution: [{ type: Input }]
};

class VectorSourceComponent {
    constructor(MapService) {
        this.MapService = MapService;
        this.type = 'vector';
        this.sourceAdded = false;
        this.sub = new Subscription();
    }
    ngOnInit() {
        const sub1 = this.MapService.mapLoaded$.subscribe(() => {
            this.init();
            const sub = fromEvent(this.MapService.mapInstance, 'styledata')
                .pipe(filter(() => !this.MapService.mapInstance.getSource(this.id)))
                .subscribe(() => {
                this.init();
            });
            this.sub.add(sub);
        });
        this.sub.add(sub1);
    }
    ngOnChanges(changes) {
        if (!this.sourceAdded) {
            return;
        }
        if ((changes.bounds && !changes.bounds.isFirstChange()) ||
            (changes.scheme && !changes.scheme.isFirstChange()) ||
            (changes.minzoom && !changes.minzoom.isFirstChange()) ||
            (changes.maxzoom && !changes.maxzoom.isFirstChange()) ||
            (changes.attribution && !changes.attribution.isFirstChange()) ||
            (changes.promoteId && !changes.promoteId.isFirstChange())) {
            this.ngOnDestroy();
            this.ngOnInit();
        }
        else if ((changes.url && !changes.url.isFirstChange()) ||
            (changes.tiles && !changes.tiles.isFirstChange())) {
            const source = this.MapService.getSource(this.id);
            if (changes.url && this.url) {
                source.setUrl(this.url);
            }
            if (changes.tiles && this.tiles) {
                source.setTiles(this.tiles);
            }
        }
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
        if (this.sourceAdded) {
            this.MapService.removeSource(this.id);
            this.sourceAdded = false;
        }
    }
    init() {
        const source = {
            type: this.type,
            url: this.url,
            tiles: this.tiles,
            bounds: this.bounds,
            scheme: this.scheme,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            attribution: this.attribution,
            promoteId: this.promoteId,
        };
        this.MapService.addSource(this.id, source);
        this.sourceAdded = true;
    }
}
VectorSourceComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-vector-source',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
VectorSourceComponent.ctorParameters = () => [
    { type: MapService }
];
VectorSourceComponent.propDecorators = {
    id: [{ type: Input }],
    url: [{ type: Input }],
    tiles: [{ type: Input }],
    bounds: [{ type: Input }],
    scheme: [{ type: Input }],
    minzoom: [{ type: Input }],
    maxzoom: [{ type: Input }],
    attribution: [{ type: Input }],
    promoteId: [{ type: Input }]
};

class VideoSourceComponent {
    constructor(MapService) {
        this.MapService = MapService;
        this.sourceAdded = false;
        this.sub = new Subscription();
    }
    ngOnInit() {
        const sub1 = this.MapService.mapLoaded$.subscribe(() => {
            this.init();
            const sub = fromEvent(this.MapService.mapInstance, 'styledata')
                .pipe(filter(() => !this.MapService.mapInstance.getSource(this.id)))
                .subscribe(() => {
                this.init();
            });
            this.sub.add(sub);
        });
        this.sub.add(sub1);
    }
    ngOnChanges(changes) {
        if (!this.sourceAdded) {
            return;
        }
        if (changes.urls && !changes.urls.isFirstChange()) {
            this.ngOnDestroy();
            this.ngOnInit();
        }
        else if (changes.coordinates && !changes.coordinates.isFirstChange()) {
            const source = this.MapService.getSource(this.id);
            source.setCoordinates(this.coordinates);
        }
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
        if (this.sourceAdded) {
            this.MapService.removeSource(this.id);
            this.sourceAdded = false;
        }
    }
    init() {
        const source = {
            type: 'video',
            urls: this.urls,
            coordinates: this.coordinates,
        };
        this.MapService.addSource(this.id, source);
        this.sourceAdded = true;
    }
}
VideoSourceComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-video-source',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
VideoSourceComponent.ctorParameters = () => [
    { type: MapService }
];
VideoSourceComponent.propDecorators = {
    id: [{ type: Input }],
    urls: [{ type: Input }],
    coordinates: [{ type: Input }]
};

class NgxMapboxGLModule {
    static withConfig(config) {
        return {
            ngModule: NgxMapboxGLModule,
            providers: [
                {
                    provide: MAPBOX_API_KEY,
                    useValue: config.accessToken,
                },
                {
                    provide: MAPBOX_GEOCODER_API_KEY,
                    useValue: config.geocoderAccessToken || config.accessToken,
                },
            ],
        };
    }
}
NgxMapboxGLModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [
                    MapComponent,
                    LayerComponent,
                    DraggableDirective,
                    ImageComponent,
                    VectorSourceComponent,
                    GeoJSONSourceComponent,
                    RasterDemSourceComponent,
                    RasterSourceComponent,
                    ImageSourceComponent,
                    VideoSourceComponent,
                    CanvasSourceComponent,
                    FeatureComponent,
                    MarkerComponent,
                    PopupComponent,
                    ControlComponent,
                    FullscreenControlDirective,
                    NavigationControlDirective,
                    GeocoderControlDirective,
                    GeolocateControlDirective,
                    AttributionControlDirective,
                    ScaleControlDirective,
                    PointDirective,
                    ClusterPointDirective,
                    MarkersForClustersComponent,
                ],
                exports: [
                    MapComponent,
                    LayerComponent,
                    DraggableDirective,
                    ImageComponent,
                    VectorSourceComponent,
                    GeoJSONSourceComponent,
                    RasterDemSourceComponent,
                    RasterSourceComponent,
                    ImageSourceComponent,
                    VideoSourceComponent,
                    CanvasSourceComponent,
                    FeatureComponent,
                    MarkerComponent,
                    PopupComponent,
                    ControlComponent,
                    FullscreenControlDirective,
                    NavigationControlDirective,
                    GeocoderControlDirective,
                    GeolocateControlDirective,
                    AttributionControlDirective,
                    ScaleControlDirective,
                    PointDirective,
                    ClusterPointDirective,
                    MarkersForClustersComponent,
                ],
            },] }
];

/*
 * Public API Surface of ngx-mapbox-gl
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ControlComponent, CustomControl, GeoJSONSourceComponent, MAPBOX_API_KEY, MAPBOX_GEOCODER_API_KEY, MapComponent, MapService, NgxMapboxGLModule, GeocoderControlDirective as ɵa, LayerComponent as ɵb, DraggableDirective as ɵc, FeatureComponent as ɵd, ImageComponent as ɵe, VectorSourceComponent as ɵf, RasterDemSourceComponent as ɵg, RasterSourceComponent as ɵh, ImageSourceComponent as ɵi, VideoSourceComponent as ɵj, CanvasSourceComponent as ɵk, MarkerComponent as ɵl, PopupComponent as ɵm, FullscreenControlDirective as ɵn, NavigationControlDirective as ɵo, GeolocateControlDirective as ɵp, AttributionControlDirective as ɵq, ScaleControlDirective as ɵr, PointDirective as ɵs, ClusterPointDirective as ɵt, MarkersForClustersComponent as ɵu };
//# sourceMappingURL=ngx-mapbox-gl.js.map
