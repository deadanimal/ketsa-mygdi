import { Directive, EventEmitter, Host, Input, NgZone, Optional, Output, } from '@angular/core';
import { fromEvent, Subscription } from 'rxjs';
import { filter, switchMap, take, takeUntil, tap } from 'rxjs/operators';
import { LayerComponent } from '../layer/layer.component';
import { MapService } from '../map/map.service';
import { FeatureComponent } from '../source/geojson/feature.component';
import { deprecationWarning } from '../utils';
export class DraggableDirective {
    constructor(MapService, NgZone, FeatureComponent) {
        this.MapService = MapService;
        this.NgZone = NgZone;
        this.FeatureComponent = FeatureComponent;
        this.featureDragStart = new EventEmitter();
        this.featureDragEnd = new EventEmitter();
        this.featureDrag = new EventEmitter();
        /**
         * @deprecated Use featureDragStart instead
         */
        this.dragStart = new EventEmitter();
        /**
         * @deprecated Use featureDragEnd instead
         */
        this.dragEnd = new EventEmitter();
        /**
         * @deprecated Use featureDrag instead
         */
        this.drag = new EventEmitter();
        this.sub = new Subscription();
    }
    ngOnInit() {
        this.warnDeprecatedOutputs();
        let enter$;
        let leave$;
        let updateCoords;
        if (this.FeatureComponent && this.layer) {
            enter$ = this.layer.layerMouseEnter;
            leave$ = this.layer.layerMouseLeave;
            updateCoords = this.FeatureComponent.updateCoordinates.bind(this.FeatureComponent);
            if (this.FeatureComponent.geometry.type !== 'Point') {
                throw new Error('mglDraggable only support point feature');
            }
        }
        else {
            throw new Error('mglDraggable can only be used on Feature (with a layer as input) or Marker');
        }
        this.handleDraggable(enter$, leave$, updateCoords);
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    handleDraggable(enter$, leave$, updateCoords) {
        let moving = false;
        let inside = false;
        this.MapService.mapCreated$.subscribe(() => {
            const mouseUp$ = fromEvent(this.MapService.mapInstance, 'mouseup');
            const dragStart$ = enter$.pipe(filter(() => !moving), filter((evt) => this.filterFeature(evt)), tap(() => {
                inside = true;
                this.MapService.changeCanvasCursor('move');
                this.MapService.updateDragPan(false);
            }), switchMap(() => fromEvent(this.MapService.mapInstance, 'mousedown').pipe(takeUntil(leave$))));
            const dragging$ = dragStart$.pipe(switchMap(() => fromEvent(this.MapService.mapInstance, 'mousemove').pipe(takeUntil(mouseUp$))));
            const dragEnd$ = dragStart$.pipe(switchMap(() => mouseUp$.pipe(take(1))));
            this.sub.add(dragStart$.subscribe((evt) => {
                moving = true;
                if (this.featureDragStart.observers.length ||
                    this.dragStart.observers.length) {
                    this.NgZone.run(() => {
                        this.featureDragStart.emit(evt);
                        this.dragStart.emit(evt);
                    });
                }
            }));
            this.sub.add(dragging$.subscribe((evt) => {
                updateCoords([evt.lngLat.lng, evt.lngLat.lat]);
                if (this.featureDrag.observers.length || this.drag.observers.length) {
                    this.NgZone.run(() => {
                        this.featureDrag.emit(evt);
                        this.drag.emit(evt);
                    });
                }
            }));
            this.sub.add(dragEnd$.subscribe((evt) => {
                moving = false;
                if (this.featureDragEnd.observers.length ||
                    this.dragEnd.observers.length) {
                    this.NgZone.run(() => {
                        this.featureDragEnd.emit(evt);
                        this.dragEnd.emit(evt);
                    });
                }
                if (!inside) {
                    // It's possible to dragEnd outside the target (small input lag)
                    this.MapService.changeCanvasCursor('');
                    this.MapService.updateDragPan(true);
                }
            }));
            this.sub.add(leave$
                .pipe(tap(() => (inside = false)), filter(() => !moving))
                .subscribe(() => {
                this.MapService.changeCanvasCursor('');
                this.MapService.updateDragPan(true);
            }));
        });
    }
    filterFeature(evt) {
        if (this.FeatureComponent && this.layer) {
            const feature = this.MapService.queryRenderedFeatures(evt.point, {
                layers: [this.layer.id],
                filter: [
                    'all',
                    ['==', '$type', 'Point'],
                    ['==', '$id', this.FeatureComponent.id],
                ],
            })[0];
            if (!feature) {
                return false;
            }
        }
        return true;
    }
    warnDeprecatedOutputs() {
        const dw = deprecationWarning.bind(undefined, DraggableDirective.name);
        if (this.dragStart.observers.length) {
            dw('dragStart', 'featureDragStart');
        }
        if (this.dragEnd.observers.length) {
            dw('dragEnd', 'featureDragEnd');
        }
        if (this.drag.observers.length) {
            dw('drag', 'featureDrag');
        }
    }
}
DraggableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mglDraggable]',
            },] }
];
DraggableDirective.ctorParameters = () => [
    { type: MapService },
    { type: NgZone },
    { type: FeatureComponent, decorators: [{ type: Optional }, { type: Host }] }
];
DraggableDirective.propDecorators = {
    layer: [{ type: Input, args: ['mglDraggable',] }],
    featureDragStart: [{ type: Output }],
    featureDragEnd: [{ type: Output }],
    featureDrag: [{ type: Output }],
    dragStart: [{ type: Output }],
    dragEnd: [{ type: Output }],
    drag: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZ2dhYmxlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1tYXBib3gtZ2wvc3JjL2xpYi9kcmFnZ2FibGUvZHJhZ2dhYmxlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFlBQVksRUFDWixJQUFJLEVBQ0osS0FBSyxFQUNMLE1BQU0sRUFHTixRQUFRLEVBQ1IsTUFBTSxHQUNQLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxTQUFTLEVBQWMsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNELE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzFELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNoRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN2RSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFLOUMsTUFBTSxPQUFPLGtCQUFrQjtJQXNCN0IsWUFDVSxVQUFzQixFQUN0QixNQUFjLEVBQ00sZ0JBQW1DO1FBRnZELGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNNLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBbUI7UUFyQnZELHFCQUFnQixHQUFHLElBQUksWUFBWSxFQUFpQixDQUFDO1FBQ3JELG1CQUFjLEdBQUcsSUFBSSxZQUFZLEVBQWlCLENBQUM7UUFDbkQsZ0JBQVcsR0FBRyxJQUFJLFlBQVksRUFBaUIsQ0FBQztRQUMxRDs7V0FFRztRQUNPLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBaUIsQ0FBQztRQUN4RDs7V0FFRztRQUNPLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBaUIsQ0FBQztRQUN0RDs7V0FFRztRQUNPLFNBQUksR0FBRyxJQUFJLFlBQVksRUFBaUIsQ0FBQztRQUUzQyxRQUFHLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztJQU05QixDQUFDO0lBRUosUUFBUTtRQUNOLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBQzdCLElBQUksTUFBTSxDQUFDO1FBQ1gsSUFBSSxNQUFNLENBQUM7UUFDWCxJQUFJLFlBQVksQ0FBQztRQUNqQixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ3ZDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQztZQUNwQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUM7WUFDcEMsWUFBWSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQ3pELElBQUksQ0FBQyxnQkFBZ0IsQ0FDdEIsQ0FBQztZQUNGLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUFFO2dCQUNuRCxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7YUFDNUQ7U0FDRjthQUFNO1lBQ0wsTUFBTSxJQUFJLEtBQUssQ0FDYiw0RUFBNEUsQ0FDN0UsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRU8sZUFBZSxDQUNyQixNQUFpQyxFQUNqQyxNQUFpQyxFQUNqQyxZQUF1QztRQUV2QyxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDekMsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUNuQixJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFDaEMsU0FBUyxDQUNWLENBQUM7WUFDRixNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUM1QixNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFDckIsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQ3hDLEdBQUcsQ0FBQyxHQUFHLEVBQUU7Z0JBQ1AsTUFBTSxHQUFHLElBQUksQ0FBQztnQkFDZCxJQUFJLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUMzQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN2QyxDQUFDLENBQUMsRUFDRixTQUFTLENBQUMsR0FBRyxFQUFFLENBQ2IsU0FBUyxDQUNGLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUNoQyxXQUFXLENBQ1osQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQzFCLENBQ0YsQ0FBQztZQUNGLE1BQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQy9CLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FDYixTQUFTLENBQ0YsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQ2hDLFdBQVcsQ0FDWixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FDNUIsQ0FDRixDQUFDO1lBQ0YsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQ1YsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO2dCQUMzQixNQUFNLEdBQUcsSUFBSSxDQUFDO2dCQUNkLElBQ0UsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxNQUFNO29CQUN0QyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQy9CO29CQUNBLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTt3QkFDbkIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDaEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQzNCLENBQUMsQ0FBQyxDQUFDO2lCQUNKO1lBQ0gsQ0FBQyxDQUFDLENBQ0gsQ0FBQztZQUNGLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUNWLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtnQkFDMUIsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUMvQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUU7b0JBQ25FLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTt3QkFDbkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN0QixDQUFDLENBQUMsQ0FBQztpQkFDSjtZQUNILENBQUMsQ0FBQyxDQUNILENBQUM7WUFDRixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FDVixRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7Z0JBQ3pCLE1BQU0sR0FBRyxLQUFLLENBQUM7Z0JBQ2YsSUFDRSxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxNQUFNO29CQUNwQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQzdCO29CQUNBLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTt3QkFDbkIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQzlCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN6QixDQUFDLENBQUMsQ0FBQztpQkFDSjtnQkFDRCxJQUFJLENBQUMsTUFBTSxFQUFFO29CQUNYLGdFQUFnRTtvQkFDaEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDdkMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ3JDO1lBQ0gsQ0FBQyxDQUFDLENBQ0gsQ0FBQztZQUNGLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUNWLE1BQU07aUJBQ0gsSUFBSSxDQUNILEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUMzQixNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FDdEI7aUJBQ0EsU0FBUyxDQUFDLEdBQUcsRUFBRTtnQkFDZCxJQUFJLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUN2QyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0QyxDQUFDLENBQUMsQ0FDTCxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sYUFBYSxDQUFDLEdBQWtCO1FBQ3RDLElBQUksSUFBSSxDQUFDLGdCQUFnQixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDdkMsTUFBTSxPQUFPLEdBQXlCLElBQUksQ0FBQyxVQUFVLENBQUMscUJBQXFCLENBQ3pFLEdBQUcsQ0FBQyxLQUFLLEVBQ1Q7Z0JBQ0UsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQ3ZCLE1BQU0sRUFBRTtvQkFDTixLQUFLO29CQUNMLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUM7b0JBQ3hCLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO2lCQUN4QzthQUNGLENBQ0YsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNMLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ1osT0FBTyxLQUFLLENBQUM7YUFDZDtTQUNGO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU8scUJBQXFCO1FBQzNCLE1BQU0sRUFBRSxHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkUsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUU7WUFDbkMsRUFBRSxDQUFDLFdBQVcsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1NBQ3JDO1FBQ0QsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUU7WUFDakMsRUFBRSxDQUFDLFNBQVMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1NBQ2pDO1FBQ0QsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUU7WUFDOUIsRUFBRSxDQUFDLE1BQU0sRUFBRSxhQUFhLENBQUMsQ0FBQztTQUMzQjtJQUNILENBQUM7OztZQXZMRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGdCQUFnQjthQUMzQjs7O1lBTlEsVUFBVTtZQVZqQixNQUFNO1lBV0MsZ0JBQWdCLHVCQStCcEIsUUFBUSxZQUFJLElBQUk7OztvQkF2QmxCLEtBQUssU0FBQyxjQUFjOytCQUVwQixNQUFNOzZCQUNOLE1BQU07MEJBQ04sTUFBTTt3QkFJTixNQUFNO3NCQUlOLE1BQU07bUJBSU4sTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgRGlyZWN0aXZlLFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBIb3N0LFxyXG4gIElucHV0LFxyXG4gIE5nWm9uZSxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT25Jbml0LFxyXG4gIE9wdGlvbmFsLFxyXG4gIE91dHB1dCxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTWFwTW91c2VFdmVudCB9IGZyb20gJ21hcGJveC1nbCc7XHJcbmltcG9ydCB7IGZyb21FdmVudCwgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGZpbHRlciwgc3dpdGNoTWFwLCB0YWtlLCB0YWtlVW50aWwsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgTGF5ZXJDb21wb25lbnQgfSBmcm9tICcuLi9sYXllci9sYXllci5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgRmVhdHVyZUNvbXBvbmVudCB9IGZyb20gJy4uL3NvdXJjZS9nZW9qc29uL2ZlYXR1cmUuY29tcG9uZW50JztcclxuaW1wb3J0IHsgZGVwcmVjYXRpb25XYXJuaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbbWdsRHJhZ2dhYmxlXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBEcmFnZ2FibGVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWlucHV0LXJlbmFtZVxyXG4gIEBJbnB1dCgnbWdsRHJhZ2dhYmxlJykgbGF5ZXI/OiBMYXllckNvbXBvbmVudDtcclxuXHJcbiAgQE91dHB1dCgpIGZlYXR1cmVEcmFnU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPE1hcE1vdXNlRXZlbnQ+KCk7XHJcbiAgQE91dHB1dCgpIGZlYXR1cmVEcmFnRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxNYXBNb3VzZUV2ZW50PigpO1xyXG4gIEBPdXRwdXQoKSBmZWF0dXJlRHJhZyA9IG5ldyBFdmVudEVtaXR0ZXI8TWFwTW91c2VFdmVudD4oKTtcclxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZmVhdHVyZURyYWdTdGFydCBpbnN0ZWFkXHJcbiAgICovXHJcbiAgQE91dHB1dCgpIGRyYWdTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXI8TWFwTW91c2VFdmVudD4oKTtcclxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZmVhdHVyZURyYWdFbmQgaW5zdGVhZFxyXG4gICAqL1xyXG4gIEBPdXRwdXQoKSBkcmFnRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxNYXBNb3VzZUV2ZW50PigpO1xyXG4gIC8qKlxyXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmZWF0dXJlRHJhZyBpbnN0ZWFkXHJcbiAgICovXHJcbiAgQE91dHB1dCgpIGRyYWcgPSBuZXcgRXZlbnRFbWl0dGVyPE1hcE1vdXNlRXZlbnQ+KCk7XHJcblxyXG4gIHByaXZhdGUgc3ViID0gbmV3IFN1YnNjcmlwdGlvbigpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgTWFwU2VydmljZTogTWFwU2VydmljZSxcclxuICAgIHByaXZhdGUgTmdab25lOiBOZ1pvbmUsXHJcbiAgICBAT3B0aW9uYWwoKSBASG9zdCgpIHByaXZhdGUgRmVhdHVyZUNvbXBvbmVudD86IEZlYXR1cmVDb21wb25lbnRcclxuICApIHt9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gICAgdGhpcy53YXJuRGVwcmVjYXRlZE91dHB1dHMoKTtcclxuICAgIGxldCBlbnRlciQ7XHJcbiAgICBsZXQgbGVhdmUkO1xyXG4gICAgbGV0IHVwZGF0ZUNvb3JkcztcclxuICAgIGlmICh0aGlzLkZlYXR1cmVDb21wb25lbnQgJiYgdGhpcy5sYXllcikge1xyXG4gICAgICBlbnRlciQgPSB0aGlzLmxheWVyLmxheWVyTW91c2VFbnRlcjtcclxuICAgICAgbGVhdmUkID0gdGhpcy5sYXllci5sYXllck1vdXNlTGVhdmU7XHJcbiAgICAgIHVwZGF0ZUNvb3JkcyA9IHRoaXMuRmVhdHVyZUNvbXBvbmVudC51cGRhdGVDb29yZGluYXRlcy5iaW5kKFxyXG4gICAgICAgIHRoaXMuRmVhdHVyZUNvbXBvbmVudFxyXG4gICAgICApO1xyXG4gICAgICBpZiAodGhpcy5GZWF0dXJlQ29tcG9uZW50Lmdlb21ldHJ5LnR5cGUgIT09ICdQb2ludCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21nbERyYWdnYWJsZSBvbmx5IHN1cHBvcnQgcG9pbnQgZmVhdHVyZScpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgJ21nbERyYWdnYWJsZSBjYW4gb25seSBiZSB1c2VkIG9uIEZlYXR1cmUgKHdpdGggYSBsYXllciBhcyBpbnB1dCkgb3IgTWFya2VyJ1xyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaGFuZGxlRHJhZ2dhYmxlKGVudGVyJCwgbGVhdmUkLCB1cGRhdGVDb29yZHMpO1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLnN1Yi51bnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVEcmFnZ2FibGUoXHJcbiAgICBlbnRlciQ6IE9ic2VydmFibGU8TWFwTW91c2VFdmVudD4sXHJcbiAgICBsZWF2ZSQ6IE9ic2VydmFibGU8TWFwTW91c2VFdmVudD4sXHJcbiAgICB1cGRhdGVDb29yZHM6IChjb29yZDogbnVtYmVyW10pID0+IHZvaWRcclxuICApIHtcclxuICAgIGxldCBtb3ZpbmcgPSBmYWxzZTtcclxuICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcclxuICAgIHRoaXMuTWFwU2VydmljZS5tYXBDcmVhdGVkJC5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb3VzZVVwJCA9IGZyb21FdmVudDxNYXBNb3VzZUV2ZW50PihcclxuICAgICAgICA8YW55PnRoaXMuTWFwU2VydmljZS5tYXBJbnN0YW5jZSxcclxuICAgICAgICAnbW91c2V1cCdcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgZHJhZ1N0YXJ0JCA9IGVudGVyJC5waXBlKFxyXG4gICAgICAgIGZpbHRlcigoKSA9PiAhbW92aW5nKSxcclxuICAgICAgICBmaWx0ZXIoKGV2dCkgPT4gdGhpcy5maWx0ZXJGZWF0dXJlKGV2dCkpLFxyXG4gICAgICAgIHRhcCgoKSA9PiB7XHJcbiAgICAgICAgICBpbnNpZGUgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5NYXBTZXJ2aWNlLmNoYW5nZUNhbnZhc0N1cnNvcignbW92ZScpO1xyXG4gICAgICAgICAgdGhpcy5NYXBTZXJ2aWNlLnVwZGF0ZURyYWdQYW4oZmFsc2UpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHN3aXRjaE1hcCgoKSA9PlxyXG4gICAgICAgICAgZnJvbUV2ZW50PE1hcE1vdXNlRXZlbnQ+KFxyXG4gICAgICAgICAgICA8YW55PnRoaXMuTWFwU2VydmljZS5tYXBJbnN0YW5jZSxcclxuICAgICAgICAgICAgJ21vdXNlZG93bidcclxuICAgICAgICAgICkucGlwZSh0YWtlVW50aWwobGVhdmUkKSlcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IGRyYWdnaW5nJCA9IGRyYWdTdGFydCQucGlwZShcclxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT5cclxuICAgICAgICAgIGZyb21FdmVudDxNYXBNb3VzZUV2ZW50PihcclxuICAgICAgICAgICAgPGFueT50aGlzLk1hcFNlcnZpY2UubWFwSW5zdGFuY2UsXHJcbiAgICAgICAgICAgICdtb3VzZW1vdmUnXHJcbiAgICAgICAgICApLnBpcGUodGFrZVVudGlsKG1vdXNlVXAkKSlcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IGRyYWdFbmQkID0gZHJhZ1N0YXJ0JC5waXBlKHN3aXRjaE1hcCgoKSA9PiBtb3VzZVVwJC5waXBlKHRha2UoMSkpKSk7XHJcbiAgICAgIHRoaXMuc3ViLmFkZChcclxuICAgICAgICBkcmFnU3RhcnQkLnN1YnNjcmliZSgoZXZ0KSA9PiB7XHJcbiAgICAgICAgICBtb3ZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVEcmFnU3RhcnQub2JzZXJ2ZXJzLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydC5vYnNlcnZlcnMubGVuZ3RoXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy5OZ1pvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVEcmFnU3RhcnQuZW1pdChldnQpO1xyXG4gICAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0LmVtaXQoZXZ0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5zdWIuYWRkKFxyXG4gICAgICAgIGRyYWdnaW5nJC5zdWJzY3JpYmUoKGV2dCkgPT4ge1xyXG4gICAgICAgICAgdXBkYXRlQ29vcmRzKFtldnQubG5nTGF0LmxuZywgZXZ0LmxuZ0xhdC5sYXRdKTtcclxuICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmVEcmFnLm9ic2VydmVycy5sZW5ndGggfHwgdGhpcy5kcmFnLm9ic2VydmVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5OZ1pvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVEcmFnLmVtaXQoZXZ0KTtcclxuICAgICAgICAgICAgICB0aGlzLmRyYWcuZW1pdChldnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgICB0aGlzLnN1Yi5hZGQoXHJcbiAgICAgICAgZHJhZ0VuZCQuc3Vic2NyaWJlKChldnQpID0+IHtcclxuICAgICAgICAgIG1vdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVEcmFnRW5kLm9ic2VydmVycy5sZW5ndGggfHxcclxuICAgICAgICAgICAgdGhpcy5kcmFnRW5kLm9ic2VydmVycy5sZW5ndGhcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB0aGlzLk5nWm9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMuZmVhdHVyZURyYWdFbmQuZW1pdChldnQpO1xyXG4gICAgICAgICAgICAgIHRoaXMuZHJhZ0VuZC5lbWl0KGV2dCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFpbnNpZGUpIHtcclxuICAgICAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0byBkcmFnRW5kIG91dHNpZGUgdGhlIHRhcmdldCAoc21hbGwgaW5wdXQgbGFnKVxyXG4gICAgICAgICAgICB0aGlzLk1hcFNlcnZpY2UuY2hhbmdlQ2FudmFzQ3Vyc29yKCcnKTtcclxuICAgICAgICAgICAgdGhpcy5NYXBTZXJ2aWNlLnVwZGF0ZURyYWdQYW4odHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5zdWIuYWRkKFxyXG4gICAgICAgIGxlYXZlJFxyXG4gICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgIHRhcCgoKSA9PiAoaW5zaWRlID0gZmFsc2UpKSxcclxuICAgICAgICAgICAgZmlsdGVyKCgpID0+ICFtb3ZpbmcpXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5NYXBTZXJ2aWNlLmNoYW5nZUNhbnZhc0N1cnNvcignJyk7XHJcbiAgICAgICAgICAgIHRoaXMuTWFwU2VydmljZS51cGRhdGVEcmFnUGFuKHRydWUpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBmaWx0ZXJGZWF0dXJlKGV2dDogTWFwTW91c2VFdmVudCkge1xyXG4gICAgaWYgKHRoaXMuRmVhdHVyZUNvbXBvbmVudCAmJiB0aGlzLmxheWVyKSB7XHJcbiAgICAgIGNvbnN0IGZlYXR1cmU6IEdlb0pTT04uRmVhdHVyZTxhbnk+ID0gdGhpcy5NYXBTZXJ2aWNlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhcclxuICAgICAgICBldnQucG9pbnQsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgbGF5ZXJzOiBbdGhpcy5sYXllci5pZF0sXHJcbiAgICAgICAgICBmaWx0ZXI6IFtcclxuICAgICAgICAgICAgJ2FsbCcsXHJcbiAgICAgICAgICAgIFsnPT0nLCAnJHR5cGUnLCAnUG9pbnQnXSxcclxuICAgICAgICAgICAgWyc9PScsICckaWQnLCB0aGlzLkZlYXR1cmVDb21wb25lbnQuaWRdLFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICB9XHJcbiAgICAgIClbMF07XHJcbiAgICAgIGlmICghZmVhdHVyZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHdhcm5EZXByZWNhdGVkT3V0cHV0cygpIHtcclxuICAgIGNvbnN0IGR3ID0gZGVwcmVjYXRpb25XYXJuaW5nLmJpbmQodW5kZWZpbmVkLCBEcmFnZ2FibGVEaXJlY3RpdmUubmFtZSk7XHJcbiAgICBpZiAodGhpcy5kcmFnU3RhcnQub2JzZXJ2ZXJzLmxlbmd0aCkge1xyXG4gICAgICBkdygnZHJhZ1N0YXJ0JywgJ2ZlYXR1cmVEcmFnU3RhcnQnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmRyYWdFbmQub2JzZXJ2ZXJzLmxlbmd0aCkge1xyXG4gICAgICBkdygnZHJhZ0VuZCcsICdmZWF0dXJlRHJhZ0VuZCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZHJhZy5vYnNlcnZlcnMubGVuZ3RoKSB7XHJcbiAgICAgIGR3KCdkcmFnJywgJ2ZlYXR1cmVEcmFnJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==