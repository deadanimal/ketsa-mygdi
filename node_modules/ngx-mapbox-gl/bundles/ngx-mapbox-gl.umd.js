(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('mapbox-gl'), require('rxjs'), require('rxjs/operators'), require('@mapbox/mapbox-gl-geocoder')) :
    typeof define === 'function' && define.amd ? define('ngx-mapbox-gl', ['exports', '@angular/common', '@angular/core', 'mapbox-gl', 'rxjs', 'rxjs/operators', '@mapbox/mapbox-gl-geocoder'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-mapbox-gl'] = {}, global.ng.common, global.ng.core, global.MapboxGl, global.rxjs, global.rxjs.operators, global.MapboxGeocoder));
}(this, (function (exports, common, core, MapboxGl, rxjs, operators, MapboxGeocoder) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var MapboxGl__namespace = /*#__PURE__*/_interopNamespace(MapboxGl);
    var MapboxGeocoder__default = /*#__PURE__*/_interopDefaultLegacy(MapboxGeocoder);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var MAPBOX_API_KEY = new core.InjectionToken('MapboxApiKey');
    var MapService = /** @class */ (function () {
        function MapService(zone, MAPBOX_API_KEY) {
            this.zone = zone;
            this.MAPBOX_API_KEY = MAPBOX_API_KEY;
            this.mapCreated = new rxjs.AsyncSubject();
            this.mapLoaded = new rxjs.AsyncSubject();
            this.markersToRemove = [];
            this.popupsToRemove = [];
            this.imageIdsToRemove = [];
            this.subscription = new rxjs.Subscription();
            this.mapCreated$ = this.mapCreated.asObservable();
            this.mapLoaded$ = this.mapLoaded.asObservable();
        }
        MapService.prototype.setup = function (options) {
            var _this = this;
            // Need onStable to wait for a potential @angular/route transition to end
            this.zone.onStable.pipe(operators.first()).subscribe(function () {
                // Workaround rollup issue
                _this.assign(MapboxGl__namespace, 'accessToken', options.accessToken || _this.MAPBOX_API_KEY);
                if (options.customMapboxApiUrl) {
                    _this.assign(MapboxGl__namespace, 'config.API_URL', options.customMapboxApiUrl);
                }
                _this.createMap(options.mapOptions);
                _this.hookEvents(options.mapEvents);
                _this.mapEvents = options.mapEvents;
                _this.mapCreated.next(undefined);
                _this.mapCreated.complete();
            });
        };
        MapService.prototype.destroyMap = function () {
            if (this.mapInstance) {
                this.subscription.unsubscribe();
                this.mapInstance.remove();
            }
        };
        MapService.prototype.updateMinZoom = function (minZoom) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.setMinZoom(minZoom);
            });
        };
        MapService.prototype.updateMaxZoom = function (maxZoom) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.setMaxZoom(maxZoom);
            });
        };
        MapService.prototype.updateMinPitch = function (minPitch) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.setMinPitch(minPitch);
            });
        };
        MapService.prototype.updateMaxPitch = function (maxPitch) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.setMaxPitch(maxPitch);
            });
        };
        MapService.prototype.updateRenderWorldCopies = function (status) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.setRenderWorldCopies(status);
            });
        };
        MapService.prototype.updateScrollZoom = function (status) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                status
                    ? _this.mapInstance.scrollZoom.enable()
                    : _this.mapInstance.scrollZoom.disable();
            });
        };
        MapService.prototype.updateDragRotate = function (status) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                status
                    ? _this.mapInstance.dragRotate.enable()
                    : _this.mapInstance.dragRotate.disable();
            });
        };
        MapService.prototype.updateTouchPitch = function (status) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                status
                    ? _this.mapInstance.touchPitch.enable()
                    : _this.mapInstance.touchPitch.disable();
            });
        };
        MapService.prototype.updateTouchZoomRotate = function (status) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                status
                    ? _this.mapInstance.touchZoomRotate.enable()
                    : _this.mapInstance.touchZoomRotate.disable();
            });
        };
        MapService.prototype.updateDoubleClickZoom = function (status) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                status
                    ? _this.mapInstance.doubleClickZoom.enable()
                    : _this.mapInstance.doubleClickZoom.disable();
            });
        };
        MapService.prototype.updateKeyboard = function (status) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                status
                    ? _this.mapInstance.keyboard.enable()
                    : _this.mapInstance.keyboard.disable();
            });
        };
        MapService.prototype.updateDragPan = function (status) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                status
                    ? _this.mapInstance.dragPan.enable()
                    : _this.mapInstance.dragPan.disable();
            });
        };
        MapService.prototype.updateBoxZoom = function (status) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                status
                    ? _this.mapInstance.boxZoom.enable()
                    : _this.mapInstance.boxZoom.disable();
            });
        };
        MapService.prototype.updateStyle = function (style) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.setStyle(style);
            });
        };
        MapService.prototype.updateMaxBounds = function (maxBounds) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.setMaxBounds(maxBounds);
            });
        };
        MapService.prototype.changeCanvasCursor = function (cursor) {
            var canvas = this.mapInstance.getCanvasContainer();
            canvas.style.cursor = cursor;
        };
        MapService.prototype.queryRenderedFeatures = function (pointOrBox, parameters) {
            return this.mapInstance.queryRenderedFeatures(pointOrBox, parameters);
        };
        MapService.prototype.panTo = function (center, options) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.panTo(center, options);
            });
        };
        MapService.prototype.move = function (movingMethod, movingOptions, zoom, center, bearing, pitch) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance[movingMethod](Object.assign(Object.assign({}, movingOptions), { zoom: zoom ? zoom : _this.mapInstance.getZoom(), center: center ? center : _this.mapInstance.getCenter(), bearing: bearing ? bearing : _this.mapInstance.getBearing(), pitch: pitch ? pitch : _this.mapInstance.getPitch() }));
            });
        };
        MapService.prototype.addLayer = function (layer, bindEvents, before) {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                Object.keys(layer.layerOptions).forEach(function (key) {
                    var tkey = key;
                    if (layer.layerOptions[tkey] === undefined) {
                        delete layer.layerOptions[tkey];
                    }
                });
                _this.mapInstance.addLayer(layer.layerOptions, before);
                if (bindEvents) {
                    if (layer.layerEvents.layerClick.observers.length ||
                        layer.layerEvents.click.observers.length) {
                        _this.mapInstance.on('click', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerClick.emit(evt);
                                layer.layerEvents.click.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerDblClick.observers.length ||
                        layer.layerEvents.dblClick.observers.length) {
                        _this.mapInstance.on('dblclick', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerDblClick.emit(evt);
                                layer.layerEvents.dblClick.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerMouseDown.observers.length ||
                        layer.layerEvents.mouseDown.observers.length) {
                        _this.mapInstance.on('mousedown', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerMouseDown.emit(evt);
                                layer.layerEvents.mouseDown.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerMouseUp.observers.length ||
                        layer.layerEvents.mouseUp.observers.length) {
                        _this.mapInstance.on('mouseup', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerMouseUp.emit(evt);
                                layer.layerEvents.mouseUp.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerMouseEnter.observers.length ||
                        layer.layerEvents.mouseEnter.observers.length) {
                        _this.mapInstance.on('mouseenter', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerMouseEnter.emit(evt);
                                layer.layerEvents.mouseEnter.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerMouseLeave.observers.length ||
                        layer.layerEvents.mouseLeave.observers.length) {
                        _this.mapInstance.on('mouseleave', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerMouseLeave.emit(evt);
                                layer.layerEvents.mouseLeave.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerMouseMove.observers.length ||
                        layer.layerEvents.mouseMove.observers.length) {
                        _this.mapInstance.on('mousemove', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerMouseMove.emit(evt);
                                layer.layerEvents.mouseMove.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerMouseOver.observers.length ||
                        layer.layerEvents.mouseOver.observers.length) {
                        _this.mapInstance.on('mouseover', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerMouseOver.emit(evt);
                                layer.layerEvents.mouseOver.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerMouseOut.observers.length ||
                        layer.layerEvents.mouseOut.observers.length) {
                        _this.mapInstance.on('mouseout', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerMouseOut.emit(evt);
                                layer.layerEvents.mouseOut.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerContextMenu.observers.length ||
                        layer.layerEvents.contextMenu.observers.length) {
                        _this.mapInstance.on('contextmenu', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerContextMenu.emit(evt);
                                layer.layerEvents.contextMenu.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerTouchStart.observers.length ||
                        layer.layerEvents.touchStart.observers.length) {
                        _this.mapInstance.on('touchstart', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerTouchStart.emit(evt);
                                layer.layerEvents.touchStart.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerTouchEnd.observers.length ||
                        layer.layerEvents.touchEnd.observers.length) {
                        _this.mapInstance.on('touchend', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerTouchEnd.emit(evt);
                                layer.layerEvents.touchEnd.emit(evt);
                            });
                        });
                    }
                    if (layer.layerEvents.layerTouchCancel.observers.length ||
                        layer.layerEvents.touchCancel.observers.length) {
                        _this.mapInstance.on('touchcancel', layer.layerOptions.id, function (evt) {
                            _this.zone.run(function () {
                                layer.layerEvents.layerTouchCancel.emit(evt);
                                layer.layerEvents.touchCancel.emit(evt);
                            });
                        });
                    }
                }
            });
        };
        MapService.prototype.removeLayer = function (layerId) {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                if (_this.mapInstance.getLayer(layerId) != null) {
                    _this.mapInstance.removeLayer(layerId);
                }
            });
        };
        MapService.prototype.addMarker = function (marker) {
            var _this = this;
            var options = {
                offset: marker.markersOptions.offset,
                anchor: marker.markersOptions.anchor,
                draggable: !!marker.markersOptions.draggable,
                rotationAlignment: marker.markersOptions.rotationAlignment,
                pitchAlignment: marker.markersOptions.pitchAlignment,
                clickTolerance: marker.markersOptions.clickTolerance,
            };
            if (marker.markersOptions.element.childNodes.length > 0) {
                options.element = marker.markersOptions.element;
            }
            var markerInstance = new MapboxGl.Marker(options);
            if (marker.markersEvents.markerDragStart.observers.length ||
                marker.markersEvents.dragStart.observers.length) {
                markerInstance.on('dragstart', function (event) {
                    if (event) {
                        var target_1 = event.target;
                        _this.zone.run(function () {
                            marker.markersEvents.markerDragStart.emit(target_1);
                            marker.markersEvents.dragStart.emit(target_1);
                        });
                    }
                });
            }
            /*
        
             */
            if (marker.markersEvents.markerDrag.observers.length ||
                marker.markersEvents.drag.observers.length) {
                markerInstance.on('drag', function (event) {
                    if (event) {
                        var target_2 = event.target;
                        _this.zone.run(function () {
                            marker.markersEvents.markerDrag.emit(target_2);
                            marker.markersEvents.drag.emit(target_2);
                        });
                    }
                });
            }
            if (marker.markersEvents.markerDragEnd.observers.length ||
                marker.markersEvents.dragEnd.observers.length) {
                markerInstance.on('dragend', function (event) {
                    if (event) {
                        var target_3 = event.target;
                        _this.zone.run(function () {
                            marker.markersEvents.markerDragEnd.emit(target_3);
                            marker.markersEvents.dragEnd.emit(target_3);
                        });
                    }
                });
            }
            var lngLat = marker.markersOptions.feature
                ? marker.markersOptions.feature.geometry.coordinates
                : marker.markersOptions.lngLat;
            markerInstance.setLngLat(lngLat);
            return this.zone.runOutsideAngular(function () {
                markerInstance.addTo(_this.mapInstance);
                return markerInstance;
            });
        };
        MapService.prototype.removeMarker = function (marker) {
            this.markersToRemove.push(marker);
        };
        MapService.prototype.createPopup = function (popup, element) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                Object.keys(popup.popupOptions).forEach(function (key) { return popup.popupOptions[key] === undefined &&
                    delete popup.popupOptions[key]; });
                var popupInstance = new MapboxGl.Popup(popup.popupOptions);
                popupInstance.setDOMContent(element);
                if (popup.popupEvents.popupClose.observers.length ||
                    popup.popupEvents.close.observers.length) {
                    popupInstance.on('close', function () {
                        _this.zone.run(function () {
                            popup.popupEvents.popupClose.emit();
                            popup.popupEvents.close.emit();
                        });
                    });
                }
                if (popup.popupEvents.popupOpen.observers.length ||
                    popup.popupEvents.open.observers.length) {
                    popupInstance.on('open', function () {
                        _this.zone.run(function () {
                            popup.popupEvents.popupOpen.emit();
                            popup.popupEvents.open.emit();
                        });
                    });
                }
                return popupInstance;
            });
        };
        MapService.prototype.addPopupToMap = function (popup, lngLat, skipOpenEvent) {
            var _this = this;
            if (skipOpenEvent === void 0) { skipOpenEvent = false; }
            return this.zone.runOutsideAngular(function () {
                if (skipOpenEvent && popup._listeners) {
                    delete popup._listeners['open'];
                }
                popup.setLngLat(lngLat);
                popup.addTo(_this.mapInstance);
            });
        };
        MapService.prototype.addPopupToMarker = function (marker, popup) {
            return this.zone.runOutsideAngular(function () {
                marker.setPopup(popup);
            });
        };
        MapService.prototype.removePopupFromMap = function (popup, skipCloseEvent) {
            if (skipCloseEvent === void 0) { skipCloseEvent = false; }
            if (skipCloseEvent && popup._listeners) {
                delete popup._listeners['close'];
            }
            this.popupsToRemove.push(popup);
        };
        MapService.prototype.removePopupFromMarker = function (marker) {
            return this.zone.runOutsideAngular(function () {
                marker.setPopup(undefined);
            });
        };
        MapService.prototype.addControl = function (control, position) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.addControl(control, position);
            });
        };
        MapService.prototype.removeControl = function (control) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.removeControl(control);
            });
        };
        MapService.prototype.loadAndAddImage = function (imageId, url, options) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.zone.runOutsideAngular(function () {
                            return new Promise(function (resolve, reject) {
                                _this.mapInstance.loadImage(url, function (error, image) {
                                    if (error) {
                                        reject(error);
                                        return;
                                    }
                                    _this.addImage(imageId, image, options);
                                    resolve();
                                });
                            });
                        })];
                });
            });
        };
        MapService.prototype.addImage = function (imageId, data, options) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.addImage(imageId, data, options);
            });
        };
        MapService.prototype.removeImage = function (imageId) {
            this.imageIdsToRemove.push(imageId);
        };
        MapService.prototype.addSource = function (sourceId, source) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                Object.keys(source).forEach(function (key) { return source[key] === undefined && delete source[key]; });
                _this.mapInstance.addSource(sourceId, source);
            });
        };
        MapService.prototype.getSource = function (sourceId) {
            return this.mapInstance.getSource(sourceId);
        };
        MapService.prototype.removeSource = function (sourceId) {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.findLayersBySourceId(sourceId).forEach(function (layer) { return _this.mapInstance.removeLayer(layer.id); });
                _this.mapInstance.removeSource(sourceId);
            });
        };
        MapService.prototype.setAllLayerPaintProperty = function (layerId, paint) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                Object.keys(paint).forEach(function (key) {
                    // TODO Check for perf, setPaintProperty only on changed paint props maybe
                    _this.mapInstance.setPaintProperty(layerId, key, paint[key]);
                });
            });
        };
        MapService.prototype.setAllLayerLayoutProperty = function (layerId, layout) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                Object.keys(layout).forEach(function (key) {
                    // TODO Check for perf, setPaintProperty only on changed paint props maybe
                    _this.mapInstance.setLayoutProperty(layerId, key, layout[key]);
                });
            });
        };
        MapService.prototype.setLayerFilter = function (layerId, filter) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.setFilter(layerId, filter);
            });
        };
        MapService.prototype.setLayerBefore = function (layerId, beforeId) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.moveLayer(layerId, beforeId);
            });
        };
        MapService.prototype.setLayerZoomRange = function (layerId, minZoom, maxZoom) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.setLayerZoomRange(layerId, minZoom ? minZoom : 0, maxZoom ? maxZoom : 20);
            });
        };
        MapService.prototype.fitBounds = function (bounds, options) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.fitBounds(bounds, options);
            });
        };
        MapService.prototype.fitScreenCoordinates = function (points, bearing, options) {
            var _this = this;
            return this.zone.runOutsideAngular(function () {
                _this.mapInstance.fitScreenCoordinates(points[0], points[1], bearing, options);
            });
        };
        MapService.prototype.applyChanges = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.removeMarkers();
                _this.removePopups();
                _this.removeImages();
            });
        };
        MapService.prototype.createMap = function (options) {
            var _this = this;
            core.NgZone.assertNotInAngularZone();
            Object.keys(options).forEach(function (key) {
                var tkey = key;
                if (options[tkey] === undefined) {
                    delete options[tkey];
                }
            });
            this.mapInstance = new MapboxGl.Map(options);
            var isIEorEdge = window && /msie\s|trident\/|edge\//i.test(window.navigator.userAgent);
            if (isIEorEdge) {
                this.mapInstance.setStyle(options.style);
            }
            this.subscription.add(this.zone.onMicrotaskEmpty.subscribe(function () { return _this.applyChanges(); }));
        };
        MapService.prototype.removeMarkers = function () {
            var e_1, _a;
            try {
                for (var _b = __values(this.markersToRemove), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var marker = _c.value;
                    marker.remove();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.markersToRemove = [];
        };
        MapService.prototype.removePopups = function () {
            var e_2, _a;
            try {
                for (var _b = __values(this.popupsToRemove), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var popup = _c.value;
                    popup.remove();
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.popupsToRemove = [];
        };
        MapService.prototype.removeImages = function () {
            var e_3, _a;
            try {
                for (var _b = __values(this.imageIdsToRemove), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var imageId = _c.value;
                    this.mapInstance.removeImage(imageId);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this.imageIdsToRemove = [];
        };
        MapService.prototype.findLayersBySourceId = function (sourceId) {
            var layers = this.mapInstance.getStyle().layers;
            if (layers == null) {
                return [];
            }
            return layers.filter(function (l) { return 'source' in l ? l.source === sourceId : false; });
        };
        MapService.prototype.hookEvents = function (events) {
            var _this = this;
            this.mapInstance.on('load', function (evt) {
                _this.mapLoaded.next(undefined);
                _this.mapLoaded.complete();
                _this.zone.run(function () {
                    events.mapLoad.emit(evt.target);
                    events.load.emit(evt.target);
                });
            });
            if (events.mapResize.observers.length || events.resize.observers.length) {
                this.mapInstance.on('resize', function (evt) { return _this.zone.run(function () {
                    events.mapResize.emit(evt);
                    events.resize.emit(evt);
                }); });
            }
            if (events.mapRemove.observers.length || events.remove.observers.length) {
                this.mapInstance.on('remove', function (evt) { return _this.zone.run(function () {
                    events.mapRemove.emit(evt);
                    events.remove.emit(evt);
                }); });
            }
            if (events.mapMouseDown.observers.length ||
                events.mouseDown.observers.length) {
                this.mapInstance.on('mousedown', function (evt) { return _this.zone.run(function () {
                    events.mapMouseDown.emit(evt);
                    events.mouseDown.emit(evt);
                }); });
            }
            if (events.mapMouseUp.observers.length || events.mouseUp.observers.length) {
                this.mapInstance.on('mouseup', function (evt) { return _this.zone.run(function () {
                    events.mapMouseUp.emit(evt);
                    events.mouseUp.emit(evt);
                }); });
            }
            if (events.mapMouseMove.observers.length ||
                events.mouseMove.observers.length) {
                this.mapInstance.on('mousemove', function (evt) { return _this.zone.run(function () {
                    events.mapMouseMove.emit(evt);
                    events.mouseMove.emit(evt);
                }); });
            }
            if (events.mapClick.observers.length || events.click.observers.length) {
                this.mapInstance.on('click', function (evt) { return _this.zone.run(function () {
                    events.mapClick.emit(evt);
                    events.click.emit(evt);
                }); });
            }
            if (events.mapDblClick.observers.length ||
                events.dblClick.observers.length) {
                this.mapInstance.on('dblclick', function (evt) { return _this.zone.run(function () {
                    events.mapDblClick.emit(evt);
                    events.dblClick.emit(evt);
                }); });
            }
            if (events.mapMouseOver.observers.length ||
                events.mouseOver.observers.length) {
                this.mapInstance.on('mouseover', function (evt) { return _this.zone.run(function () {
                    events.mapMouseOver.emit(evt);
                    events.mouseOver.emit(evt);
                }); });
            }
            if (events.mapMouseOut.observers.length ||
                events.mouseOut.observers.length) {
                this.mapInstance.on('mouseout', function (evt) { return _this.zone.run(function () {
                    events.mapMouseOut.emit(evt);
                    events.mouseOut.emit(evt);
                }); });
            }
            if (events.mapContextMenu.observers.length ||
                events.contextMenu.observers.length) {
                this.mapInstance.on('contextmenu', function (evt) { return _this.zone.run(function () {
                    events.mapContextMenu.emit(evt);
                    events.contextMenu.emit(evt);
                }); });
            }
            if (events.mapTouchStart.observers.length ||
                events.touchStart.observers.length) {
                this.mapInstance.on('touchstart', function (evt) { return _this.zone.run(function () {
                    events.mapTouchStart.emit(evt);
                    events.touchStart.emit(evt);
                }); });
            }
            if (events.mapTouchEnd.observers.length ||
                events.touchEnd.observers.length) {
                this.mapInstance.on('touchend', function (evt) { return _this.zone.run(function () {
                    events.mapTouchEnd.emit(evt);
                    events.touchEnd.emit(evt);
                }); });
            }
            if (events.mapTouchMove.observers.length ||
                events.touchMove.observers.length) {
                this.mapInstance.on('touchmove', function (evt) { return _this.zone.run(function () {
                    events.mapTouchMove.emit(evt);
                    events.touchMove.emit(evt);
                }); });
            }
            if (events.mapTouchCancel.observers.length ||
                events.touchCancel.observers.length) {
                this.mapInstance.on('touchcancel', function (evt) { return _this.zone.run(function () {
                    events.mapTouchCancel.emit(evt);
                    events.touchCancel.emit(evt);
                }); });
            }
            if (events.mapWheel.observers.length || events.wheel.observers.length) {
                this.mapInstance.on('wheel', function (evt) { return _this.zone.run(function () {
                    events.mapWheel.emit(evt);
                    events.wheel.emit(evt);
                }); });
            }
            if (events.moveStart.observers.length) {
                this.mapInstance.on('movestart', function (evt) { return _this.zone.run(function () { return events.moveStart.emit(evt); }); });
            }
            if (events.move.observers.length) {
                this.mapInstance.on('move', function (evt) { return _this.zone.run(function () { return events.move.emit(evt); }); });
            }
            if (events.moveEnd.observers.length) {
                this.mapInstance.on('moveend', function (evt) { return _this.zone.run(function () { return events.moveEnd.emit(evt); }); });
            }
            if (events.mapDragStart.observers.length ||
                events.dragStart.observers.length) {
                this.mapInstance.on('dragstart', function (evt) { return _this.zone.run(function () {
                    events.mapDragStart.emit(evt);
                    events.dragStart.emit(evt);
                }); });
            }
            if (events.mapDrag.observers.length || events.drag.observers.length) {
                this.mapInstance.on('drag', function (evt) { return _this.zone.run(function () {
                    events.mapDrag.emit(evt);
                    events.drag.emit(evt);
                }); });
            }
            if (events.mapDragEnd.observers.length || events.dragEnd.observers.length) {
                this.mapInstance.on('dragend', function (evt) { return _this.zone.run(function () {
                    events.mapDragEnd.emit(evt);
                    events.dragEnd.emit(evt);
                }); });
            }
            if (events.zoomStart.observers.length) {
                this.mapInstance.on('zoomstart', function (evt) { return _this.zone.run(function () { return events.zoomStart.emit(evt); }); });
            }
            if (events.zoomEvt.observers.length) {
                this.mapInstance.on('zoom', function (evt) { return _this.zone.run(function () { return events.zoomEvt.emit(evt); }); });
            }
            if (events.zoomEnd.observers.length) {
                this.mapInstance.on('zoomend', function (evt) { return _this.zone.run(function () { return events.zoomEnd.emit(evt); }); });
            }
            if (events.rotateStart.observers.length) {
                this.mapInstance.on('rotatestart', function (evt) { return _this.zone.run(function () { return events.rotateStart.emit(evt); }); });
            }
            if (events.rotate.observers.length) {
                this.mapInstance.on('rotate', function (evt) { return _this.zone.run(function () { return events.rotate.emit(evt); }); });
            }
            if (events.rotateEnd.observers.length) {
                this.mapInstance.on('rotateend', function (evt) { return _this.zone.run(function () { return events.rotateEnd.emit(evt); }); });
            }
            if (events.pitchStart.observers.length) {
                this.mapInstance.on('pitchstart', function (evt) { return _this.zone.run(function () { return events.pitchStart.emit(evt); }); });
            }
            if (events.pitchEvt.observers.length) {
                this.mapInstance.on('pitch', function (evt) { return _this.zone.run(function () { return events.pitchEvt.emit(evt); }); });
            }
            if (events.pitchEnd.observers.length) {
                this.mapInstance.on('pitchend', function (evt) { return _this.zone.run(function () { return events.pitchEnd.emit(evt); }); });
            }
            if (events.boxZoomStart.observers.length) {
                this.mapInstance.on('boxzoomstart', function (evt) { return _this.zone.run(function () { return events.boxZoomStart.emit(evt); }); });
            }
            if (events.boxZoomEnd.observers.length) {
                this.mapInstance.on('boxzoomend', function (evt) { return _this.zone.run(function () { return events.boxZoomEnd.emit(evt); }); });
            }
            if (events.boxZoomCancel.observers.length) {
                this.mapInstance.on('boxzoomcancel', function (evt) { return _this.zone.run(function () { return events.boxZoomCancel.emit(evt); }); });
            }
            if (events.webGlContextLost.observers.length) {
                this.mapInstance.on('webglcontextlost', function (evt) { return _this.zone.run(function () { return events.webGlContextLost.emit(evt); }); });
            }
            if (events.webGlContextRestored.observers.length) {
                this.mapInstance.on('webglcontextrestored', function (evt) { return _this.zone.run(function () { return events.webGlContextRestored.emit(evt); }); });
            }
            if (events.render.observers.length) {
                this.mapInstance.on('render', function (evt) { return _this.zone.run(function () { return events.render.emit(evt); }); });
            }
            if (events.mapError.observers.length || events.error.observers.length) {
                this.mapInstance.on('error', function (evt) { return _this.zone.run(function () {
                    events.mapError.emit(evt);
                    events.error.emit(evt);
                }); });
            }
            if (events.data.observers.length) {
                this.mapInstance.on('data', function (evt) { return _this.zone.run(function () { return events.data.emit(evt); }); });
            }
            if (events.styleData.observers.length) {
                this.mapInstance.on('styledata', function (evt) { return _this.zone.run(function () { return events.styleData.emit(evt); }); });
            }
            if (events.sourceData.observers.length) {
                this.mapInstance.on('sourcedata', function (evt) { return _this.zone.run(function () { return events.sourceData.emit(evt); }); });
            }
            if (events.dataLoading.observers.length) {
                this.mapInstance.on('dataloading', function (evt) { return _this.zone.run(function () { return events.dataLoading.emit(evt); }); });
            }
            if (events.styleDataLoading.observers.length) {
                this.mapInstance.on('styledataloading', function (evt) { return _this.zone.run(function () { return events.styleDataLoading.emit(evt); }); });
            }
            if (events.sourceDataLoading.observers.length) {
                this.mapInstance.on('sourcedataloading', function (evt) { return _this.zone.run(function () { return events.sourceDataLoading.emit(evt); }); });
            }
            if (events.styleImageMissing.observers.length) {
                this.mapInstance.on('styleimagemissing', function (evt) { return _this.zone.run(function () { return events.styleImageMissing.emit(evt); }); });
            }
            if (events.idle.observers.length) {
                this.mapInstance.on('idle', function (evt) { return _this.zone.run(function () { return events.idle.emit(evt); }); });
            }
        };
        // TODO move this elsewhere
        MapService.prototype.assign = function (obj, prop, value) {
            if (typeof prop === 'string') {
                // tslint:disable-next-line:no-parameter-reassignment
                prop = prop.split('.');
            }
            if (prop.length > 1) {
                var e = prop.shift();
                this.assign((obj[e] =
                    Object.prototype.toString.call(obj[e]) === '[object Object]'
                        ? obj[e]
                        : {}), prop, value);
            }
            else {
                obj[prop[0]] = value;
            }
        };
        return MapService;
    }());
    MapService.decorators = [
        { type: core.Injectable }
    ];
    MapService.ctorParameters = function () { return [
        { type: core.NgZone },
        { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAPBOX_API_KEY,] }] }
    ]; };

    var CustomControl = /** @class */ (function () {
        function CustomControl(container) {
            this.container = container;
        }
        CustomControl.prototype.onAdd = function () {
            return this.container;
        };
        CustomControl.prototype.onRemove = function () {
            return this.container.parentNode.removeChild(this.container);
        };
        CustomControl.prototype.getDefaultPosition = function () {
            return 'top-right';
        };
        return CustomControl;
    }());
    var ControlComponent = /** @class */ (function () {
        function ControlComponent(MapService) {
            this.MapService = MapService;
            this.controlAdded = false;
        }
        ControlComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (this.content.nativeElement.childNodes.length) {
                this.control = new CustomControl(this.content.nativeElement);
                this.MapService.mapCreated$.subscribe(function () {
                    _this.MapService.addControl(_this.control, _this.position);
                    _this.controlAdded = true;
                });
            }
        };
        ControlComponent.prototype.ngOnDestroy = function () {
            if (this.controlAdded) {
                this.MapService.removeControl(this.control);
            }
        };
        return ControlComponent;
    }());
    ControlComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-control',
                    template: '<div class="mapboxgl-ctrl" #content><ng-content></ng-content></div>',
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ControlComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    ControlComponent.propDecorators = {
        position: [{ type: core.Input }],
        content: [{ type: core.ViewChild, args: ['content', { static: true },] }]
    };

    var AttributionControlDirective = /** @class */ (function () {
        function AttributionControlDirective(MapService, ControlComponent) {
            this.MapService = MapService;
            this.ControlComponent = ControlComponent;
        }
        AttributionControlDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.MapService.mapCreated$.subscribe(function () {
                if (_this.ControlComponent.control) {
                    throw new Error('Another control is already set for this control');
                }
                var options = {};
                if (_this.compact !== undefined) {
                    options.compact = _this.compact;
                }
                if (_this.customAttribution !== undefined) {
                    options.customAttribution = _this.customAttribution;
                }
                _this.ControlComponent.control = new MapboxGl.AttributionControl(options);
                _this.MapService.addControl(_this.ControlComponent.control, _this.ControlComponent.position);
            });
        };
        return AttributionControlDirective;
    }());
    AttributionControlDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[mglAttribution]',
                },] }
    ];
    AttributionControlDirective.ctorParameters = function () { return [
        { type: MapService },
        { type: ControlComponent, decorators: [{ type: core.Host }] }
    ]; };
    AttributionControlDirective.propDecorators = {
        compact: [{ type: core.Input }],
        customAttribution: [{ type: core.Input }]
    };

    var FullscreenControlDirective = /** @class */ (function () {
        function FullscreenControlDirective(MapService, ControlComponent) {
            this.MapService = MapService;
            this.ControlComponent = ControlComponent;
        }
        FullscreenControlDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.MapService.mapCreated$.subscribe(function () {
                if (_this.ControlComponent.control) {
                    throw new Error('Another control is already set for this control');
                }
                _this.ControlComponent.control = new MapboxGl.FullscreenControl({
                    container: _this.container,
                });
                _this.MapService.addControl(_this.ControlComponent.control, _this.ControlComponent.position);
            });
        };
        return FullscreenControlDirective;
    }());
    FullscreenControlDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[mglFullscreen]',
                },] }
    ];
    FullscreenControlDirective.ctorParameters = function () { return [
        { type: MapService },
        { type: ControlComponent, decorators: [{ type: core.Host }] }
    ]; };
    FullscreenControlDirective.propDecorators = {
        container: [{ type: core.Input }]
    };

    function deprecationWarning(context, oldApi, newApi) {
        console.warn("[ngx-mapbox-gl]: " + context + ": " + oldApi + " is deprecated, please use " + newApi + " instead.");
    }

    var MAPBOX_GEOCODER_API_KEY = new core.InjectionToken('MapboxApiKey');
    var GeocoderControlDirective = /** @class */ (function () {
        function GeocoderControlDirective(MapService, zone, ControlComponent, MAPBOX_GEOCODER_API_KEY) {
            this.MapService = MapService;
            this.zone = zone;
            this.ControlComponent = ControlComponent;
            this.MAPBOX_GEOCODER_API_KEY = MAPBOX_GEOCODER_API_KEY;
            this.marker = false;
            this.clear = new core.EventEmitter();
            this.loading = new core.EventEmitter();
            this.geocoderResults = new core.EventEmitter();
            this.geocoderResult = new core.EventEmitter();
            this.geocoderError = new core.EventEmitter();
            /**
             * @deprecated Use geocoderResults instead
             */
            this.results = new core.EventEmitter();
            /**
             * @deprecated Use geocoderResult instead
             */
            this.result = new core.EventEmitter();
            /**
             * @deprecated Use geocoderError instead
             */
            this.error = new core.EventEmitter();
        }
        GeocoderControlDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.MapService.mapCreated$.subscribe(function () {
                if (_this.ControlComponent.control) {
                    throw new Error('Another control is already set for this control');
                }
                var options = {
                    proximity: _this.proximity,
                    countries: _this.countries,
                    placeholder: _this.placeholder,
                    zoom: _this.zoom,
                    bbox: _this.bbox,
                    types: _this.types,
                    flyTo: _this.flyTo,
                    minLength: _this.minLength,
                    limit: _this.limit,
                    language: _this.language,
                    filter: _this.filter,
                    localGeocoder: _this.localGeocoder,
                    accessToken: _this.accessToken || _this.MAPBOX_GEOCODER_API_KEY,
                    mapboxgl: _this.mapboxgl,
                    marker: _this.marker,
                };
                Object.keys(options).forEach(function (key) {
                    var tkey = key;
                    if (options[tkey] === undefined) {
                        delete options[tkey];
                    }
                });
                _this.geocoder = new MapboxGeocoder__default['default'](options);
                _this.hookEvents(_this);
                _this.addControl();
            });
            if (this.searchInput) {
                this.MapService.mapLoaded$.subscribe(function () {
                    _this.geocoder.query(_this.searchInput);
                });
            }
        };
        GeocoderControlDirective.prototype.ngOnChanges = function (changes) {
            if (!this.geocoder) {
                return;
            }
            if (changes.proximity && !changes.proximity.isFirstChange()) {
                this.geocoder.setProximity(changes.proximity.currentValue);
            }
            if (changes.searchInput) {
                this.geocoder.query(this.searchInput);
            }
        };
        GeocoderControlDirective.prototype.addControl = function () {
            this.ControlComponent.control = this.geocoder;
            this.MapService.addControl(this.ControlComponent.control, this.ControlComponent.position);
        };
        GeocoderControlDirective.prototype.hookEvents = function (events) {
            var _this = this;
            this.warnDeprecatedOutputs(events);
            if (events.results.observers.length ||
                events.geocoderResults.observers.length) {
                this.geocoder.on('results', function (evt) { return _this.zone.run(function () {
                    events.geocoderResults.emit(evt);
                    events.results.emit(evt);
                }); });
            }
            if (events.geocoderResult.observers.length ||
                events.result.observers.length) {
                this.geocoder.on('result', function (evt) {
                    // Workaroud issue https://github.com/mapbox/mapbox-gl-geocoder/issues/99
                    if (_this.lastResultId !== evt.result.id) {
                        _this.lastResultId = evt.result.id;
                        _this.zone.run(function () {
                            events.geocoderResult.emit(evt);
                            events.result.emit(evt);
                        });
                    }
                });
            }
            if (events.error.observers.length ||
                events.geocoderError.observers.length) {
                this.geocoder.on('error', function (evt) { return _this.zone.run(function () {
                    events.geocoderError.emit(evt);
                    events.error.emit(evt);
                }); });
            }
            if (events.loading.observers.length) {
                this.geocoder.on('loading', function (evt) { return _this.zone.run(function () { return events.loading.emit(evt); }); });
            }
            if (events.clear.observers.length) {
                this.geocoder.on('clear', function () { return _this.zone.run(function () { return events.clear.emit(); }); });
            }
        };
        GeocoderControlDirective.prototype.warnDeprecatedOutputs = function (events) {
            var dw = deprecationWarning.bind(undefined, GeocoderControlDirective.name);
            if (events.results.observers.length) {
                dw('results', 'geocoderResults');
            }
            if (events.result.observers.length) {
                dw('result', 'geocoderResult');
            }
            if (events.error.observers.length) {
                dw('error', 'geocoderError');
            }
        };
        return GeocoderControlDirective;
    }());
    GeocoderControlDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[mglGeocoder]',
                },] }
    ];
    GeocoderControlDirective.ctorParameters = function () { return [
        { type: MapService },
        { type: core.NgZone },
        { type: ControlComponent, decorators: [{ type: core.Host }] },
        { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAPBOX_GEOCODER_API_KEY,] }] }
    ]; };
    GeocoderControlDirective.propDecorators = {
        countries: [{ type: core.Input }],
        placeholder: [{ type: core.Input }],
        zoom: [{ type: core.Input }],
        bbox: [{ type: core.Input }],
        types: [{ type: core.Input }],
        flyTo: [{ type: core.Input }],
        minLength: [{ type: core.Input }],
        limit: [{ type: core.Input }],
        language: [{ type: core.Input }],
        accessToken: [{ type: core.Input }],
        filter: [{ type: core.Input }],
        localGeocoder: [{ type: core.Input }],
        mapboxgl: [{ type: core.Input }],
        marker: [{ type: core.Input }],
        proximity: [{ type: core.Input }],
        searchInput: [{ type: core.Input }],
        clear: [{ type: core.Output }],
        loading: [{ type: core.Output }],
        geocoderResults: [{ type: core.Output }],
        geocoderResult: [{ type: core.Output }],
        geocoderError: [{ type: core.Output }],
        results: [{ type: core.Output }],
        result: [{ type: core.Output }],
        error: [{ type: core.Output }]
    };

    var GeolocateControlDirective = /** @class */ (function () {
        function GeolocateControlDirective(MapService, ControlComponent) {
            this.MapService = MapService;
            this.ControlComponent = ControlComponent;
            this.geolocate = new core.EventEmitter();
        }
        GeolocateControlDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.MapService.mapCreated$.subscribe(function () {
                if (_this.ControlComponent.control) {
                    throw new Error('Another control is already set for this control');
                }
                var options = {
                    positionOptions: _this.positionOptions,
                    fitBoundsOptions: _this.fitBoundsOptions,
                    trackUserLocation: _this.trackUserLocation,
                    showUserLocation: _this.showUserLocation,
                };
                Object.keys(options).forEach(function (key) {
                    var tkey = key;
                    if (options[tkey] === undefined) {
                        delete options[tkey];
                    }
                });
                _this.ControlComponent.control = new MapboxGl.GeolocateControl(options);
                _this.ControlComponent.control.on('geolocate', function (data) {
                    _this.geolocate.emit(data);
                });
                _this.MapService.addControl(_this.ControlComponent.control, _this.ControlComponent.position);
            });
        };
        return GeolocateControlDirective;
    }());
    GeolocateControlDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[mglGeolocate]',
                },] }
    ];
    GeolocateControlDirective.ctorParameters = function () { return [
        { type: MapService },
        { type: ControlComponent, decorators: [{ type: core.Host }] }
    ]; };
    GeolocateControlDirective.propDecorators = {
        positionOptions: [{ type: core.Input }],
        fitBoundsOptions: [{ type: core.Input }],
        trackUserLocation: [{ type: core.Input }],
        showUserLocation: [{ type: core.Input }],
        geolocate: [{ type: core.Output }]
    };

    var NavigationControlDirective = /** @class */ (function () {
        function NavigationControlDirective(MapService, ControlComponent) {
            this.MapService = MapService;
            this.ControlComponent = ControlComponent;
        }
        NavigationControlDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.MapService.mapCreated$.subscribe(function () {
                if (_this.ControlComponent.control) {
                    throw new Error('Another control is already set for this control');
                }
                var options = {};
                if (_this.showCompass !== undefined) {
                    options.showCompass = _this.showCompass;
                }
                if (_this.showZoom !== undefined) {
                    options.showZoom = _this.showZoom;
                }
                _this.ControlComponent.control = new MapboxGl.NavigationControl(options);
                _this.MapService.addControl(_this.ControlComponent.control, _this.ControlComponent.position);
            });
        };
        return NavigationControlDirective;
    }());
    NavigationControlDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[mglNavigation]',
                },] }
    ];
    NavigationControlDirective.ctorParameters = function () { return [
        { type: MapService },
        { type: ControlComponent, decorators: [{ type: core.Host }] }
    ]; };
    NavigationControlDirective.propDecorators = {
        showCompass: [{ type: core.Input }],
        showZoom: [{ type: core.Input }]
    };

    var ScaleControlDirective = /** @class */ (function () {
        function ScaleControlDirective(MapService, ControlComponent) {
            this.MapService = MapService;
            this.ControlComponent = ControlComponent;
        }
        ScaleControlDirective.prototype.ngOnChanges = function (changes) {
            if (changes.unit && !changes.unit.isFirstChange()) {
                this.ControlComponent.control.setUnit(changes.unit.currentValue);
            }
        };
        ScaleControlDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.MapService.mapCreated$.subscribe(function () {
                if (_this.ControlComponent.control) {
                    throw new Error('Another control is already set for this control');
                }
                var options = {};
                if (_this.maxWidth !== undefined) {
                    options.maxWidth = _this.maxWidth;
                }
                if (_this.unit !== undefined) {
                    options.unit = _this.unit;
                }
                _this.ControlComponent.control = new MapboxGl.ScaleControl(options);
                _this.MapService.addControl(_this.ControlComponent.control, _this.ControlComponent.position);
            });
        };
        return ScaleControlDirective;
    }());
    ScaleControlDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[mglScale]',
                },] }
    ];
    ScaleControlDirective.ctorParameters = function () { return [
        { type: MapService },
        { type: ControlComponent, decorators: [{ type: core.Host }] }
    ]; };
    ScaleControlDirective.propDecorators = {
        maxWidth: [{ type: core.Input }],
        unit: [{ type: core.Input }]
    };

    var GeoJSONSourceComponent = /** @class */ (function () {
        function GeoJSONSourceComponent(MapService, zone) {
            this.MapService = MapService;
            this.zone = zone;
            this.updateFeatureData = new rxjs.Subject();
            this.sub = new rxjs.Subscription();
            this.sourceAdded = false;
            this.featureIdCounter = 0;
        }
        GeoJSONSourceComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (!this.data) {
                this.data = {
                    type: 'FeatureCollection',
                    features: [],
                };
            }
            var sub1 = this.MapService.mapLoaded$.subscribe(function () {
                _this.init();
                var sub = rxjs.fromEvent(_this.MapService.mapInstance, 'styledata')
                    .pipe(operators.filter(function () { return !_this.MapService.mapInstance.getSource(_this.id); }))
                    .subscribe(function () {
                    _this.init();
                });
                _this.sub.add(sub);
            });
            this.sub.add(sub1);
        };
        GeoJSONSourceComponent.prototype.ngOnChanges = function (changes) {
            if (!this.sourceAdded) {
                return;
            }
            if ((changes.maxzoom && !changes.maxzoom.isFirstChange()) ||
                (changes.attribution && !changes.attribution.isFirstChange()) ||
                (changes.buffer && !changes.buffer.isFirstChange()) ||
                (changes.tolerance && !changes.tolerance.isFirstChange()) ||
                (changes.cluster && !changes.cluster.isFirstChange()) ||
                (changes.clusterRadius && !changes.clusterRadius.isFirstChange()) ||
                (changes.clusterMaxZoom && !changes.clusterMaxZoom.isFirstChange()) ||
                (changes.clusterMinPoints && !changes.clusterMinPoints.isFirstChange()) ||
                (changes.clusterProperties &&
                    !changes.clusterProperties.isFirstChange()) ||
                (changes.lineMetrics && !changes.lineMetrics.isFirstChange()) ||
                (changes.generateId && !changes.generateId.isFirstChange()) ||
                (changes.promoteId && !changes.promoteId.isFirstChange()) ||
                (changes.filter && !changes.filter.isFirstChange())) {
                this.ngOnDestroy();
                this.ngOnInit();
            }
            if (changes.data && !changes.data.isFirstChange()) {
                var source = this.MapService.getSource(this.id);
                source.setData(this.data);
            }
        };
        GeoJSONSourceComponent.prototype.ngOnDestroy = function () {
            this.sub.unsubscribe();
            if (this.sourceAdded) {
                this.MapService.removeSource(this.id);
                this.sourceAdded = false;
            }
        };
        /**
         * For clustered sources, fetches the zoom at which the given cluster expands.
         * @param clusterId The value of the cluster's cluster_id property.
         */
        GeoJSONSourceComponent.prototype.getClusterExpansionZoom = function (clusterId) {
            return __awaiter(this, void 0, void 0, function () {
                var source;
                var _this = this;
                return __generator(this, function (_a) {
                    source = this.MapService.getSource(this.id);
                    return [2 /*return*/, this.zone.run(function () { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                return [2 /*return*/, new Promise(function (resolve, reject) {
                                        source.getClusterExpansionZoom(clusterId, function (error, zoom) {
                                            if (error) {
                                                reject(error);
                                            }
                                            else {
                                                resolve(zoom);
                                            }
                                        });
                                    })];
                            });
                        }); })];
                });
            });
        };
        /**
         * For clustered sources, fetches the children of the given cluster on the next zoom level (as an array of GeoJSON features).
         * @param clusterId The value of the cluster's cluster_id property.
         */
        GeoJSONSourceComponent.prototype.getClusterChildren = function (clusterId) {
            return __awaiter(this, void 0, void 0, function () {
                var source;
                var _this = this;
                return __generator(this, function (_a) {
                    source = this.MapService.getSource(this.id);
                    return [2 /*return*/, this.zone.run(function () { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                return [2 /*return*/, new Promise(function (resolve, reject) {
                                        source.getClusterChildren(clusterId, function (error, features) {
                                            if (error) {
                                                reject(error);
                                            }
                                            else {
                                                resolve(features);
                                            }
                                        });
                                    })];
                            });
                        }); })];
                });
            });
        };
        /**
         * For clustered sources, fetches the original points that belong to the cluster (as an array of GeoJSON features).
         * @param clusterId The value of the cluster's cluster_id property.
         * @param limit The maximum number of features to return.
         * @param offset The number of features to skip (e.g. for pagination).
         */
        GeoJSONSourceComponent.prototype.getClusterLeaves = function (clusterId, limit, offset) {
            return __awaiter(this, void 0, void 0, function () {
                var source;
                var _this = this;
                return __generator(this, function (_a) {
                    source = this.MapService.getSource(this.id);
                    return [2 /*return*/, this.zone.run(function () { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                return [2 /*return*/, new Promise(function (resolve, reject) {
                                        source.getClusterLeaves(clusterId, limit, offset, function (error, features) {
                                            if (error) {
                                                reject(error);
                                            }
                                            else {
                                                resolve(features);
                                            }
                                        });
                                    })];
                            });
                        }); })];
                });
            });
        };
        GeoJSONSourceComponent.prototype._addFeature = function (feature) {
            var collection = (this.data);
            collection.features.push(feature);
            this.updateFeatureData.next();
        };
        GeoJSONSourceComponent.prototype._removeFeature = function (feature) {
            var collection = (this.data);
            var index = collection.features.indexOf(feature);
            if (index > -1) {
                collection.features.splice(index, 1);
            }
            this.updateFeatureData.next();
        };
        GeoJSONSourceComponent.prototype._getNewFeatureId = function () {
            return ++this.featureIdCounter;
        };
        GeoJSONSourceComponent.prototype.init = function () {
            var _this = this;
            var source = {
                type: 'geojson',
                data: this.data,
                maxzoom: this.maxzoom,
                attribution: this.attribution,
                buffer: this.buffer,
                tolerance: this.tolerance,
                cluster: this.cluster,
                clusterRadius: this.clusterRadius,
                clusterMaxZoom: this.clusterMaxZoom,
                clusterMinPoints: this.clusterMinPoints,
                clusterProperties: this.clusterProperties,
                lineMetrics: this.lineMetrics,
                generateId: this.generateId,
                promoteId: this.promoteId,
                filter: this.filter,
            };
            this.MapService.addSource(this.id, source);
            var sub = this.updateFeatureData.pipe(operators.debounceTime(0)).subscribe(function () {
                var source = _this.MapService.getSource(_this.id);
                source.setData(_this.data);
            });
            this.sub.add(sub);
            this.sourceAdded = true;
        };
        return GeoJSONSourceComponent;
    }());
    GeoJSONSourceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-geojson-source',
                    template: '',
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    GeoJSONSourceComponent.ctorParameters = function () { return [
        { type: MapService },
        { type: core.NgZone }
    ]; };
    GeoJSONSourceComponent.propDecorators = {
        id: [{ type: core.Input }],
        data: [{ type: core.Input }],
        maxzoom: [{ type: core.Input }],
        attribution: [{ type: core.Input }],
        buffer: [{ type: core.Input }],
        tolerance: [{ type: core.Input }],
        cluster: [{ type: core.Input }],
        clusterRadius: [{ type: core.Input }],
        clusterMaxZoom: [{ type: core.Input }],
        clusterMinPoints: [{ type: core.Input }],
        clusterProperties: [{ type: core.Input }],
        lineMetrics: [{ type: core.Input }],
        generateId: [{ type: core.Input }],
        promoteId: [{ type: core.Input }],
        filter: [{ type: core.Input }]
    };

    var FeatureComponent = /** @class */ (function () {
        function FeatureComponent(GeoJSONSourceComponent) {
            this.GeoJSONSourceComponent = GeoJSONSourceComponent;
            this.type = 'Feature';
        }
        FeatureComponent.prototype.ngOnInit = function () {
            if (!this.id) {
                this.id = this.GeoJSONSourceComponent._getNewFeatureId();
            }
            this.feature = {
                type: this.type,
                geometry: this.geometry,
                properties: this.properties ? this.properties : {},
            };
            this.feature.id = this.id;
            this.GeoJSONSourceComponent._addFeature(this.feature);
        };
        FeatureComponent.prototype.ngOnDestroy = function () {
            this.GeoJSONSourceComponent._removeFeature(this.feature);
        };
        FeatureComponent.prototype.updateCoordinates = function (coordinates) {
            this.feature.geometry.coordinates = coordinates;
            this.GeoJSONSourceComponent.updateFeatureData.next();
        };
        return FeatureComponent;
    }());
    FeatureComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-feature',
                    template: '',
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    FeatureComponent.ctorParameters = function () { return [
        { type: GeoJSONSourceComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return GeoJSONSourceComponent; }),] }] }
    ]; };
    FeatureComponent.propDecorators = {
        id: [{ type: core.Input }],
        geometry: [{ type: core.Input }],
        properties: [{ type: core.Input }]
    };

    var DraggableDirective = /** @class */ (function () {
        function DraggableDirective(MapService, NgZone, FeatureComponent) {
            this.MapService = MapService;
            this.NgZone = NgZone;
            this.FeatureComponent = FeatureComponent;
            this.featureDragStart = new core.EventEmitter();
            this.featureDragEnd = new core.EventEmitter();
            this.featureDrag = new core.EventEmitter();
            /**
             * @deprecated Use featureDragStart instead
             */
            this.dragStart = new core.EventEmitter();
            /**
             * @deprecated Use featureDragEnd instead
             */
            this.dragEnd = new core.EventEmitter();
            /**
             * @deprecated Use featureDrag instead
             */
            this.drag = new core.EventEmitter();
            this.sub = new rxjs.Subscription();
        }
        DraggableDirective.prototype.ngOnInit = function () {
            this.warnDeprecatedOutputs();
            var enter$;
            var leave$;
            var updateCoords;
            if (this.FeatureComponent && this.layer) {
                enter$ = this.layer.layerMouseEnter;
                leave$ = this.layer.layerMouseLeave;
                updateCoords = this.FeatureComponent.updateCoordinates.bind(this.FeatureComponent);
                if (this.FeatureComponent.geometry.type !== 'Point') {
                    throw new Error('mglDraggable only support point feature');
                }
            }
            else {
                throw new Error('mglDraggable can only be used on Feature (with a layer as input) or Marker');
            }
            this.handleDraggable(enter$, leave$, updateCoords);
        };
        DraggableDirective.prototype.ngOnDestroy = function () {
            this.sub.unsubscribe();
        };
        DraggableDirective.prototype.handleDraggable = function (enter$, leave$, updateCoords) {
            var _this = this;
            var moving = false;
            var inside = false;
            this.MapService.mapCreated$.subscribe(function () {
                var mouseUp$ = rxjs.fromEvent(_this.MapService.mapInstance, 'mouseup');
                var dragStart$ = enter$.pipe(operators.filter(function () { return !moving; }), operators.filter(function (evt) { return _this.filterFeature(evt); }), operators.tap(function () {
                    inside = true;
                    _this.MapService.changeCanvasCursor('move');
                    _this.MapService.updateDragPan(false);
                }), operators.switchMap(function () { return rxjs.fromEvent(_this.MapService.mapInstance, 'mousedown').pipe(operators.takeUntil(leave$)); }));
                var dragging$ = dragStart$.pipe(operators.switchMap(function () { return rxjs.fromEvent(_this.MapService.mapInstance, 'mousemove').pipe(operators.takeUntil(mouseUp$)); }));
                var dragEnd$ = dragStart$.pipe(operators.switchMap(function () { return mouseUp$.pipe(operators.take(1)); }));
                _this.sub.add(dragStart$.subscribe(function (evt) {
                    moving = true;
                    if (_this.featureDragStart.observers.length ||
                        _this.dragStart.observers.length) {
                        _this.NgZone.run(function () {
                            _this.featureDragStart.emit(evt);
                            _this.dragStart.emit(evt);
                        });
                    }
                }));
                _this.sub.add(dragging$.subscribe(function (evt) {
                    updateCoords([evt.lngLat.lng, evt.lngLat.lat]);
                    if (_this.featureDrag.observers.length || _this.drag.observers.length) {
                        _this.NgZone.run(function () {
                            _this.featureDrag.emit(evt);
                            _this.drag.emit(evt);
                        });
                    }
                }));
                _this.sub.add(dragEnd$.subscribe(function (evt) {
                    moving = false;
                    if (_this.featureDragEnd.observers.length ||
                        _this.dragEnd.observers.length) {
                        _this.NgZone.run(function () {
                            _this.featureDragEnd.emit(evt);
                            _this.dragEnd.emit(evt);
                        });
                    }
                    if (!inside) {
                        // It's possible to dragEnd outside the target (small input lag)
                        _this.MapService.changeCanvasCursor('');
                        _this.MapService.updateDragPan(true);
                    }
                }));
                _this.sub.add(leave$
                    .pipe(operators.tap(function () { return (inside = false); }), operators.filter(function () { return !moving; }))
                    .subscribe(function () {
                    _this.MapService.changeCanvasCursor('');
                    _this.MapService.updateDragPan(true);
                }));
            });
        };
        DraggableDirective.prototype.filterFeature = function (evt) {
            if (this.FeatureComponent && this.layer) {
                var feature = this.MapService.queryRenderedFeatures(evt.point, {
                    layers: [this.layer.id],
                    filter: [
                        'all',
                        ['==', '$type', 'Point'],
                        ['==', '$id', this.FeatureComponent.id],
                    ],
                })[0];
                if (!feature) {
                    return false;
                }
            }
            return true;
        };
        DraggableDirective.prototype.warnDeprecatedOutputs = function () {
            var dw = deprecationWarning.bind(undefined, DraggableDirective.name);
            if (this.dragStart.observers.length) {
                dw('dragStart', 'featureDragStart');
            }
            if (this.dragEnd.observers.length) {
                dw('dragEnd', 'featureDragEnd');
            }
            if (this.drag.observers.length) {
                dw('drag', 'featureDrag');
            }
        };
        return DraggableDirective;
    }());
    DraggableDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[mglDraggable]',
                },] }
    ];
    DraggableDirective.ctorParameters = function () { return [
        { type: MapService },
        { type: core.NgZone },
        { type: FeatureComponent, decorators: [{ type: core.Optional }, { type: core.Host }] }
    ]; };
    DraggableDirective.propDecorators = {
        layer: [{ type: core.Input, args: ['mglDraggable',] }],
        featureDragStart: [{ type: core.Output }],
        featureDragEnd: [{ type: core.Output }],
        featureDrag: [{ type: core.Output }],
        dragStart: [{ type: core.Output }],
        dragEnd: [{ type: core.Output }],
        drag: [{ type: core.Output }]
    };

    var ImageComponent = /** @class */ (function () {
        function ImageComponent(MapService, zone) {
            this.MapService = MapService;
            this.zone = zone;
            this.imageError = new core.EventEmitter();
            this.imageLoaded = new core.EventEmitter();
            /**
             * @deprecated Use imageError instead
             */
            this.error = new core.EventEmitter();
            /**
             * @deprecated Use imageLoaded instead
             */
            this.loaded = new core.EventEmitter();
            this.isAdded = false;
            this.isAdding = false;
        }
        ImageComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.warnDeprecatedOutputs();
            this.sub = this.MapService.mapLoaded$
                .pipe(operators.switchMap(function () { return rxjs.fromEvent(_this.MapService.mapInstance, 'styledata').pipe(operators.startWith(undefined), operators.filter(function () { return !_this.isAdding && !_this.MapService.mapInstance.hasImage(_this.id); })); }))
                .subscribe(function () { return _this.init(); });
        };
        ImageComponent.prototype.ngOnChanges = function (changes) {
            if ((changes.data && !changes.data.isFirstChange()) ||
                (changes.options && !changes.options.isFirstChange()) ||
                (changes.url && !changes.url.isFirstChange())) {
                this.ngOnDestroy();
                this.ngOnInit();
            }
        };
        ImageComponent.prototype.ngOnDestroy = function () {
            if (this.isAdded) {
                this.MapService.removeImage(this.id);
            }
            if (this.sub) {
                this.sub.unsubscribe();
            }
        };
        ImageComponent.prototype.init = function () {
            return __awaiter(this, void 0, void 0, function () {
                var error_1;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.isAdding = true;
                            if (!this.data) return [3 /*break*/, 1];
                            this.MapService.addImage(this.id, this.data, this.options);
                            this.isAdded = true;
                            this.isAdding = false;
                            return [3 /*break*/, 5];
                        case 1:
                            if (!this.url) return [3 /*break*/, 5];
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, this.MapService.loadAndAddImage(this.id, this.url, this.options)];
                        case 3:
                            _a.sent();
                            this.isAdded = true;
                            this.isAdding = false;
                            this.zone.run(function () {
                                _this.imageLoaded.emit();
                                _this.loaded.emit();
                            });
                            return [3 /*break*/, 5];
                        case 4:
                            error_1 = _a.sent();
                            this.zone.run(function () {
                                _this.imageError.emit(error_1);
                                _this.error.emit(error_1);
                            });
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        ImageComponent.prototype.warnDeprecatedOutputs = function () {
            var dw = deprecationWarning.bind(undefined, ImageComponent.name);
            if (this.error.observers.length) {
                dw('error', 'imageError');
            }
            if (this.loaded.observers.length) {
                dw('loaded', 'imageLoaded');
            }
        };
        return ImageComponent;
    }());
    ImageComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-image',
                    template: ''
                },] }
    ];
    ImageComponent.ctorParameters = function () { return [
        { type: MapService },
        { type: core.NgZone }
    ]; };
    ImageComponent.propDecorators = {
        id: [{ type: core.Input }],
        data: [{ type: core.Input }],
        options: [{ type: core.Input }],
        url: [{ type: core.Input }],
        imageError: [{ type: core.Output }],
        imageLoaded: [{ type: core.Output }],
        error: [{ type: core.Output }],
        loaded: [{ type: core.Output }]
    };

    var LayerComponent = /** @class */ (function () {
        function LayerComponent(MapService) {
            this.MapService = MapService;
            this.layerClick = new core.EventEmitter();
            this.layerDblClick = new core.EventEmitter();
            this.layerMouseDown = new core.EventEmitter();
            this.layerMouseUp = new core.EventEmitter();
            this.layerMouseEnter = new core.EventEmitter();
            this.layerMouseLeave = new core.EventEmitter();
            this.layerMouseMove = new core.EventEmitter();
            this.layerMouseOver = new core.EventEmitter();
            this.layerMouseOut = new core.EventEmitter();
            this.layerContextMenu = new core.EventEmitter();
            this.layerTouchStart = new core.EventEmitter();
            this.layerTouchEnd = new core.EventEmitter();
            this.layerTouchCancel = new core.EventEmitter();
            /**
             * @deprecated Use layerClick instead
             */
            this.click = new core.EventEmitter();
            /**
             * @deprecated Use layerDblClick instead
             */
            this.dblClick = new core.EventEmitter();
            /**
             * @deprecated Use layerMouseDown instead
             */
            this.mouseDown = new core.EventEmitter();
            /**
             * @deprecated Use layerMouseUp instead
             */
            this.mouseUp = new core.EventEmitter();
            /**
             * @deprecated Use layerMouseEnter instead
             */
            this.mouseEnter = new core.EventEmitter();
            /**
             * @deprecated Use layerMouseLeave instead
             */
            this.mouseLeave = new core.EventEmitter();
            /**
             * @deprecated Use layerMouseMove instead
             */
            this.mouseMove = new core.EventEmitter();
            /**
             * @deprecated Use layerMouseOver instead
             */
            this.mouseOver = new core.EventEmitter();
            /**
             * @deprecated Use layerMouseOut instead
             */
            this.mouseOut = new core.EventEmitter();
            /**
             * @deprecated Use layerContextMenu instead
             */
            this.contextMenu = new core.EventEmitter();
            /**
             * @deprecated Use layerTouchStart instead
             */
            this.touchStart = new core.EventEmitter();
            /**
             * @deprecated Use layerTouchEnd instead
             */
            this.touchEnd = new core.EventEmitter();
            /**
             * @deprecated Use layerTouchCancel instead
             */
            this.touchCancel = new core.EventEmitter();
            this.layerAdded = false;
        }
        LayerComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.warnDeprecatedOutputs();
            this.sub = this.MapService.mapLoaded$
                .pipe(operators.switchMap(function () { return rxjs.fromEvent(_this.MapService.mapInstance, 'styledata').pipe(operators.mapTo(false), operators.filter(function () { return !_this.MapService.mapInstance.getLayer(_this.id); }), operators.startWith(true)); }))
                .subscribe(function (bindEvents) { return _this.init(bindEvents); });
        };
        LayerComponent.prototype.ngOnChanges = function (changes) {
            if (!this.layerAdded) {
                return;
            }
            if (changes.paint && !changes.paint.isFirstChange()) {
                this.MapService.setAllLayerPaintProperty(this.id, changes.paint.currentValue);
            }
            if (changes.layout && !changes.layout.isFirstChange()) {
                this.MapService.setAllLayerLayoutProperty(this.id, changes.layout.currentValue);
            }
            if (changes.filter && !changes.filter.isFirstChange()) {
                this.MapService.setLayerFilter(this.id, changes.filter.currentValue);
            }
            if (changes.before && !changes.before.isFirstChange()) {
                this.MapService.setLayerBefore(this.id, changes.before.currentValue);
            }
            if ((changes.minzoom && !changes.minzoom.isFirstChange()) ||
                (changes.maxzoom && !changes.maxzoom.isFirstChange())) {
                this.MapService.setLayerZoomRange(this.id, this.minzoom, this.maxzoom);
            }
        };
        LayerComponent.prototype.ngOnDestroy = function () {
            if (this.layerAdded) {
                this.MapService.removeLayer(this.id);
            }
            if (this.sub) {
                this.sub.unsubscribe();
            }
        };
        LayerComponent.prototype.init = function (bindEvents) {
            var layer = {
                layerOptions: {
                    id: this.id,
                    type: this.type,
                    source: this.source,
                    metadata: this.metadata,
                    'source-layer': this.sourceLayer,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this.layout,
                    paint: this.paint,
                },
                layerEvents: {
                    layerClick: this.layerClick,
                    layerDblClick: this.layerDblClick,
                    layerMouseDown: this.layerMouseDown,
                    layerMouseUp: this.layerMouseUp,
                    layerMouseEnter: this.layerMouseEnter,
                    layerMouseLeave: this.layerMouseLeave,
                    layerMouseMove: this.layerMouseMove,
                    layerMouseOver: this.layerMouseOver,
                    layerMouseOut: this.layerMouseOut,
                    layerContextMenu: this.layerContextMenu,
                    layerTouchStart: this.layerTouchStart,
                    layerTouchEnd: this.layerTouchEnd,
                    layerTouchCancel: this.layerTouchCancel,
                    click: this.click,
                    dblClick: this.dblClick,
                    mouseDown: this.mouseDown,
                    mouseUp: this.mouseUp,
                    mouseEnter: this.mouseEnter,
                    mouseLeave: this.mouseLeave,
                    mouseMove: this.mouseMove,
                    mouseOver: this.mouseOver,
                    mouseOut: this.mouseOut,
                    contextMenu: this.contextMenu,
                    touchStart: this.touchStart,
                    touchEnd: this.touchEnd,
                    touchCancel: this.touchCancel,
                },
            };
            this.MapService.addLayer(layer, bindEvents, this.before);
            this.layerAdded = true;
        };
        LayerComponent.prototype.warnDeprecatedOutputs = function () {
            var dw = deprecationWarning.bind(undefined, LayerComponent.name);
            if (this.click.observers.length) {
                dw('click', 'layerClick');
            }
            if (this.dblClick.observers.length) {
                dw('dblClick', 'layerDblClick');
            }
            if (this.mouseDown.observers.length) {
                dw('mouseDown', 'layerMouseDown');
            }
            if (this.mouseUp.observers.length) {
                dw('mouseUp', 'layerMouseUp');
            }
            if (this.mouseEnter.observers.length) {
                dw('mouseEnter', 'layerMouseEnter');
            }
            if (this.mouseLeave.observers.length) {
                dw('mouseLeave', 'layerMouseLeave');
            }
            if (this.mouseMove.observers.length) {
                dw('mouseMove', 'layerMouseMove');
            }
            if (this.mouseOver.observers.length) {
                dw('mouseOver', 'layerMouseOver');
            }
            if (this.mouseOut.observers.length) {
                dw('mouseOut', 'layerMouseOut');
            }
            if (this.contextMenu.observers.length) {
                dw('contextMenu', 'layerContextMenu');
            }
            if (this.touchStart.observers.length) {
                dw('touchStart', 'layerTouchStart');
            }
            if (this.touchEnd.observers.length) {
                dw('touchEnd', 'layerTouchEnd');
            }
            if (this.touchCancel.observers.length) {
                dw('touchCancel', 'layerTouchCancel');
            }
        };
        return LayerComponent;
    }());
    LayerComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-layer',
                    template: ''
                },] }
    ];
    LayerComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    LayerComponent.propDecorators = {
        id: [{ type: core.Input }],
        source: [{ type: core.Input }],
        type: [{ type: core.Input }],
        metadata: [{ type: core.Input }],
        sourceLayer: [{ type: core.Input }],
        filter: [{ type: core.Input }],
        layout: [{ type: core.Input }],
        paint: [{ type: core.Input }],
        before: [{ type: core.Input }],
        minzoom: [{ type: core.Input }],
        maxzoom: [{ type: core.Input }],
        layerClick: [{ type: core.Output }],
        layerDblClick: [{ type: core.Output }],
        layerMouseDown: [{ type: core.Output }],
        layerMouseUp: [{ type: core.Output }],
        layerMouseEnter: [{ type: core.Output }],
        layerMouseLeave: [{ type: core.Output }],
        layerMouseMove: [{ type: core.Output }],
        layerMouseOver: [{ type: core.Output }],
        layerMouseOut: [{ type: core.Output }],
        layerContextMenu: [{ type: core.Output }],
        layerTouchStart: [{ type: core.Output }],
        layerTouchEnd: [{ type: core.Output }],
        layerTouchCancel: [{ type: core.Output }],
        click: [{ type: core.Output }],
        dblClick: [{ type: core.Output }],
        mouseDown: [{ type: core.Output }],
        mouseUp: [{ type: core.Output }],
        mouseEnter: [{ type: core.Output }],
        mouseLeave: [{ type: core.Output }],
        mouseMove: [{ type: core.Output }],
        mouseOver: [{ type: core.Output }],
        mouseOut: [{ type: core.Output }],
        contextMenu: [{ type: core.Output }],
        touchStart: [{ type: core.Output }],
        touchEnd: [{ type: core.Output }],
        touchCancel: [{ type: core.Output }]
    };

    var MapComponent = /** @class */ (function () {
        function MapComponent(MapService) {
            this.MapService = MapService;
            /* Added by ngx-mapbox-gl */
            this.movingMethod = 'flyTo';
            this.mapResize = new core.EventEmitter();
            this.mapRemove = new core.EventEmitter();
            this.mapMouseDown = new core.EventEmitter();
            this.mapMouseUp = new core.EventEmitter();
            this.mapMouseMove = new core.EventEmitter();
            this.mapClick = new core.EventEmitter();
            this.mapDblClick = new core.EventEmitter();
            this.mapMouseOver = new core.EventEmitter();
            this.mapMouseOut = new core.EventEmitter();
            this.mapContextMenu = new core.EventEmitter();
            this.mapTouchStart = new core.EventEmitter();
            this.mapTouchEnd = new core.EventEmitter();
            this.mapTouchMove = new core.EventEmitter();
            this.mapTouchCancel = new core.EventEmitter();
            this.mapWheel = new core.EventEmitter();
            this.moveStart = new core.EventEmitter();
            this.move = new core.EventEmitter();
            this.moveEnd = new core.EventEmitter();
            this.mapDragStart = new core.EventEmitter();
            this.mapDrag = new core.EventEmitter();
            this.mapDragEnd = new core.EventEmitter();
            this.zoomStart = new core.EventEmitter();
            this.zoomEvt = new core.EventEmitter();
            this.zoomEnd = new core.EventEmitter();
            this.rotateStart = new core.EventEmitter();
            this.rotate = new core.EventEmitter();
            this.rotateEnd = new core.EventEmitter();
            this.pitchStart = new core.EventEmitter();
            this.pitchEvt = new core.EventEmitter();
            this.pitchEnd = new core.EventEmitter();
            this.boxZoomStart = new core.EventEmitter();
            this.boxZoomEnd = new core.EventEmitter();
            this.boxZoomCancel = new core.EventEmitter();
            this.webGlContextLost = new core.EventEmitter();
            this.webGlContextRestored = new core.EventEmitter();
            this.mapLoad = new core.EventEmitter();
            this.idle = new core.EventEmitter();
            this.render = new core.EventEmitter();
            this.mapError = new core.EventEmitter();
            this.data = new core.EventEmitter();
            this.styleData = new core.EventEmitter();
            this.sourceData = new core.EventEmitter();
            this.dataLoading = new core.EventEmitter();
            this.styleDataLoading = new core.EventEmitter();
            this.sourceDataLoading = new core.EventEmitter();
            this.styleImageMissing = new core.EventEmitter();
            /**
             * @deprecated Use mapResize instead
             */
            this.resize = new core.EventEmitter();
            /**
             * @deprecated Use mapRemove instead
             */
            this.remove = new core.EventEmitter();
            /**
             * @deprecated Use mapMouseDown instead
             */
            this.mouseDown = new core.EventEmitter();
            /**
             * @deprecated Use mapMouseUp instead
             */
            this.mouseUp = new core.EventEmitter();
            /**
             * @deprecated Use mapMouseMove instead
             */
            this.mouseMove = new core.EventEmitter();
            /**
             * @deprecated Use mapClick instead
             */
            this.click = new core.EventEmitter();
            /**
             * @deprecated Use mapDblClick instead
             */
            this.dblClick = new core.EventEmitter();
            /**
             * @deprecated Use mapMouseOver instead
             */
            this.mouseOver = new core.EventEmitter();
            /**
             * @deprecated Use mapMouseOut instead
             */
            this.mouseOut = new core.EventEmitter();
            /**
             * @deprecated Use mapContextMenu instead
             */
            this.contextMenu = new core.EventEmitter();
            /**
             * @deprecated Use mapTouchStart instead
             */
            this.touchStart = new core.EventEmitter();
            /**
             * @deprecated Use mapTouchEnd instead
             */
            this.touchEnd = new core.EventEmitter();
            /**
             * @deprecated Use mapTouchMove instead
             */
            this.touchMove = new core.EventEmitter();
            /**
             * @deprecated Use mapTouchCancel instead
             */
            this.touchCancel = new core.EventEmitter();
            /**
             * @deprecated Use mapWheel instead
             */
            this.wheel = new core.EventEmitter();
            /**
             * @deprecated Use mapDragStart instead
             */
            this.dragStart = new core.EventEmitter();
            /**
             * @deprecated Use mapDrag instead
             */
            this.drag = new core.EventEmitter();
            /**
             * @deprecated Use mapDragEnd instead
             */
            this.dragEnd = new core.EventEmitter();
            /**
             * @deprecated Use mapLoad instead
             */
            this.load = new core.EventEmitter();
            /**
             * @deprecated Use mapError instead
             */
            this.error = new core.EventEmitter();
        }
        Object.defineProperty(MapComponent.prototype, "mapInstance", {
            get: function () {
                return this.MapService.mapInstance;
            },
            enumerable: false,
            configurable: true
        });
        MapComponent.prototype.ngAfterViewInit = function () {
            this.warnDeprecatedOutputs();
            this.MapService.setup({
                accessToken: this.accessToken,
                customMapboxApiUrl: this.customMapboxApiUrl,
                mapOptions: {
                    collectResourceTiming: this.collectResourceTiming,
                    container: this.mapContainer.nativeElement,
                    crossSourceCollisions: this.crossSourceCollisions,
                    fadeDuration: this.fadeDuration,
                    minZoom: this.minZoom,
                    maxZoom: this.maxZoom,
                    minPitch: this.minPitch,
                    maxPitch: this.maxPitch,
                    style: this.style,
                    hash: this.hash,
                    interactive: this.interactive,
                    bearingSnap: this.bearingSnap,
                    pitchWithRotate: this.pitchWithRotate,
                    clickTolerance: this.clickTolerance,
                    attributionControl: this.attributionControl,
                    logoPosition: this.logoPosition,
                    failIfMajorPerformanceCaveat: this.failIfMajorPerformanceCaveat,
                    preserveDrawingBuffer: this.preserveDrawingBuffer,
                    refreshExpiredTiles: this.refreshExpiredTiles,
                    maxBounds: this.maxBounds,
                    scrollZoom: this.scrollZoom,
                    boxZoom: this.boxZoom,
                    dragRotate: this.dragRotate,
                    dragPan: this.dragPan,
                    keyboard: this.keyboard,
                    doubleClickZoom: this.doubleClickZoom,
                    touchPitch: this.touchPitch,
                    touchZoomRotate: this.touchZoomRotate,
                    trackResize: this.trackResize,
                    center: this.center,
                    zoom: this.zoom,
                    bearing: this.bearing,
                    pitch: this.pitch,
                    renderWorldCopies: this.renderWorldCopies,
                    maxTileCacheSize: this.maxTileCacheSize,
                    localIdeographFontFamily: this.localIdeographFontFamily,
                    transformRequest: this.transformRequest,
                    bounds: this.bounds ? this.bounds : this.fitBounds,
                    fitBoundsOptions: this.fitBoundsOptions,
                    antialias: this.antialias,
                    locale: this.locale,
                },
                mapEvents: this,
            });
            if (this.cursorStyle) {
                this.MapService.changeCanvasCursor(this.cursorStyle);
            }
        };
        MapComponent.prototype.ngOnDestroy = function () {
            this.MapService.destroyMap();
        };
        MapComponent.prototype.ngOnChanges = function (changes) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.MapService.mapCreated$.toPromise()];
                        case 1:
                            _a.sent();
                            if (changes.cursorStyle && !changes.cursorStyle.isFirstChange()) {
                                this.MapService.changeCanvasCursor(changes.cursorStyle.currentValue);
                            }
                            if (changes.minZoom && !changes.minZoom.isFirstChange()) {
                                this.MapService.updateMinZoom(changes.minZoom.currentValue);
                            }
                            if (changes.maxZoom && !changes.maxZoom.isFirstChange()) {
                                this.MapService.updateMaxZoom(changes.maxZoom.currentValue);
                            }
                            if (changes.minPitch && !changes.minPitch.isFirstChange()) {
                                this.MapService.updateMinPitch(changes.minPitch.currentValue);
                            }
                            if (changes.maxPitch && !changes.maxPitch.isFirstChange()) {
                                this.MapService.updateMaxPitch(changes.maxPitch.currentValue);
                            }
                            if (changes.renderWorldCopies &&
                                !changes.renderWorldCopies.isFirstChange()) {
                                this.MapService.updateRenderWorldCopies(changes.renderWorldCopies.currentValue);
                            }
                            if (changes.scrollZoom && !changes.scrollZoom.isFirstChange()) {
                                this.MapService.updateScrollZoom(changes.scrollZoom.currentValue);
                            }
                            if (changes.dragRotate && !changes.dragRotate.isFirstChange()) {
                                this.MapService.updateDragRotate(changes.dragRotate.currentValue);
                            }
                            if (changes.touchPitch && !changes.touchPitch.isFirstChange()) {
                                this.MapService.updateTouchPitch(changes.touchPitch.currentValue);
                            }
                            if (changes.touchZoomRotate && !changes.touchZoomRotate.isFirstChange()) {
                                this.MapService.updateTouchZoomRotate(changes.touchZoomRotate.currentValue);
                            }
                            if (changes.doubleClickZoom && !changes.doubleClickZoom.isFirstChange()) {
                                this.MapService.updateDoubleClickZoom(changes.doubleClickZoom.currentValue);
                            }
                            if (changes.keyboard && !changes.keyboard.isFirstChange()) {
                                this.MapService.updateKeyboard(changes.keyboard.currentValue);
                            }
                            if (changes.dragPan && !changes.dragPan.isFirstChange()) {
                                this.MapService.updateDragPan(changes.dragPan.currentValue);
                            }
                            if (changes.boxZoom && !changes.boxZoom.isFirstChange()) {
                                this.MapService.updateBoxZoom(changes.boxZoom.currentValue);
                            }
                            if (changes.style && !changes.style.isFirstChange()) {
                                this.MapService.updateStyle(changes.style.currentValue);
                            }
                            if (changes.maxBounds && !changes.maxBounds.isFirstChange()) {
                                this.MapService.updateMaxBounds(changes.maxBounds.currentValue);
                            }
                            if (changes.fitBounds &&
                                changes.fitBounds.currentValue &&
                                !changes.fitBounds.isFirstChange()) {
                                this.MapService.fitBounds(changes.fitBounds.currentValue, this.fitBoundsOptions);
                            }
                            if (changes.fitScreenCoordinates &&
                                changes.fitScreenCoordinates.currentValue) {
                                if ((this.center || this.zoom || this.pitch || this.fitBounds) &&
                                    changes.fitScreenCoordinates.isFirstChange()) {
                                    console.warn('[ngx-mapbox-gl] center / zoom / pitch / fitBounds inputs are being overridden by fitScreenCoordinates input');
                                }
                                this.MapService.fitScreenCoordinates(changes.fitScreenCoordinates.currentValue, this.bearing ? this.bearing[0] : 0, this.movingOptions);
                            }
                            if (this.centerWithPanTo &&
                                changes.center &&
                                !changes.center.isFirstChange() &&
                                !changes.zoom &&
                                !changes.bearing &&
                                !changes.pitch) {
                                this.MapService.panTo(this.center, this.panToOptions);
                            }
                            else if ((changes.center && !changes.center.isFirstChange()) ||
                                (changes.zoom && !changes.zoom.isFirstChange()) ||
                                (changes.bearing &&
                                    !changes.bearing.isFirstChange() &&
                                    !changes.fitScreenCoordinates) ||
                                (changes.pitch && !changes.pitch.isFirstChange())) {
                                this.MapService.move(this.movingMethod, this.movingOptions, changes.zoom && this.zoom ? this.zoom[0] : undefined, changes.center ? this.center : undefined, changes.bearing && this.bearing ? this.bearing[0] : undefined, changes.pitch && this.pitch ? this.pitch[0] : undefined);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        MapComponent.prototype.warnDeprecatedOutputs = function () {
            var dw = deprecationWarning.bind(undefined, MapComponent.name);
            if (this.resize.observers.length) {
                dw('resize', 'mapResize');
            }
            if (this.remove.observers.length) {
                dw('remove', 'mapRemove');
            }
            if (this.mouseDown.observers.length) {
                dw('mouseDown', 'mapMouseDown');
            }
            if (this.mouseUp.observers.length) {
                dw('mouseUp', 'mapMouseUp');
            }
            if (this.mouseMove.observers.length) {
                dw('mouseMove', 'mapMouseMove');
            }
            if (this.click.observers.length) {
                dw('click', 'mapClick');
            }
            if (this.dblClick.observers.length) {
                dw('dblClick', 'mapDblClick');
            }
            if (this.mouseOver.observers.length) {
                dw('mouseOver', 'mapMouseOver');
            }
            if (this.mouseOut.observers.length) {
                dw('mouseOut', 'mapMouseOut');
            }
            if (this.contextMenu.observers.length) {
                dw('contextMenu', 'mapContextMenu');
            }
            if (this.touchStart.observers.length) {
                dw('touchStart', 'mapTouchStart');
            }
            if (this.touchEnd.observers.length) {
                dw('touchEnd', 'mapTouchEnd');
            }
            if (this.touchMove.observers.length) {
                dw('touchMove', 'mapTouchMove');
            }
            if (this.touchCancel.observers.length) {
                dw('touchCancel', 'mapTouchCancel');
            }
            if (this.wheel.observers.length) {
                dw('wheel', 'mapWheel');
            }
            if (this.dragStart.observers.length) {
                dw('dragStart', 'mapDragStart');
            }
            if (this.drag.observers.length) {
                dw('drag', 'mapDrag');
            }
            if (this.dragEnd.observers.length) {
                dw('dragEnd', 'mapDragEnd');
            }
            if (this.load.observers.length) {
                dw('load', 'mapLoad');
            }
            if (this.error.observers.length) {
                dw('error', 'mapError');
            }
        };
        return MapComponent;
    }());
    MapComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-map',
                    template: '<div #container></div>',
                    providers: [MapService],
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: ["\n      :host {\n        display: block;\n      }\n      div {\n        height: 100%;\n        width: 100%;\n      }\n    "]
                },] }
    ];
    MapComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    MapComponent.propDecorators = {
        accessToken: [{ type: core.Input }],
        collectResourceTiming: [{ type: core.Input }],
        crossSourceCollisions: [{ type: core.Input }],
        customMapboxApiUrl: [{ type: core.Input }],
        fadeDuration: [{ type: core.Input }],
        hash: [{ type: core.Input }],
        refreshExpiredTiles: [{ type: core.Input }],
        failIfMajorPerformanceCaveat: [{ type: core.Input }],
        bearingSnap: [{ type: core.Input }],
        interactive: [{ type: core.Input }],
        pitchWithRotate: [{ type: core.Input }],
        clickTolerance: [{ type: core.Input }],
        attributionControl: [{ type: core.Input }],
        logoPosition: [{ type: core.Input }],
        maxTileCacheSize: [{ type: core.Input }],
        localIdeographFontFamily: [{ type: core.Input }],
        preserveDrawingBuffer: [{ type: core.Input }],
        trackResize: [{ type: core.Input }],
        transformRequest: [{ type: core.Input }],
        bounds: [{ type: core.Input }],
        antialias: [{ type: core.Input }],
        locale: [{ type: core.Input }],
        minZoom: [{ type: core.Input }],
        maxZoom: [{ type: core.Input }],
        minPitch: [{ type: core.Input }],
        maxPitch: [{ type: core.Input }],
        scrollZoom: [{ type: core.Input }],
        dragRotate: [{ type: core.Input }],
        touchPitch: [{ type: core.Input }],
        touchZoomRotate: [{ type: core.Input }],
        doubleClickZoom: [{ type: core.Input }],
        keyboard: [{ type: core.Input }],
        dragPan: [{ type: core.Input }],
        boxZoom: [{ type: core.Input }],
        style: [{ type: core.Input }],
        center: [{ type: core.Input }],
        maxBounds: [{ type: core.Input }],
        zoom: [{ type: core.Input }],
        bearing: [{ type: core.Input }],
        pitch: [{ type: core.Input }],
        fitBoundsOptions: [{ type: core.Input }],
        renderWorldCopies: [{ type: core.Input }],
        movingMethod: [{ type: core.Input }],
        movingOptions: [{ type: core.Input }],
        fitBounds: [{ type: core.Input }],
        fitScreenCoordinates: [{ type: core.Input }],
        centerWithPanTo: [{ type: core.Input }],
        panToOptions: [{ type: core.Input }],
        cursorStyle: [{ type: core.Input }],
        mapResize: [{ type: core.Output }],
        mapRemove: [{ type: core.Output }],
        mapMouseDown: [{ type: core.Output }],
        mapMouseUp: [{ type: core.Output }],
        mapMouseMove: [{ type: core.Output }],
        mapClick: [{ type: core.Output }],
        mapDblClick: [{ type: core.Output }],
        mapMouseOver: [{ type: core.Output }],
        mapMouseOut: [{ type: core.Output }],
        mapContextMenu: [{ type: core.Output }],
        mapTouchStart: [{ type: core.Output }],
        mapTouchEnd: [{ type: core.Output }],
        mapTouchMove: [{ type: core.Output }],
        mapTouchCancel: [{ type: core.Output }],
        mapWheel: [{ type: core.Output }],
        moveStart: [{ type: core.Output }],
        move: [{ type: core.Output }],
        moveEnd: [{ type: core.Output }],
        mapDragStart: [{ type: core.Output }],
        mapDrag: [{ type: core.Output }],
        mapDragEnd: [{ type: core.Output }],
        zoomStart: [{ type: core.Output }],
        zoomEvt: [{ type: core.Output }],
        zoomEnd: [{ type: core.Output }],
        rotateStart: [{ type: core.Output }],
        rotate: [{ type: core.Output }],
        rotateEnd: [{ type: core.Output }],
        pitchStart: [{ type: core.Output }],
        pitchEvt: [{ type: core.Output }],
        pitchEnd: [{ type: core.Output }],
        boxZoomStart: [{ type: core.Output }],
        boxZoomEnd: [{ type: core.Output }],
        boxZoomCancel: [{ type: core.Output }],
        webGlContextLost: [{ type: core.Output }],
        webGlContextRestored: [{ type: core.Output }],
        mapLoad: [{ type: core.Output }],
        idle: [{ type: core.Output }],
        render: [{ type: core.Output }],
        mapError: [{ type: core.Output }],
        data: [{ type: core.Output }],
        styleData: [{ type: core.Output }],
        sourceData: [{ type: core.Output }],
        dataLoading: [{ type: core.Output }],
        styleDataLoading: [{ type: core.Output }],
        sourceDataLoading: [{ type: core.Output }],
        styleImageMissing: [{ type: core.Output }],
        resize: [{ type: core.Output }],
        remove: [{ type: core.Output }],
        mouseDown: [{ type: core.Output }],
        mouseUp: [{ type: core.Output }],
        mouseMove: [{ type: core.Output }],
        click: [{ type: core.Output }],
        dblClick: [{ type: core.Output }],
        mouseOver: [{ type: core.Output }],
        mouseOut: [{ type: core.Output }],
        contextMenu: [{ type: core.Output }],
        touchStart: [{ type: core.Output }],
        touchEnd: [{ type: core.Output }],
        touchMove: [{ type: core.Output }],
        touchCancel: [{ type: core.Output }],
        wheel: [{ type: core.Output }],
        dragStart: [{ type: core.Output }],
        drag: [{ type: core.Output }],
        dragEnd: [{ type: core.Output }],
        load: [{ type: core.Output }],
        error: [{ type: core.Output }],
        mapContainer: [{ type: core.ViewChild, args: ['container', { static: true },] }]
    };

    var MarkerComponent = /** @class */ (function () {
        function MarkerComponent(MapService) {
            this.MapService = MapService;
            this.markerDragStart = new core.EventEmitter();
            this.markerDragEnd = new core.EventEmitter();
            this.markerDrag = new core.EventEmitter();
            /**
             * @deprecated Use markerDragStart instead
             */
            this.dragStart = new core.EventEmitter();
            /**
             * @deprecated Use markerDragEnd instead
             */
            this.dragEnd = new core.EventEmitter();
            /**
             * @deprecated Use markerDrag instead
             */
            this.drag = new core.EventEmitter();
        }
        MarkerComponent.prototype.ngOnInit = function () {
            this.warnDeprecatedOutputs();
            if (this.feature && this.lngLat) {
                throw new Error('feature and lngLat input are mutually exclusive');
            }
        };
        MarkerComponent.prototype.ngOnChanges = function (changes) {
            if (changes.lngLat && !changes.lngLat.isFirstChange()) {
                this.markerInstance.setLngLat(this.lngLat);
            }
            if (changes.feature && !changes.feature.isFirstChange()) {
                this.markerInstance.setLngLat(this.feature.geometry.coordinates);
            }
            if (changes.draggable && !changes.draggable.isFirstChange()) {
                this.markerInstance.setDraggable(!!this.draggable);
            }
            if (changes.popupShown && !changes.popupShown.isFirstChange()) {
                changes.popupShown.currentValue
                    ? this.markerInstance.getPopup().addTo(this.MapService.mapInstance)
                    : this.markerInstance.getPopup().remove();
            }
            if (changes.pitchAlignment && !changes.pitchAlignment.isFirstChange()) {
                this.markerInstance.setPitchAlignment(changes.pitchAlignment.currentValue);
            }
            if (changes.rotationAlignment &&
                !changes.rotationAlignment.isFirstChange()) {
                this.markerInstance.setRotationAlignment(changes.rotationAlignment.currentValue);
            }
        };
        MarkerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.MapService.mapCreated$.subscribe(function () {
                _this.markerInstance = _this.MapService.addMarker({
                    markersOptions: {
                        offset: _this.offset,
                        anchor: _this.anchor,
                        pitchAlignment: _this.pitchAlignment,
                        rotationAlignment: _this.rotationAlignment,
                        draggable: !!_this.draggable,
                        element: _this.content.nativeElement,
                        feature: _this.feature,
                        lngLat: _this.lngLat,
                        clickTolerance: _this.clickTolerance,
                    },
                    markersEvents: {
                        markerDragStart: _this.markerDragStart,
                        markerDrag: _this.markerDrag,
                        markerDragEnd: _this.markerDragEnd,
                        dragStart: _this.dragStart,
                        drag: _this.drag,
                        dragEnd: _this.dragEnd,
                    },
                });
            });
        };
        MarkerComponent.prototype.ngOnDestroy = function () {
            this.MapService.removeMarker(this.markerInstance);
            this.markerInstance = undefined;
        };
        MarkerComponent.prototype.togglePopup = function () {
            this.markerInstance.togglePopup();
        };
        MarkerComponent.prototype.updateCoordinates = function (coordinates) {
            this.markerInstance.setLngLat(coordinates);
        };
        MarkerComponent.prototype.warnDeprecatedOutputs = function () {
            var dw = deprecationWarning.bind(undefined, MarkerComponent.name);
            if (this.dragStart.observers.length) {
                dw('dragStart', 'markerDragStart');
            }
            if (this.dragEnd.observers.length) {
                dw('dragEnd', 'markerDragEnd');
            }
            if (this.drag.observers.length) {
                dw('drag', 'markerDrag');
            }
        };
        return MarkerComponent;
    }());
    MarkerComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-marker',
                    template: '<div [class]="className" #content><ng-content></ng-content></div>',
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    MarkerComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    MarkerComponent.propDecorators = {
        offset: [{ type: core.Input }],
        anchor: [{ type: core.Input }],
        clickTolerance: [{ type: core.Input }],
        feature: [{ type: core.Input }],
        lngLat: [{ type: core.Input }],
        draggable: [{ type: core.Input }],
        popupShown: [{ type: core.Input }],
        className: [{ type: core.Input }],
        pitchAlignment: [{ type: core.Input }],
        rotationAlignment: [{ type: core.Input }],
        markerDragStart: [{ type: core.Output }],
        markerDragEnd: [{ type: core.Output }],
        markerDrag: [{ type: core.Output }],
        dragStart: [{ type: core.Output }],
        dragEnd: [{ type: core.Output }],
        drag: [{ type: core.Output }],
        content: [{ type: core.ViewChild, args: ['content', { static: true },] }]
    };

    var PointDirective = /** @class */ (function () {
        function PointDirective() {
        }
        return PointDirective;
    }());
    PointDirective.decorators = [
        { type: core.Directive, args: [{ selector: 'ng-template[mglPoint]' },] }
    ];
    var ClusterPointDirective = /** @class */ (function () {
        function ClusterPointDirective() {
        }
        return ClusterPointDirective;
    }());
    ClusterPointDirective.decorators = [
        { type: core.Directive, args: [{ selector: 'ng-template[mglClusterPoint]' },] }
    ];
    var uniqId = 0;
    var MarkersForClustersComponent = /** @class */ (function () {
        function MarkersForClustersComponent(MapService, ChangeDetectorRef, zone) {
            this.MapService = MapService;
            this.ChangeDetectorRef = ChangeDetectorRef;
            this.zone = zone;
            this.layerId = "mgl-markers-for-clusters-" + uniqId++;
            this.sub = new rxjs.Subscription();
        }
        MarkersForClustersComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            var clusterDataUpdate = function () { return rxjs.fromEvent(_this.MapService.mapInstance, 'data').pipe(operators.filter(function (e) { return e.sourceId === _this.source &&
                e.sourceDataType !== 'metadata' &&
                _this.MapService.mapInstance.isSourceLoaded(_this.source); })); };
            var sub = this.MapService.mapCreated$
                .pipe(operators.switchMap(clusterDataUpdate), operators.switchMap(function () { return rxjs.merge(rxjs.fromEvent(_this.MapService.mapInstance, 'move'), rxjs.fromEvent(_this.MapService.mapInstance, 'moveend')).pipe(operators.startWith(undefined)); }))
                .subscribe(function () {
                _this.zone.run(function () {
                    _this.updateCluster();
                });
            });
            this.sub.add(sub);
        };
        MarkersForClustersComponent.prototype.ngOnDestroy = function () {
            this.sub.unsubscribe();
        };
        MarkersForClustersComponent.prototype.trackByClusterPoint = function (_index, clusterPoint) {
            return clusterPoint.id;
        };
        MarkersForClustersComponent.prototype.updateCluster = function () {
            // Invalid queryRenderedFeatures typing
            var params = { layers: [this.layerId] };
            if (!this.pointTpl) {
                params.filter = ['==', 'cluster', true];
            }
            this.clusterPoints = this.MapService.mapInstance.queryRenderedFeatures(params);
            this.ChangeDetectorRef.markForCheck();
        };
        return MarkersForClustersComponent;
    }());
    MarkersForClustersComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-markers-for-clusters',
                    template: "\n    <mgl-layer\n      [id]=\"layerId\"\n      [source]=\"source\"\n      type=\"circle\"\n      [paint]=\"{ 'circle-radius': 0 }\"\n    ></mgl-layer>\n    <ng-container\n      *ngFor=\"let feature of clusterPoints; trackBy: trackByClusterPoint\"\n    >\n      <ng-container *ngIf=\"feature.properties.cluster\">\n        <mgl-marker [feature]=\"feature\">\n          <ng-container\n            *ngTemplateOutlet=\"clusterPointTpl; context: { $implicit: feature }\"\n          ></ng-container>\n        </mgl-marker>\n      </ng-container>\n      <ng-container *ngIf=\"!feature.properties.cluster\">\n        <mgl-marker [feature]=\"feature\">\n          <ng-container\n            *ngTemplateOutlet=\"pointTpl; context: { $implicit: feature }\"\n          ></ng-container>\n        </mgl-marker>\n      </ng-container>\n    </ng-container>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false
                },] }
    ];
    MarkersForClustersComponent.ctorParameters = function () { return [
        { type: MapService },
        { type: core.ChangeDetectorRef },
        { type: core.NgZone }
    ]; };
    MarkersForClustersComponent.propDecorators = {
        source: [{ type: core.Input }],
        pointTpl: [{ type: core.ContentChild, args: [PointDirective, { read: core.TemplateRef, static: false },] }],
        clusterPointTpl: [{ type: core.ContentChild, args: [ClusterPointDirective, { read: core.TemplateRef, static: false },] }]
    };

    var PopupComponent = /** @class */ (function () {
        function PopupComponent(MapService) {
            this.MapService = MapService;
            this.popupClose = new core.EventEmitter();
            this.popupOpen = new core.EventEmitter();
            /**
             * @deprecated Use popupClose instead
             */
            this.close = new core.EventEmitter();
            /**
             * @deprecated Use popupOpen instead
             */
            this.open = new core.EventEmitter();
        }
        PopupComponent.prototype.ngOnInit = function () {
            this.warnDeprecatedOutputs();
            if ((this.lngLat && this.marker) ||
                (this.feature && this.lngLat) ||
                (this.feature && this.marker)) {
                throw new Error('marker, lngLat, feature input are mutually exclusive');
            }
        };
        PopupComponent.prototype.ngOnChanges = function (changes) {
            if ((changes.lngLat && !changes.lngLat.isFirstChange()) ||
                (changes.feature && !changes.feature.isFirstChange())) {
                var newlngLat = changes.lngLat
                    ? this.lngLat
                    : this.feature.geometry.coordinates;
                this.MapService.removePopupFromMap(this.popupInstance, true);
                var popupInstanceTmp = this.createPopup();
                this.MapService.addPopupToMap(popupInstanceTmp, newlngLat, this.popupInstance.isOpen());
                this.popupInstance = popupInstanceTmp;
            }
            if (changes.marker && !changes.marker.isFirstChange()) {
                var previousMarker = changes.marker.previousValue;
                if (previousMarker.markerInstance) {
                    this.MapService.removePopupFromMarker(previousMarker.markerInstance);
                }
                if (this.marker && this.marker.markerInstance && this.popupInstance) {
                    this.MapService.addPopupToMarker(this.marker.markerInstance, this.popupInstance);
                }
            }
            if (changes.offset &&
                !changes.offset.isFirstChange() &&
                this.popupInstance) {
                this.popupInstance.setOffset(this.offset);
            }
        };
        PopupComponent.prototype.ngAfterViewInit = function () {
            this.popupInstance = this.createPopup();
            this.addPopup(this.popupInstance);
        };
        PopupComponent.prototype.ngOnDestroy = function () {
            if (this.popupInstance) {
                if (this.lngLat || this.feature) {
                    this.MapService.removePopupFromMap(this.popupInstance);
                }
                else if (this.marker && this.marker.markerInstance) {
                    this.MapService.removePopupFromMarker(this.marker.markerInstance);
                }
            }
            this.popupInstance = undefined;
        };
        PopupComponent.prototype.createPopup = function () {
            return this.MapService.createPopup({
                popupOptions: {
                    closeButton: this.closeButton,
                    closeOnClick: this.closeOnClick,
                    anchor: this.anchor,
                    offset: this.offset,
                    className: this.className,
                    maxWidth: this.maxWidth,
                },
                popupEvents: {
                    open: this.open,
                    close: this.close,
                    popupOpen: this.popupOpen,
                    popupClose: this.popupClose,
                },
            }, this.content.nativeElement);
        };
        PopupComponent.prototype.addPopup = function (popup) {
            var _this = this;
            this.MapService.mapCreated$.subscribe(function () {
                if (_this.lngLat || _this.feature) {
                    _this.MapService.addPopupToMap(popup, _this.lngLat
                        ? _this.lngLat
                        : _this.feature.geometry.coordinates);
                }
                else if (_this.marker && _this.marker.markerInstance) {
                    _this.MapService.addPopupToMarker(_this.marker.markerInstance, popup);
                }
                else {
                    throw new Error('mgl-popup need either lngLat/marker/feature to be set');
                }
            });
        };
        PopupComponent.prototype.warnDeprecatedOutputs = function () {
            var dw = deprecationWarning.bind(undefined, PopupComponent.name);
            if (this.close.observers.length) {
                dw('close', 'popupClose');
            }
            if (this.open.observers.length) {
                dw('open', 'popupOpen');
            }
        };
        return PopupComponent;
    }());
    PopupComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-popup',
                    template: '<div #content><ng-content></ng-content></div>',
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    PopupComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    PopupComponent.propDecorators = {
        closeButton: [{ type: core.Input }],
        closeOnClick: [{ type: core.Input }],
        anchor: [{ type: core.Input }],
        className: [{ type: core.Input }],
        maxWidth: [{ type: core.Input }],
        feature: [{ type: core.Input }],
        lngLat: [{ type: core.Input }],
        marker: [{ type: core.Input }],
        offset: [{ type: core.Input }],
        popupClose: [{ type: core.Output }],
        popupOpen: [{ type: core.Output }],
        close: [{ type: core.Output }],
        open: [{ type: core.Output }],
        content: [{ type: core.ViewChild, args: ['content', { static: true },] }]
    };

    var CanvasSourceComponent = /** @class */ (function () {
        function CanvasSourceComponent(MapService) {
            this.MapService = MapService;
            this.sourceAdded = false;
            this.sub = new rxjs.Subscription();
        }
        CanvasSourceComponent.prototype.ngOnInit = function () {
            var _this = this;
            var sub1 = this.MapService.mapLoaded$.subscribe(function () {
                _this.init();
                var sub = rxjs.fromEvent(_this.MapService.mapInstance, 'styledata')
                    .pipe(operators.filter(function () { return !_this.MapService.mapInstance.getSource(_this.id); }))
                    .subscribe(function () {
                    _this.init();
                });
                _this.sub.add(sub);
            });
            this.sub.add(sub1);
        };
        CanvasSourceComponent.prototype.ngOnChanges = function (changes) {
            if (!this.sourceAdded) {
                return;
            }
            if ((changes.canvas && !changes.canvas.isFirstChange()) ||
                (changes.animate && !changes.animate.isFirstChange())) {
                this.ngOnDestroy();
                this.ngOnInit();
            }
            else if (changes.coordinates && !changes.coordinates.isFirstChange()) {
                var source = this.MapService.getSource(this.id);
                source.setCoordinates(this.coordinates);
            }
        };
        CanvasSourceComponent.prototype.ngOnDestroy = function () {
            this.sub.unsubscribe();
            if (this.sourceAdded) {
                this.MapService.removeSource(this.id);
                this.sourceAdded = false;
            }
        };
        CanvasSourceComponent.prototype.init = function () {
            var source = {
                type: 'canvas',
                coordinates: this.coordinates,
                canvas: this.canvas,
                animate: this.animate,
            };
            this.MapService.addSource(this.id, source);
            this.sourceAdded = true;
        };
        return CanvasSourceComponent;
    }());
    CanvasSourceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-canvas-source',
                    template: '',
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CanvasSourceComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    CanvasSourceComponent.propDecorators = {
        id: [{ type: core.Input }],
        coordinates: [{ type: core.Input }],
        canvas: [{ type: core.Input }],
        animate: [{ type: core.Input }]
    };

    var ImageSourceComponent = /** @class */ (function () {
        function ImageSourceComponent(MapService) {
            this.MapService = MapService;
        }
        ImageSourceComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.sub = this.MapService.mapLoaded$.subscribe(function () { return _this.init(); });
        };
        ImageSourceComponent.prototype.ngOnChanges = function (changes) {
            if (this.sourceId === undefined) {
                return;
            }
            var source = this.MapService.getSource(this.sourceId);
            source.updateImage({
                url: changes.url === undefined ? undefined : this.url,
                coordinates: changes.coordinates === undefined ? undefined : this.coordinates,
            });
        };
        ImageSourceComponent.prototype.ngOnDestroy = function () {
            if (this.sub !== undefined) {
                this.sub.unsubscribe();
            }
            if (this.sourceId !== undefined) {
                this.MapService.removeSource(this.sourceId);
                this.sourceId = undefined;
            }
        };
        ImageSourceComponent.prototype.init = function () {
            var imageSource = {
                type: 'image',
                url: this.url,
                coordinates: this.coordinates,
            };
            this.MapService.addSource(this.id, imageSource);
            this.sourceId = this.id;
        };
        return ImageSourceComponent;
    }());
    ImageSourceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-image-source',
                    template: '',
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ImageSourceComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    ImageSourceComponent.propDecorators = {
        id: [{ type: core.Input }],
        url: [{ type: core.Input }],
        coordinates: [{ type: core.Input }]
    };

    var RasterDemSourceComponent = /** @class */ (function () {
        function RasterDemSourceComponent(MapService) {
            this.MapService = MapService;
            this.type = 'raster-dem';
            this.sourceAdded = false;
            this.sub = new rxjs.Subscription();
        }
        RasterDemSourceComponent.prototype.ngOnInit = function () {
            var _this = this;
            var sub1 = this.MapService.mapLoaded$.subscribe(function () {
                _this.init();
                var sub = rxjs.fromEvent(_this.MapService.mapInstance, 'styledata')
                    .pipe(operators.filter(function () { return !_this.MapService.mapInstance.getSource(_this.id); }))
                    .subscribe(function () {
                    _this.init();
                });
                _this.sub.add(sub);
            });
            this.sub.add(sub1);
        };
        RasterDemSourceComponent.prototype.ngOnChanges = function (changes) {
            if (!this.sourceAdded) {
                return;
            }
            if ((changes.url && !changes.url.isFirstChange()) ||
                (changes.tiles && !changes.tiles.isFirstChange()) ||
                (changes.bounds && !changes.bounds.isFirstChange()) ||
                (changes.minzoom && !changes.minzoom.isFirstChange()) ||
                (changes.maxzoom && !changes.maxzoom.isFirstChange()) ||
                (changes.tileSize && !changes.tileSize.isFirstChange()) ||
                (changes.attribution && !changes.attribution.isFirstChange()) ||
                (changes.encoding && !changes.encoding.isFirstChange())) {
                this.ngOnDestroy();
                this.ngOnInit();
            }
        };
        RasterDemSourceComponent.prototype.ngOnDestroy = function () {
            this.sub.unsubscribe();
            if (this.sourceAdded) {
                this.MapService.removeSource(this.id);
                this.sourceAdded = false;
            }
        };
        RasterDemSourceComponent.prototype.init = function () {
            var source = {
                type: this.type,
                url: this.url,
                tiles: this.tiles,
                bounds: this.bounds,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                tileSize: this.tileSize,
                attribution: this.attribution,
                encoding: this.encoding,
            };
            this.MapService.addSource(this.id, source);
            this.sourceAdded = true;
        };
        return RasterDemSourceComponent;
    }());
    RasterDemSourceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-raster-dem-source',
                    template: '',
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    RasterDemSourceComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    RasterDemSourceComponent.propDecorators = {
        id: [{ type: core.Input }],
        url: [{ type: core.Input }],
        tiles: [{ type: core.Input }],
        bounds: [{ type: core.Input }],
        minzoom: [{ type: core.Input }],
        maxzoom: [{ type: core.Input }],
        tileSize: [{ type: core.Input }],
        attribution: [{ type: core.Input }],
        encoding: [{ type: core.Input }]
    };

    var RasterSourceComponent = /** @class */ (function () {
        function RasterSourceComponent(MapService) {
            this.MapService = MapService;
            this.type = 'raster';
            this.sourceAdded = false;
            this.sub = new rxjs.Subscription();
        }
        RasterSourceComponent.prototype.ngOnInit = function () {
            var _this = this;
            var sub1 = this.MapService.mapLoaded$.subscribe(function () {
                _this.init();
                var sub = rxjs.fromEvent(_this.MapService.mapInstance, 'styledata')
                    .pipe(operators.filter(function () { return !_this.MapService.mapInstance.getSource(_this.id); }))
                    .subscribe(function () {
                    _this.init();
                });
                _this.sub.add(sub);
            });
            this.sub.add(sub1);
        };
        RasterSourceComponent.prototype.ngOnChanges = function (changes) {
            if (!this.sourceAdded) {
                return;
            }
            if ((changes.url && !changes.url.isFirstChange()) ||
                (changes.tiles && !changes.tiles.isFirstChange()) ||
                (changes.bounds && !changes.bounds.isFirstChange()) ||
                (changes.minzoom && !changes.minzoom.isFirstChange()) ||
                (changes.maxzoom && !changes.maxzoom.isFirstChange()) ||
                (changes.tileSize && !changes.tileSize.isFirstChange()) ||
                (changes.scheme && !changes.scheme.isFirstChange()) ||
                (changes.attribution && !changes.attribution.isFirstChange())) {
                this.ngOnDestroy();
                this.ngOnInit();
            }
        };
        RasterSourceComponent.prototype.ngOnDestroy = function () {
            this.sub.unsubscribe();
            if (this.sourceAdded) {
                this.MapService.removeSource(this.id);
                this.sourceAdded = false;
            }
        };
        RasterSourceComponent.prototype.init = function () {
            var source = {
                type: this.type,
                url: this.url,
                tiles: this.tiles,
                bounds: this.bounds,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                tileSize: this.tileSize,
                scheme: this.scheme,
                attribution: this.attribution,
            };
            this.MapService.addSource(this.id, source);
            this.sourceAdded = true;
        };
        return RasterSourceComponent;
    }());
    RasterSourceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-raster-source',
                    template: '',
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    RasterSourceComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    RasterSourceComponent.propDecorators = {
        id: [{ type: core.Input }],
        url: [{ type: core.Input }],
        tiles: [{ type: core.Input }],
        bounds: [{ type: core.Input }],
        minzoom: [{ type: core.Input }],
        maxzoom: [{ type: core.Input }],
        tileSize: [{ type: core.Input }],
        scheme: [{ type: core.Input }],
        attribution: [{ type: core.Input }]
    };

    var VectorSourceComponent = /** @class */ (function () {
        function VectorSourceComponent(MapService) {
            this.MapService = MapService;
            this.type = 'vector';
            this.sourceAdded = false;
            this.sub = new rxjs.Subscription();
        }
        VectorSourceComponent.prototype.ngOnInit = function () {
            var _this = this;
            var sub1 = this.MapService.mapLoaded$.subscribe(function () {
                _this.init();
                var sub = rxjs.fromEvent(_this.MapService.mapInstance, 'styledata')
                    .pipe(operators.filter(function () { return !_this.MapService.mapInstance.getSource(_this.id); }))
                    .subscribe(function () {
                    _this.init();
                });
                _this.sub.add(sub);
            });
            this.sub.add(sub1);
        };
        VectorSourceComponent.prototype.ngOnChanges = function (changes) {
            if (!this.sourceAdded) {
                return;
            }
            if ((changes.bounds && !changes.bounds.isFirstChange()) ||
                (changes.scheme && !changes.scheme.isFirstChange()) ||
                (changes.minzoom && !changes.minzoom.isFirstChange()) ||
                (changes.maxzoom && !changes.maxzoom.isFirstChange()) ||
                (changes.attribution && !changes.attribution.isFirstChange()) ||
                (changes.promoteId && !changes.promoteId.isFirstChange())) {
                this.ngOnDestroy();
                this.ngOnInit();
            }
            else if ((changes.url && !changes.url.isFirstChange()) ||
                (changes.tiles && !changes.tiles.isFirstChange())) {
                var source = this.MapService.getSource(this.id);
                if (changes.url && this.url) {
                    source.setUrl(this.url);
                }
                if (changes.tiles && this.tiles) {
                    source.setTiles(this.tiles);
                }
            }
        };
        VectorSourceComponent.prototype.ngOnDestroy = function () {
            this.sub.unsubscribe();
            if (this.sourceAdded) {
                this.MapService.removeSource(this.id);
                this.sourceAdded = false;
            }
        };
        VectorSourceComponent.prototype.init = function () {
            var source = {
                type: this.type,
                url: this.url,
                tiles: this.tiles,
                bounds: this.bounds,
                scheme: this.scheme,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                attribution: this.attribution,
                promoteId: this.promoteId,
            };
            this.MapService.addSource(this.id, source);
            this.sourceAdded = true;
        };
        return VectorSourceComponent;
    }());
    VectorSourceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-vector-source',
                    template: '',
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    VectorSourceComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    VectorSourceComponent.propDecorators = {
        id: [{ type: core.Input }],
        url: [{ type: core.Input }],
        tiles: [{ type: core.Input }],
        bounds: [{ type: core.Input }],
        scheme: [{ type: core.Input }],
        minzoom: [{ type: core.Input }],
        maxzoom: [{ type: core.Input }],
        attribution: [{ type: core.Input }],
        promoteId: [{ type: core.Input }]
    };

    var VideoSourceComponent = /** @class */ (function () {
        function VideoSourceComponent(MapService) {
            this.MapService = MapService;
            this.sourceAdded = false;
            this.sub = new rxjs.Subscription();
        }
        VideoSourceComponent.prototype.ngOnInit = function () {
            var _this = this;
            var sub1 = this.MapService.mapLoaded$.subscribe(function () {
                _this.init();
                var sub = rxjs.fromEvent(_this.MapService.mapInstance, 'styledata')
                    .pipe(operators.filter(function () { return !_this.MapService.mapInstance.getSource(_this.id); }))
                    .subscribe(function () {
                    _this.init();
                });
                _this.sub.add(sub);
            });
            this.sub.add(sub1);
        };
        VideoSourceComponent.prototype.ngOnChanges = function (changes) {
            if (!this.sourceAdded) {
                return;
            }
            if (changes.urls && !changes.urls.isFirstChange()) {
                this.ngOnDestroy();
                this.ngOnInit();
            }
            else if (changes.coordinates && !changes.coordinates.isFirstChange()) {
                var source = this.MapService.getSource(this.id);
                source.setCoordinates(this.coordinates);
            }
        };
        VideoSourceComponent.prototype.ngOnDestroy = function () {
            this.sub.unsubscribe();
            if (this.sourceAdded) {
                this.MapService.removeSource(this.id);
                this.sourceAdded = false;
            }
        };
        VideoSourceComponent.prototype.init = function () {
            var source = {
                type: 'video',
                urls: this.urls,
                coordinates: this.coordinates,
            };
            this.MapService.addSource(this.id, source);
            this.sourceAdded = true;
        };
        return VideoSourceComponent;
    }());
    VideoSourceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mgl-video-source',
                    template: '',
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    VideoSourceComponent.ctorParameters = function () { return [
        { type: MapService }
    ]; };
    VideoSourceComponent.propDecorators = {
        id: [{ type: core.Input }],
        urls: [{ type: core.Input }],
        coordinates: [{ type: core.Input }]
    };

    var NgxMapboxGLModule = /** @class */ (function () {
        function NgxMapboxGLModule() {
        }
        NgxMapboxGLModule.withConfig = function (config) {
            return {
                ngModule: NgxMapboxGLModule,
                providers: [
                    {
                        provide: MAPBOX_API_KEY,
                        useValue: config.accessToken,
                    },
                    {
                        provide: MAPBOX_GEOCODER_API_KEY,
                        useValue: config.geocoderAccessToken || config.accessToken,
                    },
                ],
            };
        };
        return NgxMapboxGLModule;
    }());
    NgxMapboxGLModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule],
                    declarations: [
                        MapComponent,
                        LayerComponent,
                        DraggableDirective,
                        ImageComponent,
                        VectorSourceComponent,
                        GeoJSONSourceComponent,
                        RasterDemSourceComponent,
                        RasterSourceComponent,
                        ImageSourceComponent,
                        VideoSourceComponent,
                        CanvasSourceComponent,
                        FeatureComponent,
                        MarkerComponent,
                        PopupComponent,
                        ControlComponent,
                        FullscreenControlDirective,
                        NavigationControlDirective,
                        GeocoderControlDirective,
                        GeolocateControlDirective,
                        AttributionControlDirective,
                        ScaleControlDirective,
                        PointDirective,
                        ClusterPointDirective,
                        MarkersForClustersComponent,
                    ],
                    exports: [
                        MapComponent,
                        LayerComponent,
                        DraggableDirective,
                        ImageComponent,
                        VectorSourceComponent,
                        GeoJSONSourceComponent,
                        RasterDemSourceComponent,
                        RasterSourceComponent,
                        ImageSourceComponent,
                        VideoSourceComponent,
                        CanvasSourceComponent,
                        FeatureComponent,
                        MarkerComponent,
                        PopupComponent,
                        ControlComponent,
                        FullscreenControlDirective,
                        NavigationControlDirective,
                        GeocoderControlDirective,
                        GeolocateControlDirective,
                        AttributionControlDirective,
                        ScaleControlDirective,
                        PointDirective,
                        ClusterPointDirective,
                        MarkersForClustersComponent,
                    ],
                },] }
    ];

    /*
     * Public API Surface of ngx-mapbox-gl
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ControlComponent = ControlComponent;
    exports.CustomControl = CustomControl;
    exports.GeoJSONSourceComponent = GeoJSONSourceComponent;
    exports.MAPBOX_API_KEY = MAPBOX_API_KEY;
    exports.MAPBOX_GEOCODER_API_KEY = MAPBOX_GEOCODER_API_KEY;
    exports.MapComponent = MapComponent;
    exports.MapService = MapService;
    exports.NgxMapboxGLModule = NgxMapboxGLModule;
    exports.a = GeocoderControlDirective;
    exports.b = LayerComponent;
    exports.c = DraggableDirective;
    exports.d = FeatureComponent;
    exports.e = ImageComponent;
    exports.f = VectorSourceComponent;
    exports.g = RasterDemSourceComponent;
    exports.h = RasterSourceComponent;
    exports.i = ImageSourceComponent;
    exports.j = VideoSourceComponent;
    exports.k = CanvasSourceComponent;
    exports.l = MarkerComponent;
    exports.m = PopupComponent;
    exports.n = FullscreenControlDirective;
    exports.o = NavigationControlDirective;
    exports.p = GeolocateControlDirective;
    exports.q = AttributionControlDirective;
    exports.r = ScaleControlDirective;
    exports.s = PointDirective;
    exports.t = ClusterPointDirective;
    exports.u = MarkersForClustersComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-mapbox-gl.umd.js.map
